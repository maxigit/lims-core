filename='lib/common.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_common.rb__ > $filename
# requirement used by  everything
require 'facets/string'
require 'facets/kernel'
require 'facets/hash'
require 'facets/array'

require 'virtus'
require 'aequitas/virtus_integration'

class Object
  def andtap(&block)
    self && (block ? block[self] : self)
  end
end

__END_OF_common.rb__
filename='lib/lims-core/actions/action.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_action.rb__ > $filename
require 'common'

require  'virtus'
require 'facets/ostruct'

module Lims::Core
  module Actions
    # This mixin add the Action behavior to a class.
    # An action can be called and reverted (if possible) within a {Persistence::Session session}.
    # For this, the action must implements the {Action::AfterEval#_call_in_session _call_in_session} and {Action::AfterEval#_revert_in_session _revert_in_session}.
    # Those methods are private and take a session as a parameter.
    # The public equivalent (call/revert) will create a session (using the store) and call the corresponding methods.

    module Action
      UnrevertableAction = Class.new(StandardError)
      def self.included(klass)
        klass.class_eval do
          include Virtus
          include Aequitas
          attribute :store, String, :required => true
          attribute :user, String, :required => true
          attribute :application, String, :required => true
          attribute :result, Object
          include AfterEval # hack so initialize would be called properly
        end
      end

      InvalidParameters = Class.new(RuntimeError)

      module AfterEval
        # Initialize a new actions
        # 'Common' parameters are set as argument
        # whereas specific ones are set on a dummy object via the block.
        # The block is executed within a session allowing to find object form id, etc.

        def initialize(*args, &initializer)
          @initializer = initializer
          super(*args)
        end

        # Executes the action.
        # This is a wrapper around _call_in_session,
        # and it shouldn't be overriden.
        # A block can be passed to  be evaluated with the session after the save session been saved.
        # This is usefull to get ids of saved object.
        # False will be returned if the action failed (or parameters are invalid)
        # @return the value return by the block
        # @yieldparam [Action] a self
        # @yieldparam [Session]  session the current session.
        def call(&after_save)
          after_save ||= lambda { |a,s| a.result }
          with_session do |s| 
            self.result = _call_in_session(s)

            _objects_to_save.each do |a| 
              s << a 
            end

            lambda { after_save[self, s] }
          end.andtap { |block| block.call }
        end

        # Execute the opposite of the action if possible.
        # This a wrapper around _revert_in_session,
        # and shouldn't be overriden.
        # @raise UnrevertableAction
        def revert()
          with_session { |s| _revert_in_session(s) }
        end

        # Execute the given block within a new session.
        # Validates the action and fill #errors if needed
        # @return [Object, False]
        def with_session(*args, &block)
          @store.with_session(*args) do |session|
            # initialize action
            if @initializer
              params = OpenStruct.new
              @initializer[params, session]
              set_attributes(params)
              @initializer = nil
            end

            block.call(session) if valid?
          end
        end

        # This is the main method of an action,
        # called to effectively perform an action.
        def _call_in_session(session)
          raise NotImplementedError
        end

        # how to revert the action,
        # if possible.
        def _revert_in_session(session)
          raise UnrevertableAction(self)
        end

        # List of objects to save (add to the session).
        # By default get all attributes and the resulth.
        # Override if need (to add a created resource for example).
        # @return a list of object to save
        def _objects_to_save
          [result, *attributes.map { |a| a[1] }].select { |o| o.is_a?(Resource) }
        end
        private :_call_in_session, :_revert_in_session, :_objects_to_save
      end
    end
  end
end
__END_OF_action.rb__
filename='lib/lims-core/actions/container.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_container.rb__ > $filename
module Lims::Core
  module Actions
    module Container

      def self.included(klass)
        klass.class_eval do
          include Virtus
          include Aequitas

          %w(row column).each do |w|
            attribute :"number_of_#{w}s",  Fixnum, :required => true, :gte => 0, :writer => :private
          end
        end
      end

      # The specific container should implement this method
      # and return the proper container class
      # i. e. : Laboratory::Gel
      def container_class
        raise NotImplementedError
      end

      # The specific container should implement this method
      # and return the property name of specific container's element
      # i. e. : windows_description
      def element_description
        raise NotImplementedError
      end

      # The specific container should implement this method
      # and return the container name
      # i. e. : "gel"
      def container_symbol
        raise NotImplementedError
      end
 
      # Return the default parameters to create a new container 
      def container_parameters
        {:number_of_rows => number_of_rows, :number_of_columns => number_of_columns}
      end

      def _call_in_session(session)
        new_container = container_class.new(container_parameters)
        session << new_container
        element_description.each do |element_name, aliquots|
          aliquots.each do |aliquot|
            new_container[element_name] <<  Laboratory::Aliquot.new(aliquot)
          end
        end
        { container_symbol => new_container, :uuid => session.uuid_for!(new_container) }
      end
    end
  end
end
__END_OF_container.rb__
filename='lib/lims-core/actions/create_batch.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_create_batch.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2  spell:spelllang=en  
require 'lims/core/actions/action'
require 'lims/core/organization/batch'

module Lims::Core
  module Actions
    class CreateBatch
      include Action

      attribute :process, String, :required => false, :writer => :private

      def _call_in_session(session)
        batch = Organization::Batch.new(:process => process)
        session << batch
        {:batch => batch, :uuid => session.uuid_for!(batch)}
      end

    end
  end
  module Organization
    class Batch
      Create = Actions::CreateBatch
    end
  end
end
__END_OF_create_batch.rb__
filename='lib/lims-core/actions/create_flowcell.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_create_flowcell.rb__ > $filename
#create_flowcell.rb
require 'lims/core/actions/action'

require 'lims/core/laboratory/flowcell'

module Lims::Core
  module Actions
    class CreateFlowcell
      include Action

      attribute :number_of_lanes, Fixnum, :required => true, :gte => 0, :writer => :private

      # @attribute [Hash<String>, Array<Hash>>] lanes_description
      # @example
      #   { "1" => [{ :sample => s1, :quantity => 2}, {:sample => s2}] }
      # # the keys are a String and start a 1 for the firt lane.
      attribute :lanes_description, Hash, :default => {}

      def _call_in_session(session)
        flowcell = Laboratory::Flowcell.new(:number_of_lanes => number_of_lanes)
        session << flowcell
        lanes_description.each do |lane_name, aliquots|
          aliquots.each do |aliquot|
            flowcell[lane_name.to_i-1] <<  Laboratory::Aliquot.new(aliquot)
          end
        end
        { :flowcell => flowcell, :uuid => session.uuid_for!(flowcell) }
      end
    end
  end
  module Laboratory
    class Flowcell
      Create = Actions::CreateFlowcell
    end
  end
end
__END_OF_create_flowcell.rb__
filename='lib/lims-core/actions/create_gel.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_create_gel.rb__ > $filename
require 'lims/core/actions/action'

require 'lims/core/laboratory/gel'
require 'lims/core/actions/container'

module Lims::Core
  module Actions
    class CreateGel
      include Action
      include Container

      # @attribute [Hash<String, Array<Hash>>] windows_description
      # @example
      #   { "A1" => [{ :sample => s1, :quantity => 2}, {:sample => s2}] }
      attribute :windows_description, Hash, :default => {}

      def container_class
        Laboratory::Gel
      end

      def element_description
        windows_description
      end

      def container_symbol
        :gel
      end
    end
  end

  module Laboratory
    class Gel
      Create = Actions::CreateGel
    end
  end
end
__END_OF_create_gel.rb__
filename='lib/lims-core/actions/create_label.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_create_label.rb__ > $filename
# create_labellable.rb
require 'lims/core/actions/action'

require 'lims/core/laboratory/labellable'

module Lims::Core
  module Actions
    class CreateLabel
      include Action

      attribute :labellable, Lims::Core::Laboratory::Labellable, :required => true, :writer => :private, :initializable => true
      attribute :type, String, :required => true, :writer => :private, :initializable => true
      attribute :value, String, :required => true, :writer => :private, :initializable => true
      attribute :position, String, :required => true, :writer => :private, :initializable => true

      def _validate_parameters
        raise InvalidParameters, 
          "Labellable object is not exist! We can not add label to it." if labellable.nil?
      end

      def _call_in_session(session)
        label = Laboratory::Labellable::Label.new(:type => type,
                                      :value => value)

        labellable[position] = label

        session << labellable

        labellable
      end

    end
  end

  module Laboratory
    class Labellable
      Update = Actions::CreateLabel
    end
  end
end
__END_OF_create_label.rb__
filename='lib/lims-core/actions/create_labellable.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_create_labellable.rb__ > $filename
# create_labellable.rb
require 'lims/core/actions/action'

require 'lims/core/laboratory/labellable'

module Lims::Core
  module Actions
    class CreateLabellable
      include Action

      attribute :name, String, :required => true, :writer => :private, :initializable => true
      attribute :type, String, :required => true, :writer => :private, :initializable => true
      attribute :labels, Hash, :default => {}, :writer => :private, :initializable => true

      def _call_in_session(session)
        labellable = Laboratory::Labellable.new(:name => name,
                                                :type => type)

        labels.each { |position, label|
          created_label = Laboratory::Labellable::Label.new(:type => label["type"],
                                                    :value => label["value"])

          labellable[position]= created_label
        }

        session << labellable

        { :labellable => labellable, :uuid => session.uuid_for!(labellable) }
      end
    end
  end
  module Laboratory
    class Labellable
      Create = Actions::CreateLabellable
    end
  end
end
__END_OF_create_labellable.rb__
filename='lib/lims-core/actions/create_order.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_create_order.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2  spell:spelllang=en  
require 'lims/core/actions/action'
require 'lims-core/organization/order'

module Lims::Core
  module Actions
      # sources and targets represent the {Organization::Order} order {Organization::Order::Item items}.
      # source items get a "done" status and
      # target items get a "pending" status on creation. 
    class CreateOrder
      include Action

      attribute :pipeline, String
      attribute :parameters, Hash, :default => {}
      # @attribute [Hash<String, String>] sources
      # @example
      #   { "role" => "{uuid of the underlying object}"}
      attribute :sources, Base::HashString, :default => {}
      # @attribute [Hash<String, String>] targets
      attribute :targets, Base::HashString, :default => {}
      #   { "role" => "{uuid of the underlying object}",
      #     "role1" => nil}
      attribute :study, Organization::Study, :required => true
      attribute :cost_code, String, :required => true

      def _call_in_session(session)
        order = Organization::Order.new(:creator => user,
                                        :pipeline => pipeline,
                                        :parameters => parameters,
                                        :study => study,
                                        :cost_code => cost_code) 

        sources.each { |role, uuid| order.add_source(role, uuid) }
        targets.each { |role, uuid| order.add_target(role, uuid) }

        session << order
        { :order => order, :uuid => session.uuid_for!(order) }
      end
    end
  end
  module Organization
    class Order
      Create = Actions::CreateOrder
    end
  end
end
__END_OF_create_order.rb__
filename='lib/lims-core/actions/create_plate.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_create_plate.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2  spell:spelllang=en  
require 'lims/core/actions/action'

require 'lims/core/laboratory/plate'
require 'lims/core/actions/container'

module Lims::Core
  module Actions
    class CreatePlate
      include Action
      include Container

      # @attribute [Hash<String, Array<Hash>>] wells_description
      # @example
      #   { "A1" => [{ :sample => s1, :quantity => 2}, {:sample => s2}] }
      attribute :wells_description, Hash, :default => {}
      # Type is the actual type of the plate, not the role in the order.
      attribute :type, String, :required => false, :writer => :private 

      def container_class
        Laboratory::Plate
      end

      def element_description
        wells_description
      end

      def container_symbol
        :plate
      end

      def container_parameters
        super.merge(:type => type)
      end
    end
  end

  module Laboratory
    class Plate
      Create = Actions::CreatePlate
    end
  end
end
__END_OF_create_plate.rb__
filename='lib/lims-core/actions/create_search.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_create_search.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2  spell:spelllang=en  
require 'lims/core/actions/action'

require 'lims/core/persistence/search'
require 'lims/core/persistence/multi_criteria_filter'
require 'lims/core/persistence/label_filter'
require 'lims/core/persistence/order_filter'
require 'lims/core/persistence/batch_filter'

module Lims::Core
  module Actions
    class CreateSearch
      include Action

      attribute :description, String, :required => true
      attribute :model, String, :required => true
      attribute :criteria, Hash, :required => true

      def _call_in_session(session)
        # Create the appropriate filter depending on the criteria
        filter = case [criteria.size, criteria.keys.first.to_s]
                 when [1, "label"] then Persistence::LabelFilter.new(:criteria => criteria)
                 when [1, "order"] then Persistence::OrderFilter.new(:criteria => criteria)
                 when [1, "batch"] then Persistence::BatchFilter.new(:criteria => criteria)
                 else Persistence::MultiCriteriaFilter.new(:criteria => criteria)
                 end

        search = Persistence::Search.new(:description => description, 
                                         :model => session.send(model).model, 
                                         :filter => filter)
        if search.valid?   
          stored_search = session.search[search.attributes]
          if stored_search.nil?
            session << search
          else 
            search = stored_search
          end
          { :search => search, :uuid => session.uuid_for!(search) }
        else
          false
        end
      end
    end
  end
  module Persistence
    class Search
      Create = Actions::CreateSearch
    end
  end
end
__END_OF_create_search.rb__
filename='lib/lims-core/actions/create_spin_column.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_create_spin_column.rb__ > $filename
require 'lims/core/actions/action'
require 'lims/core/laboratory/spin_column'

module Lims::Core
  module Actions
    class CreateSpinColumn
      include Action

      attribute :aliquots, Array, :default => []

      def initialize(*args, &block)
        @name = "Create Spin Column"
        super(*args, &block)
      end

      def _call_in_session(session)
        spin_column = Laboratory::SpinColumn.new()
        session << spin_column
        aliquots.each do |aliquot|
          spin_column << Laboratory::Aliquot.new(aliquot)
        end
        { :spin_column => spin_column, :uuid => session.uuid_for!(spin_column) }
      end
    end
  end

  module Laboratory
    class SpinColumn
      Create=Actions::CreateSpinColumn
    end
  end
end
__END_OF_create_spin_column.rb__
filename='lib/lims-core/actions/create_tube.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_create_tube.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2  spell:spelllang=en  
require 'lims/core/actions/action'

require 'lims/core/laboratory/tube'

module Lims::Core
  module Actions
    class CreateTube
      include Action

      attribute :aliquots, Array, :default => []
      attribute :type, String, :required => false, :writer => :private
      attribute :max_volume, Numeric, :required => false, :writer => :private

      def initialize(*args, &block)
        @name = "Create Tube"
        super(*args, &block)
      end

      def _call_in_session(session)
        tube = Laboratory::Tube.new(:type => type, :max_volume => max_volume)
        session << tube
        aliquots.each do |aliquot|
          tube << Laboratory::Aliquot.new(aliquot)
        end
        { :tube => tube, :uuid => session.uuid_for!(tube) }
      end
    end
  end
  module Laboratory
    class Tube
      Create=Actions::CreateTube
    end
  end
end
__END_OF_create_tube.rb__
filename='lib/lims-core/actions/create_tube_rack.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_create_tube_rack.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2  spell:spelllang=en  
require 'lims/core/actions/action'
require 'lims/core/laboratory/tube_rack'

module Lims::Core
  module Actions
    class CreateTubeRack
      include Action

      %w(row column).each do |w|
        attribute :"number_of_#{w}s", Fixnum, :required => true, :gte => 0, :writer => :private
      end

      # @attribute [Hash<String, Laboratory::Tube>] tubes description
      # @example
      #     {"A1" => tube_1, "B4" => tube_2}
      attribute :tubes, Hash, :default => {}

      def _call_in_session(session)
        tube_rack = Laboratory::TubeRack.new(:number_of_columns => number_of_columns, :number_of_rows => number_of_rows)
        session << tube_rack

        tubes.each do |position, tube|
          tube_rack[position] = tube
        end

        {:tube_rack => tube_rack, :uuid => session.uuid_for!(tube_rack)}
      end
    end
  end

  module Laboratory
    class TubeRack
      Create = Actions::CreateTubeRack
    end
  end
end

__END_OF_create_tube_rack.rb__
filename='lib/lims-core/laboratory/plate/plate_transfer.rb
mkdir -p $(dirname $filename)
cat <<__END_OF_plate_transfer.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2  spell:spelllang=en  
require 'lims/core/actions/action'
require 'lims/core/actions/transfer_action'

require 'lims/core/laboratory/plate'

module Lims::Core
  module Laboratory
    # This {Action}  transfer the content between too plate.
    # At the moment there are no quantity associated  to the transfer.
    # It take a source and a target plate and a map telling which wells go in were.
    # For more details, see attributes.
    class Plate::PlateTransfer
      include Action
      include TransferAction

      attribute :source, Laboratory::Plate, :required => true, :writer => :private
      attribute :target, Laboratory::Plate, :required => true, :writer => :private
      attribute :transfer_map, Hash, :required => true, :writer => :private
      attribute :aliquot_type, String, :required => false, :writer => :private


      # transfer the content of from source to target according to map
      # If aliquot_type is given, it sets the type on all the aliquots
      # of the target plate.
      def _call_in_session(session)
        transfers = _transfers
        transfer_hash = _transfer(transfers, _amounts(transfers), session)
        transfer_hash[:targets].first
      end

    end
  end
end
__END_OF_plate_transfer.rb__
filename='lib/lims-core/actions/tag_wells.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_tag_wells.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2  spell:spelllang=en  
require 'lims/core/actions/action'

require 'lims/core/laboratory/plate'

module Lims::Core
  module Laboratory
    class TagWells
      include Action

      attribute :plate, Laboratory::Plate, :writer => :private
      attribute :well_to_tag_map, Hash, :writer => :private
      def _call_in_session(session)
        well_to_tag_map.each do |well_name, tag| 
          well = plate[well_name]
          well.each do |aliquot|
            aliquot.tag = tag
          end
        end
      end
    end
  end
end
__END_OF_tag_wells.rb__
filename='lib/lims-core/actions/transfer_action.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_transfer_action.rb__ > $filename
module Lims::Core
  module Laboratory
    module TransferAction

      def self.included(klass)
        klass.class_eval do

          # Converts the fraction to amount and store it in an array
          def _amounts(transfers)
            amounts = []
            transfers.each do |transfer|
              # simplify the transfer related variables
              source = transfer["source"]
              from = transfer["source_location"]
              fraction = transfer["fraction"]
              amount = transfer["amount"]

              # in case if plate-like object
              source = source[from] if from

              # Converts the fraction to the amount of the aliquot
              # and use it later when transfering to the target asset
              if fraction
                amounts << (source.quantity ? source.quantity * fraction : nil)
              else
                amounts << amount
              end
            end
            amounts
          end

          # Do the transfers from source asset(s) to target asset(s)
          # It is working for tube-like and plate-like asset(s), too.
          def _transfer(transfers, amounts, session)
            sources = []
            targets = []

            transfers.zip(amounts) do |transfer, amount|
              # simplify the transfer related variables
              source = transfer["source"]
              from = transfer["source_location"]
              target = transfer["target"]
              to = transfer["target_location"]
              aliquot_type = transfer["aliquot_type"]

              # do the element transfer according to the given transfer (map)
              target_element, source_element = nil, nil
              if from
                source_element = source[from]
                target_element = target[to]
              else
                source_element = source
                target_element = target
              end
              target_element << source_element.take_amount(amount)

              # change the aliquot_type of the target
              unless aliquot_type.nil?
                target_element.each do |aliquot|
                  aliquot.type = aliquot_type
                end
              end

              sources << source
              targets << target

            end

            { :sources => sources.uniq, :targets => targets.uniq}
          end

          def _transfers
            transfers = []
            transfer_map.each do |from, to|
              transfers <<
                { "source" => source,
                  "source_location" => from,
                  "target" => target,
                  "target_location" => to,
                  "fraction" => 1,
                  "aliquot_type" => aliquot_type
                }
            end
            transfers
          end

        end
      end
    end
  end
end
__END_OF_transfer_action.rb__
filename='lib/lims-core/actions/transfer_plates_to_plates.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_transfer_plates_to_plates.rb__ > $filename
require 'lims/core/actions/action'
require 'lims/core/actions/transfer_action'
require 'lims/core/actions/transfers_parameters'

module Lims::Core
  module Laboratory

    # This {Action} transfers the given fraction and type of aliquot from plate-like asset(s)
    # to plate-like asset(s).
    # It takes an array, which contains transfer elements.
    # An element has a source, source_location, target, target_location,
    # amount/fraction and aliquot_type parameters.
    # Source and targets are plate-like assets (plates, gel plates or tube racks).
    # The source/target_location is the well/window/tube location (like "A1") from
    # transfer the aliquots and to transfer the aliquots.
    # Amount is an amount of an aliquot to transfer.
    # Fraction is the fraction of an aliquot to transfer.
    # You should give the fraction OR the amount of the transfer, not both of them.
    # Aliquot_type is the type of the aliquot (DNA, RNA, NA, sample etc...).
    class TransferPlatesToPlates
      include Action
      include TransferAction
      include TransfersParameters

      # transfer the given fraction of aliquot from plate-like asset(s)
      # to plate-like asset(s)
      def _call_in_session(session)

        _transfer(transfers, _amounts(transfers), session)

      end
    end
  end
end
__END_OF_transfer_plates_to_plates.rb__
filename='lib/lims-core/actions/transfer_tubes_to_tubes.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_transfer_tubes_to_tubes.rb__ > $filename
require 'lims/core/actions/action'
require 'lims/core/actions/transfer_action'
require 'lims/core/actions/transfers_parameters'

require 'lims/core/laboratory/spin_column'
require 'lims/core/laboratory/tube'

module Lims::Core
  module Laboratory

    # This {Action} transfers the given fraction and type of aliquot from tube-like asset(s)
    # to tube-like asset(s).
    # It takes an array, which contains transfer elements. 
    # An element has a source, target, amount, fraction and type parameter.
    # Source and targets are tube-like assets (a tube or spin column).
    # Amount is an amount of an aliquot to transfer.
    # Fraction is the fraction of an aliquot to transfer.
    # Type is the type of the aliquot.
    class TransferTubesToTubes
      include Action
      include TransferAction
      include TransfersParameters

      # transfer the given fraction of aliquot from tube-like asset(s)
      # to tube-like asset(s)
      def _call_in_session(session)

        _transfer(transfers, _amounts(transfers), session)

      end
    end
  end
end
__END_OF_transfer_tubes_to_tubes.rb__
filename='lib/lims-core/actions/transfer_wells_to_tubes.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_transfer_wells_to_tubes.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2  spell:spelllang=en  
require 'lims/core/actions/action'

require 'lims/core/laboratory/plate'
require 'lims/core/laboratory/tube'

module Lims::Core
  module Laboratory
    # This {Action}  transfer the content between too plate.
    # At the moment there are no quantity associated  to the transfer.
    # It take a source and a target plate and a map telling which wells go in were.
    # For more details, see attributes.
    class TransferWellsToTubes
      include Action

      attribute :plate, Laboratory::Plate, :required => true, :writer => :private
      attribute :well_to_tube_map, Hash, :required => true, :writer => :private

      def _validate_parameters
        tubes = well_to_tube_map.values
        raise InvalidParameters, "Many wells go in the same tube" if tubes.uniq.size != tubes.size
      end
      # transfer the content of  from source to target according to map
      def _call_in_session(session)
          well_to_tube_map.each do |well , tube|
            tube << plate[well].take_fraction(1)
          end
      end
    end
  end
end
__END_OF_transfer_wells_to_tubes.rb__
filename='lib/lims-core/actions/transfers_parameters.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_transfers_parameters.rb__ > $filename
module Lims::Core
  module Laboratory

    # This module holds the parameter of transfer related action like TransfersPlatesToPlates
    # and TransferTubesToTubes and the validation of these parameters.
    module TransfersParameters

      def self.included(klass)
        klass.class_eval do
          attribute :transfers, Array, :required => true, :writer => :private

          def _validate_parameters
            raise ArgumentError, "The transfer array should not be null." unless transfers
            raise ArgumentError, "You should give the fraction OR the amount of the transfer, not both." unless valid_amount_and_fraction
          end

          def valid_amount_and_fraction
            valid = true
            transfers.each do |transfer|
              if (transfer["fraction"].nil? && transfer["amount"].nil?) || (transfer["fraction"] && transfer["amount"])
                valid = false
                break
              end
            end
            valid
          end

        end
      end
    end
  end
end
__END_OF_transfers_parameters.rb__
filename='lib/lims-core/laboratory/tube/tube_rack_move.rb
mkdir -p $(dirname $filename)
cat <<__END_OF_tube_rack_move.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2  spell:spelllang=en 
require 'lims/core/actions/action'
require 'lims/core/laboratory/tube_rack'

module Lims::Core
  module Laboratory
    # This {Action} moves physically tubes from source racks
    # to target racks.
    # It takes an array, which contains the elements of the movement.
    # An element has a source, source_location, target and target_location.
    # Source and targets are tube racks.
    # The source/target_location is the tube location (like "A1") from
    # move the tube and to move the tube.
    class Tube::TubeRackMove
      include Action

      attribute :moves, Array, :required => true, :writer => :private

      # Move tubes from source tube racks to target
      # tube racks. If a tube is already present in the
      # target location, a RackPositionNotEmpty exception
      # is raised in the Laboratory::TubeRack class.
      # The tube is removed from the source tube rack 
      # after moving to its target location.
      def _call_in_session(session)
        targets = []
        moves.each do |move|
          source = move["source"]
          from = move["source_location"]
          target = move["target"]
          to = move["target_location"]

          unless source[from].nil?
            target[to] = source[from]
            source[from] = nil
          end

          targets << target
        end

        targets.uniq
      end

    end
  end
end
__END_OF_tube_rack_move.rb__
filename='lib/lims-core/laboratory/tube/tube_rack_transfer.rb
mkdir -p $(dirname $filename)
cat <<__END_OF_tube_rack_transfer.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2  spell:spelllang=en  
require 'lims/core/actions/action'
require 'lims/core/laboratory/tube_rack'

module Lims::Core
  module Laboratory
    # This action transfers the content of a source tube rack
    # to a target tube rack according to a transfer map.
    class Tube::TubeRackTransfer
      include Action

      attribute :source, Laboratory::TubeRack, :required => true, :writer => :private
      attribute :target, Laboratory::TubeRack, :required => true, :writer => :private
      attribute :transfer_map, Hash, :required => true, :writer => :private

      # Exception raised after an attempt to transfer
      # the content of a tube to an empty rack location.
      class NoTubeInTargetLocation < StandardError
      end

      # Transfer the content from a source tube rack to a target
      # tube rack according to a transfer map. If the transfer
      # map specifies a target location which is actually empty
      # (no tube), a NoTubeInTargetLocation exception is raised.
      # If the transfer map specifies a source location which is 
      # empty (no tube), nothing happens.
      def _call_in_session(session)
        transfer_map.each do |from, to|
          raise NoTubeInTargetLocation, "#{to} location is empty" unless target[to].is_a? Laboratory::Tube

          unless source[from].nil?
            target[to] << source[from].take_fraction(1)
          end
        end
        target
      end
    end
  end
end
__END_OF_tube_rack_transfer.rb__
filename='lib/lims-core/actions/update_order.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_update_order.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2  spell:spelllang=en  
require 'lims/core/actions/action'

require 'lims/core/organization/order'

module Lims::Core
  module Laboratory
    class UpdateOrder
      include Action

      #@ attribute :order
      #  The order to update.
      attribute :order, Organization::Order
      # @attribute :items
      #   a Hash of Hash of Items to *add* or *update*
      #   key are the role name
      #   value are a Hash of items with
      #      key being either the item uuid, #   and index, or last for insert
      #      value either a uuid (String) or an event (Symbol) to send to the current item.
      # {:role => {'11111111-1111-2222-3333-444444444444' => 
      #     {:event => :start,
      #      :batch_uuid => '111111111-0000-0000-0000-111111111111'}}}
      # or
      # {:role => {'1' => {:event => :start}}}
      attribute :items, Hash , :default => {}
      attribute :event, Symbol 
      attribute :pipeline, String
      attribute :study, Organization::Study
      attribute :creator, Organization::User
      attribute :cost_code, String
      attribute :parameters, Hash
      attribute :state, Hash

      def _call_in_session(session)
        items.each { |role, args| update_item(role, args) }
        if event.present?
          order.public_send("#{event}!")
        end
        %w[pipeline creator cost_code study parameters state].each do |key|
          value = self[key]
          order[key] = value if value
        end
        {:order => order }
      end

      def update_item(role, args)
        items = order.fetch(role) { |k|  order[k]= [] }

        args.each do |key, item_args|
          item = case key
          when /\\A\\d+\\z/
            items[key.to_i]
          when "last"
            Organization::Order::Item.new.tap { |item|  items << item }
          else # uuid
            # Lookup item by uuid
            # If we don't find it
            # we need to create it and add it.
            # If there are two, we raise an error.
            founds = items.select { |i| i.uuid == key }
            case founds.size
            when 0
              Organization::Order::Item.new(:uuid => key).tap { |item| items << item }
            when 1
              founds.first
            else
              raise InvalidParameters, "there are too many items with the uuid #{key} for role '#{role}'"
            end
          end

          item_args["uuid"].andtap { |uuid| item.uuid = uuid }
          item_args["event"].andtap { |event| item.public_send("#{event}!") }
          item_args["batch"].andtap { |batch| item.batch = batch }
        end
      end
    end
  end

  module Organization
    class Order
      Update = Actions::UpdateOrder
    end
  end
end
__END_OF_update_order.rb__
filename='lib/lims-core/actions/update_plate.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_update_plate.rb__ > $filename

# vi: ts=2:sts=2:et:sw=2  spell:spelllang=en  
require 'lims/core/actions/action'

require 'lims/core/laboratory/plate'

module Lims::Core
  module Laboratory
    # Update a plate and set a new type and/or a new quantity to 
    # all its aliquots.
    class UpdatePlate
      include Action

      # The plate to update
      attribute :plate, Laboratory::Plate, :required => true, :writer => :private
      attribute :aliquot_type, String, :required => false, :writer => :private
      attribute :aliquot_quantity, Numeric, :required => false, :writer => :private 
      # Type is the actual type of the plate, not the role in the order.
      attribute :type, String, :requried => false, :writer => :private

      def _call_in_session(session)
        plate.type = type if type
        plate.each do |well|
          well.each do |aliquot|
            aliquot.type = aliquot_type if aliquot_type
            aliquot.quantity = aliquot_quantity if aliquot_quantity
          end
        end
        {:plate => plate}
      end
    end
    end

  module Laboratory
    class Plate
      Update = Actions::UpdatePlate
    end
  end
end
__END_OF_update_plate.rb__
filename='lib/lims-core/actions/update_tube.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_update_tube.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2  spell:spelllang=en  
require 'lims/core/actions/action'

require 'lims/core/laboratory/tube'

module Lims::Core
  module Laboratory
    # Update a tube and set a new type and/or a new quantity to 
    # all its aliquots.
    class UpdateTube
      include Action

      # The tube to update
      attribute :tube, Laboratory::Tube, :required => true, :writer => :private
      # On update, all the aliquots in the tube will have the type
      # aliquot_type and the quantity aliquot_quantity.
      attribute :aliquot_type, String, :required => false, :writer => :private
      attribute :aliquot_quantity, Numeric, :required => false, :writer => :private 
      # The actual type of the tube, like Eppendorf.
      attribute :type, String, :required => false, :writer => :private
      attribute :max_volume, Numeric, :required => false, :writer => :private

      def _call_in_session(session)
        tube.type = type if type
        tube.max_volume = max_volume if max_volume
        tube.each do |aliquot|
          aliquot.type = aliquot_type unless aliquot_type.nil?
          aliquot.quantity = aliquot_quantity unless aliquot_quantity.nil?
        end
        {:tube => tube}
      end
    end
  end

  module Laboratory
    class Tube
      Update = Actions::UpdateTube
    end

    # As Tube and SpinColumn behave the same, update a spin column
    # redirects to update a tube action.
    class SpinColumn
      Update = Actions::UpdateTube
    end
  end
end
__END_OF_update_tube.rb__
filename='lib/lims-core/actions/update_tube_rack.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_update_tube_rack.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2  spell:spelllang=en  
require 'lims/core/actions/action'
require 'lims/core/laboratory/tube_rack'

module Lims::Core
  module Laboratory
    # Update a tube rack by updating each of its tube type or quantity.
    class UpdateTubeRack
      include Action

      attribute :tube_rack, Laboratory::TubeRack, :required => true, :writer => :private
      attribute :aliquot_type, String, :required => false, :writer => :private
      attribute :aliquot_quantity, Numeric, :required => false, :writer => :private

      def _call_in_session(session)
        tube_rack.each do |tube|
          if tube
            tube.each do |aliquot|
              aliquot.type = aliquot_type if aliquot_type
              aliquot.quantity = aliquot_quantity if aliquot_quantity
            end
          end
        end
        {:tube_rack => tube_rack}
      end
    end
  end

  module Laboratory
    class TubeRack
      Update = Actions::UpdateTubeRack
    end
  end
end
__END_OF_update_tube_rack.rb__
filename='lib/lims-core/actions.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_actions.rb__ > $filename
#vi: ts=2 sw=2 et spell spelllang=en
# true needed to avoid modeline comment to be seen as Lims::Core doc.
require 'lims/core/actions/action'

module Lims::Core
  # Actions are high level end user groups of elementary steps that a user can perform on things .
  # They can be seen as use-case, scenario  and will probably each correspond to one call in the API.
  module Laboratory
  end
end

unless defined?(Lims::Core::NO_AUTOLOAD)
  require_all('actions/*')
end
__END_OF_actions.rb__
filename='lib/lims-core/base.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_base.rb__ > $filename
# vi: ts=2 sts=2 et sw=2 spell spelllang=en  
require 'common'
require 'lims-core/container'

module Lims::Core
  module Base
    def self.included(klass)
      klass.class_eval do
        include Virtus
        include Aequitas
        include AccessibleViaSuper
        extend Forwardable
        extend ClassMethod
      end
    end

    module AccessibleViaSuper
      def initialize(*args, &block)
        # readonly attributes are normaly not allowed in constructor
        # by Virtus. We need to call set_attributes explicitely
        options = args.extract_options!
        # we would use \`options & [:row ... ]\` if we could
        # but Sequel redefine Hash#& ...
        initializables = self.class.attributes.select {|a| a.options[:initializable] == true  }
        initial_options  = options.subset(initializables.map(&:name))
        set_attributes(initial_options)
        super(*args, options - initial_options, &block).tap {
        }
      end
    end
    # Compare 2 resources.
    # They are == if they have the same values (attributes),
    # regardless they are the same ruby object or not.
    # @param other
    # @return [Boolean]
    def ==(other)
      self.attributes == (other.respond(:attributes) || {} )
    end


    module ClassMethod
      def is_array_of(child_klass, options = {},  &initializer)
        define_method :initialize_array do |*args|
          @content = initializer ? initializer[self, child_klass] : []
        end

        class_eval do
          include Enumerable
          include IsArrayOf
          def_delegators :@content, :each, :size , :each_with_index, :map, :zip, :clear, :empty?, :to_s \\
            , :include?, :to_a, :first, :last

        end
      end

      def is_matrix_of(child_klass, options = {},  &initializer)
        element_name = child_klass.name.split('::').last.downcase
        class_eval do
          is_array_of(child_klass, options, &initializer)
          include Container

          define_method "get_#{element_name}" do |*args|
            get_element(*args)
          end

        end
      end
    end


    module IsArrayOf

      def initialize(*args, &block)
        super(*args, &block)
        initialize_array()
      end

      # Add content to compare
      # If classe are not in the same hierarchy we only compare the content
      # @param other to compare with
      # @return [Boolean]
      def ==(other)
        if other.is_a?(self.class) || self.is_a?(other.class)
          super(other)
        else
          true
        end && self.to_a == other.to_a
      end

      # The underlying array. Use to everything which is not directly delegated 
      # @return [Array]
      def content
        @content 
      end

      # Delegate [] to the underlying array.
      # This is needed because Virtus redefine [] as well 
      # @param [Fixnum, ... ] i index
      # @return [Object]
      def [](i)
        case i
        when Fixnum then self.content[i]
        else super(i)
        end
      end

      def []=(i, value)
        case i
        when Fixnum then self.content[i]=value
        else super(i, value)
        end
      end
      # iterate only between non empty lanes.
      # @yield [content]
      # @return itself
      def each_content
        @content.each do |content|
          yield content if content
        end
      end
    end 

    class HashString < Virtus::Attribute::Object
      primitive Hash
      def coerce(hash)
        hash.rekey  {|key| key.to_s }
      end
    end

    # @todo override state_machine to automatically add
    # attribute
    class State < Virtus::Attribute::Object
      primitive String
    end
  end
end
__END_OF_base.rb__
filename='lib/lims-core/container.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_container.rb__ > $filename
require 'common'

module Lims
  module Core
    # A container is an a laboratory pieces
    # containing other laboratory pieces.
    # Example, a plate or a tube rack.
    module Container
      def self.included(klass)
        klass.extend ClassMethods

        # each_with_index needs to be evaluated using
        # class_eval on Container module inclusion to 
        # redefine the method each_with_index. Otherwise,
        # the normal each_with_index is called as when a 
        # module is included, its methods are placed right 
        # above the class' methods in inheritance chain.
        klass.class_eval do
          include Virtus
          include Aequitas

          %w(row column).each do |w|
            attribute :"number_of_#{w}s", Fixnum, :required => true, :gte => 0, :writer => :private, :initializable => true
          end

          # each is already defined to look like an Array.
          # This one provide a "String" index (like "A1") aka
          # element name. It can be used to access the Container.
          def each_with_index
            @content.each_with_index do |well, index|
              yield well, index_to_element_name(index)
            end
          end
        end
      end

      IndexOutOfRangeError = Class.new(RuntimeError)

      module AccessibleViaSuper
        def [](index)
          case index
          when Array
            get_element(*index)
          when /\\A([a-zA-Z])(\\d+)\\z/
            get_element(\$1, \$2)
            # why not something like
            # get_well(*[\$1, \$2].zip(%w{A 1}).map { |a,b| [a,b].map(&:ord).inject { |x,y| x-y } })
          when Symbol
            self[index.to_s]
          else
            super(index)
          end
        end
      end
      # We need to do that so is_array can call it via super
      include AccessibleViaSuper

      # Hash behavior

      # Provides the list of the element names, equivalent to
      # the Hash#keys methods.
      # @return [Array<String>]
      def keys
        0.upto(size-1).map { |i| index_to_element_name(i) }
      end

      # List of the elements, equivalent to Hash#values
      def values
        @content
      end

      def indexes_to_element_name(row, column)
        self.class.indexes_to_element_name(row, column)
      end

      # Convert an index to String
      # @param [Fixnum] index (stating at 0)
      # @return [String] ex "A1"
      # @todo memoize if needed
      def index_to_element_name(index)
        row = index / number_of_columns
        column = index % number_of_columns

        indexes_to_element_name(row, column)
      end

      # Converts an element name to an index of the underlying container
      # The result could be from 0 to size - 1
      def element_name_to_index(row_str, col_str)
        row = row_str.ord - ?A.ord if row_str.is_a?(String)
        col = col_str.to_i - 1 if col_str.is_a?(String)
        raise IndexOutOfRangeError unless (0...number_of_rows).include?(row)
        raise IndexOutOfRangeError unless (0...number_of_columns).include?(col)
        row*number_of_columns + col
      end

      # return a element from a 2D index
      # Also check the boundary
      # @param [Fixnum] row index of the row (starting at 0)
      # @param [Fixnum] col index of the column (starting at 0)
      # @return [Object]
      def get_element(row, col)
        @content[element_name_to_index(row, col)]
      end
      private :get_element


      module ClassMethods
        def indexes_to_element_name(row, column)
          "#{(row+?A.ord).chr}#{column+1}"
        end 
      end
    end
  end
end
__END_OF_container.rb__
filename='lib/lims-core/laboratory/aliquot.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_aliquot.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2 spell:spelllang=en  
require 'common'


require 'lims/core/laboratory/sample'
require 'lims/core/laboratory/oligo'
require 'lims/core/resource'

module Lims::Core
  module Laboratory
    # An aliquot represent the fraction of identical chemical substance inside a receptacle.
    # it should have:
    # 1. A receptacle
    # 1. A quantity  => volume, weight, moles?
    # 2. An owner (Order?)
    # 3. One or more constituents (sample, tags).
    # 4. A type/shape (gel, library, sample  etc...)
    # Constituents inside an aliquot are bound together, i.e. :
    # - "mixing" sample and tag in a tube without any processing will probably results
    # in a receptacle containing two aliquots, one representing the tag and the other
    # one the sample.
    # - "tagging" a sample with a oligo will result in a receptacle containing one aliquot
    #   representing the tagged sample (the oligo and the sample are bound together).
    # At the moment, rather than allowing an aliquot to have many constituents (in a free form way),
    # an aliquot can be formed of at least a {Laboratory::Sample sample}, a {Laboratory::Oligo tag} and  or a {Laboratory::BaitLibrary bait library}.
    class Aliquot
      include Resource
      attribute :sample, Sample
      attribute :tag, Oligo
      # @todo add a unit to quantity
      attribute :quantity, Numeric, :required=> true, :gte => 0

      # the form of the chemical substance, like library, sample etc ...
      attribute :type, String # Subclass ?

      #validates_presence_of :quantity
      #validates_numericalness_of :quantity, :gte => 0

      # Take a percentage of an aliquot
      # and remove the corresponding quantity
      # 1 (100%) remove everything from the current aliquot
      # nil won't remove anything nor set a quantity on the returned aliquot
      # @param [Float, nil] fraction
      # @return [Aliquot]
      def take_fraction(fraction)
        new = self.class.new(attributes)
        if quantity && fraction
          new_quantity = quantity*fraction
          self.quantity -= new_quantity
          new.quantity = new_quantity
        else
          new.quantity= nil
        end
        return new
      end

      def ===(other)
        to_exclude = [:quantity]
        a, b = [self, other].map { |a| a.attributes - to_exclude }
        a == b
      end


      # The following methods should be in subclass
      # It will need to be move in subclass if we implement subclasses
      module Dimension
        # Dimension
        Volume = :volume
        Mass = :mass
        AmountOfSubstance = :amount_of_substance

        DimensionToUnit = { Volume => "ul", Mass => "mg", AmountOfSubstance => "mole" }

        # Type
        Solvent = "solvent"

        # describe what kind of measure the quantity refers to.
        # @return [String]
        def dimension
          # By default, dimension are AmountOfSubstance except for
          # solvent which are by default liquid, therefore volume.
          case type
          when Solvent then Volume
          else AmountOfSubstance
          end
        end
      end
      include Dimension

      # The unit in which the quantity is store.
      # For example, volume are stored in microlittre
      # so the unit will be ul.
      def unit
        DimensionToUnit[dimension]
      end


      # add the specified amount to the current aliquot quantity, can be nil
      # @param [Float,Nil] quantity
      def increase_quantity(quantity)
        new_quantity = self.class.add_quantity(self.quantity, quantity)
        self.quantity = new_quantity && [0, new_quantity].max

      end

      # add to quantities, work out nil number
      # @param [Number, Nil] q1
      # @param [Number, Nil] q2
      # @return [Number, Nil]
      def self.add_quantity(q1, q2)
        q1 && q2 ? q1+q2 : q1 || q2
      end
    end
  end
end
__END_OF_aliquot.rb__
filename='lib/lims-core/laboratory/barcode_2d.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_barcode_2d.rb__ > $filename
require 'common'

require 'lims-core/laboratory/labellable'

module Lims::Core
  module Laboratory
    class Barcode2D
      include Labellable::Label
      Type = "2d-barcode"
    end
  end
end
__END_OF_barcode_2d.rb__
filename='lib/lims-core/laboratory/ean13_barcode.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_ean13_barcode.rb__ > $filename
require 'common'
require 'lims-core/laboratory/labellable'

module Lims::Core
  module Laboratory
    class EAN13Barcode
      include Labellable::Label
      Type = "ean13-barcode"
    end
  end
end
__END_OF_ean13_barcode.rb__
filename='lib/lims-core/laboratory/flowcell.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_flowcell.rb__ > $filename
require 'lims/core/laboratory/receptacle'
require 'lims/core/resource'

module Lims::Core
  module Laboratory
    # A flowcell with some lanes.
    # readable labels on it.
    # TODO add label behavior
    class Flowcell
      include Resource

      attribute :number_of_lanes, Fixnum, :required => true, :gte => 0, :writer => :private

      # A lane on a {Flowcell flowcell}.
      # Contains some chemical substances.
      class Lane
        include Receptacle

        def to_s()
          content.to_s
        end
      end


      module AccessibleViaSuper
      # @todo move in class method in resource
        def initialize(*args, &block)
          # readonly attributes are normaly not allowed in constructor
          # by Virtus. We need to call set_attributes explicitely
          options = args.extract_options!
          # we would use \`options & [:lane_number ]\` if we could
          # but Sequel redefine Hash#& ...
          number_of_lanes = options.subset([:number_of_lanes])
          set_attributes(number_of_lanes)
          super(*args, options - number_of_lanes, &block)
        end

      end
      # We need to do that so is_array can call it via super
      include AccessibleViaSuper

      is_array_of Lane do |flowcell,t|
        flowcell.number_of_lanes.times.map { t.new }
      end

     # iterate only between non empty lanes.
     # @yield [content]
     # @return itself
     def each_content
       content.each do |content|
         yield content if content
       end
     end
    end
  end
end
__END_OF_flowcell.rb__
filename='lib/lims-core/laboratory/gel.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_gel.rb__ > $filename
require 'lims/core/resource'
require 'lims/core/laboratory/receptacle'

require 'facets/hash'
require 'facets/array'

module Lims::Core
  module Laboratory
    # Gel is a labware as seen in a laboratory.
    # It has a number of rows and number of columns property.
    # Gel contains Windows and has some readable labels on it (i.e. barcode).
    class Gel
      include Resource

      # The window can contain a receptacle, which is a chemical substance.
      class Window
        include Receptacle
      end

      is_matrix_of Window do |gel, window|
        (gel.number_of_rows*gel.number_of_columns).times.map { window.new }
      end

    end
  end
end
__END_OF_gel.rb__
filename='lib/lims-core/laboratory/labellable.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_labellable.rb__ > $filename
require 'common'

module Lims::Core
  module Laboratory
    # A labellable is something which can have one or more labels.
    # By labels we mean any readable information found on a physical oblect.
    # This can be serial number, stick label with barcode etc.
    # {Label} can eventually be identified by a position : an a arbitray string (not a Symbol).
    # The semantic of the position is left to pipeline.
    # A label as a name , unique identifier and a type, which should indicate
    # if it's a resource (plate, tube) an equipment a user etc ...
    # Labellable acts mainly has a hash of location => labels
    class Labellable
      include Resource
      attribute :name, String, :required => true, :writer => :private, :initializable => true
      attribute :type, String, :required => true, :writer => :private, :initializable => true
      attribute :content, Hash, :default => {}, :writer => :private, :initializable => true

      def initialize(*args, &block)
        super(*args, &block)
      end

      include Enumerable
      def_delegators :content, :each, :size, :each_with_index, :map, :zip, :clear, :include? \\
        ,:to_a, :keys, :values, :delete, :fetch



      # We need to redefine [] and []=
      # as Virtus it to computes attributes
      # Therefore, we use the Virtus method for Symbols.
      # Everything else, is redirected to content.
      # i.e. 
      #     labellable[:name]  # == labellable.name
      #     labellable["name"] # label in position "name".
      def [](key)
        case key
        when Symbol
          super(key)
        else
          content[key]
        end
      end

      def []=(key, value)
        case key
        when Symbol
          super(key, value)
        else
          content[key] = value
        end
      end

      def empty?
        false
      end

      # Return all positions
      # @return [Array<String>]
      def positions
        content.keys
      end


      # @return [Array<Label>]
      def labels
        content.values
      end

      def self.type_to_class
        @@type_to_class ||= begin

      end
    end

    # Mixin needed by Object wanted to be 
    # attached to a Labellable
    # Its value correspond to what will be scanned and what will be
    # looked up in the database.
    # The actual formatting of it to the final user would be done
    # in the API server
    # Type needs to be defind by the class in the initializing
    module Label
      @@subclasses = Set.new()
      def self.included(klass)
        klass.instance_eval do
          include Resource
          include After
          attribute :value, String, :required => true
          attribute :type, String, :writter => true, :required => true
        end

        @@subclasses << klass
      end

      def self.new(attributes)
        type = attributes.delete(:type)
        klass = type_to_class(type)
        raise RuntimeError, "No class associated to label type '#{type}'" unless klass
        klass.new(attributes)
      end

      def self.type_to_class(type)
        @@type_to_subclass ||= @@subclasses.mash { |s| [s::Type, s] }
        @@type_to_subclass[type]
      end


      module After
        def initialize(*args, &block)
          @type = self.class::Type
          super(*args, &block)
        end
      end
    end
  end
end
end
require 'lims/core/laboratory/barcode_2d'
require 'lims/core/laboratory/sanger_barcode'
require 'lims/core/laboratory/ean13_barcode'
__END_OF_labellable.rb__
filename='lib/lims-core/laboratory/oligo.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_oligo.rb__ > $filename
require 'common'

require 'lims/core/resource'
require 'forwardable'

module Lims::Core
  module Laboratory
    # A tag is a sequence of DNA meant to be bound to a sample to recognize
    # from other samples in the same multiplex.
    class Oligo
      include Resource
      include Forwardable
      attribute :sequence, String, :writer => :protected, :initializable => true

        # @param [String, Hash] sequence a Sequence or attribute set.
      def initialize(sequence)
        args = {}
        case sequence
        when String then args[:sequence] = sequence
        when Hash then args = sequence
        end

        super(args)
      end

      def ==(other)
        case other
          when String  then  sequence == other
          when Oligo then sequence == other.sequence
          else false
          end
      end


      def_delegators :@sequence, :each, :size, :map
      def to_s
        @sequence.to_s
      end
    end
  end
end
__END_OF_oligo.rb__
filename='lib/lims-core/laboratory/plate.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_plate.rb__ > $filename
require 'lims/core/resource'
require 'lims/core/laboratory/receptacle'

require 'facets/hash'
require 'facets/array'

module Lims::Core
  module Laboratory
    # A plate is a plate as seen in a laboratory, .i.e
    # a rectangular bits of platics with wells and some 
    # readable labels on it.
    # TODO add label behavior
    class Plate 
      include Resource
      # Type contains the actual type of the plate.
      attribute :type, String, :required => false

      # The well of a {Plate}. 
      # Contains some chemical substances.
      class Well
        include Receptacle
      end

      is_matrix_of Well do |p,t|
        (p.number_of_rows*p.number_of_columns).times.map { t.new }
      end

      # This should be set by the user.
      # We mock it to give pools by column
      # @return [Hash<String, Array<String>] pools pool name => list of wells name
      def pools
        1.upto(number_of_columns).mash do |c|
          [c, 1.upto(number_of_rows).map { |r| indexes_to_element_name(r-1,c-1) } ]
        end
      end
    end
  end
end
__END_OF_plate.rb__
filename='lib/lims-core/laboratory/receptacle.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_receptacle.rb__ > $filename
# vi: ts=2 sts=2 et sw=2 spell spelllang=en  
require 'common'
require 'lims/core/laboratory/aliquot'
require 'lims/core/base'

require 'forwardable'

module Lims::Core
  module Laboratory
    # A Receptacle has a chemical content which is a set of {Laboratory::Aliquot aliquots}.
    # It can be seen (and used) as a Array of Aliquots (until a certain extend).
    # {include:Laboratory::Aliquot}
    module Receptacle

      def self.included(klass)
        klass.class_eval do
          include Base

          is_array_of(Aliquot) { |l,t| Array.new }

          # Add something to the receptacle.
          # Could be one or many {Aliquot aliquots}
          # @param [Aliquot, Array<Aliquot>]
          def <<(e)
            tap do
              if e.respond_to?(:to_a)
                  content.concat(e.to_a)
              else
                # we need to add aggregate similar aliquot and
                 content.each do |aliquot|
                   next unless aliquot === e
                   # wound a similar aliquot, update the quantity
                   aliquot.increase_quantity(e.quantity)
                   return
                end
                  content << e
              end
            end
          end

          # returns the total quantity of liquid present in the receptacle.
          # for liquid, this is the sum  of each aliquot.
          # @todo to be correct we need the actual quantity of water AND of chemical substance.
          # @return Float
          def quantity(dimension=Aliquot::Volume)
            content.select { |a| a.dimension == dimension }.inject(nil) { |q, a| Aliquot::add_quantity(q, a.quantity) }
          end

          def volume
            quantity(Aliquot::Volume)
          end

          # Takes (removes) a specified amount of each aliquots (proportionally)
          # @param amount
          # @return [Array<Laboratory::Aliquot>]
          def take_amount(amount=nil, dimension=Aliquot::Volume)
            # @todo : implement
            # take_fraction
            take_fraction(amount && quantity(dimension) ? amount/quantity(dimension).to_f : nil)
          end

          # Takes (removes) a specified amount of each aliquots (proportionally)
          # @param [Float] f the fraction (between 0.0 and 1.0) of each aliquots to take.
          # @return [Array<Laboratory::Aliquot>]
          def take_fraction(f)
            f = [0, f, 1].sort[1] if f # clamp
            content.map {|a| a.take_fraction(f) }
          end

          def to_s()
            content.to_s
          end
        end
      end
    end
  end
end

__END_OF_receptacle.rb__
filename='lib/lims-core/laboratory/sample.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_sample.rb__ > $filename
require 'common'
require 'lims-core/resource'

module Lims::Core
  module Laboratory
    # A sample is a constituant of an aliquot.
    # It refers to a sample of DNA of an 'individual' at a particular time.
    # The core doesn't need to care about 'individual',
    # it just store metadata (like organism, gender, etc ...).
   class Sample
     include Resource
     include Aequitas
     attribute :name, String, :required => true
      def initialize(params={})
        args = {}
        case params
        when String then args[:name] = params
        when Hash then args = params
        end

        super(args)
      end

      def to_s
        @name.inspect
      end
   end
  end 
end
__END_OF_sample.rb__
filename='lib/lims-core/laboratory/sanger_barcode.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_sanger_barcode.rb__ > $filename
require 'common'

require 'lims-core/laboratory/labellable'

module Lims::Core
  module Laboratory
    class SangerBarcode
      include Labellable::Label
      Type = "sanger-barcode"
    end
  end
end
__END_OF_sanger_barcode.rb__
filename='lib/lims-core/laboratory/spin_column.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_spin_column.rb__ > $filename
require 'lims/core/resource'
require 'lims/core/laboratory/receptacle.rb'

module Lims::Core
  module Laboratory
    # Piece of labware. 
    # Can have something on it.
    # It can have a label (barcode) to identify it.
    class SpinColumn
      include Resource
      include Receptacle
    end
  end
end
__END_OF_spin_column.rb__
filename='lib/lims-core/laboratory/tag_group.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_tag_group.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2 spell:spelllang=en  
require 'common'

require 'lims/core/resource'
require 'lims/core/laboratory/oligo'

module Lims::Core
  module Laboratory
    class TagGroup
      include Resource
      include Forwardable
      attribute :name, String, :writer => :protected, :initializable => true
      is_array_of Oligo

      #module AccessibleViaSuper
        # @param [String, Hash] name the name or a hash of attributes.
        # @param [Oligo, Array<Oligo>] oligos to add to the tag group.
      def initialize(name, *oligos, &block)
        args = {}
        case name
        when String then args[:name] = name
        when Hash then args = name
        end
        super(args, &block)

        @content = oligos.flatten

      end
      #end
      #include AccessibleViaSuper

      # Add additional method delegations
      def_delegators :@content, :<<, :[]=
    end
  end
end
__END_OF_tag_group.rb__
filename='lib/lims-core/laboratory/tube.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_tube.rb__ > $filename
require 'common'
require 'lims/core/resource'
require 'lims/core/laboratory/receptacle.rb'

module Lims::Core
  module Laboratory
    # Piece of laboratory. 
    # Can have something in it and probably a label or something to identifiy it.
    class Tube
      include Resource
      include Receptacle
      # Type contains the actual type of the tube, for example Eppendorf.
      attribute :type, String, :required => false
      # Store the maximum volume a tube can hold in ml.
      attribute :max_volume, Numeric, :gte => 0, :required => false
    end
  end
end
__END_OF_tube.rb__
filename='lib/lims-core/laboratory/tube_rack.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_tube_rack.rb__ > $filename
require 'lims/core/resource'
require 'lims/core/laboratory/tube'

module Lims::Core
  module Laboratory
    class TubeRack
      include Resource

      is_matrix_of Tube do |p,t|
        Array.new(p.number_of_rows * p.number_of_columns)
      end

      class RackPositionNotEmpty < StandardError
      end

      # Overwrite []= method to add tube in the rack.
      # The value nil needs to be set sometimes, for
      # example when we move physically a tube between
      # racks, the source rack position is then empty.
      # @param [Symbol, String] position in the rack
      # @param [Laboratory::Tube] tube
      def []=(key, value)
        raise ArgumentError, "#{value} is not a Tube" unless value.is_a? Tube or value.nil?

        case key
        when /\\A([a-zA-Z])(\\d+)\\z/
          position = element_name_to_index(\$1, \$2)
          raise RackPositionNotEmpty unless content[position].nil? or value.nil?
          content[position] = value
        when Symbol
          self[key.to_s] = value
        else
          super(key, value)
        end
      end
    end
  end
end
__END_OF_tube_rack.rb__
filename='lib/lims-core/laboratory.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_laboratory.rb__ > $filename
#vi: ts=2 sw=2 et
require 'lims/core/laboratory/plate.rb'
require 'lims/core/laboratory/tube.rb'
require 'lims/core/laboratory/flowcell.rb'

require 'lims/core/laboratory/aliquot'
require 'lims/core/laboratory/sample'
require 'lims/core/laboratory/oligo'

module Lims::Core
  # Things used/found in the lab. Includes pure laboratory (inert things as {Plate plates}, {Tube tubes})
  # and chemical one (as {Aliquot aliquots}, {Sample samples}).
  module Laboratory
  end
end
__END_OF_laboratory.rb__
filename='lib/lims-core/organization/batch.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_batch.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2 spell:spelllang=en 
require 'common'
require 'lims/core/resource'

module Lims::Core
  module Organization
    # A batch groups multiple items together.
    class Batch
      include Resource
      # Store the process that the batch is going through.
      # Ex: 8 tubes might go through the process "manual extraction".
      attribute :process, String, :required => false
    end
  end
end
__END_OF_batch.rb__
filename='lib/lims-core/organization/order/item.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_item.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2 spell:spelllang=en 
require 'common'
require 'lims/core/resource'
require 'lims-core/organization/user'
require 'lims-core/organization/study'
require 'lims-core/organization/batch'

require 'state_machine'

StateMachine::Machine.ignore_method_conflicts = true
module Lims::Core
  module Organization
    class Order
      # @see Order
      # An item has an iteration attribute, representing the number of times
      # its been started. Iteration > 1 means that the items has been failed at least once.
      # Iteration = 0 means that the item has been set directly as source and is part of the
      # initial order.
      # The status represents the *progress* of the item.
      class Item
        include Resource

        attribute :iteration, Fixnum, :writer => :private, :default => 0
        attribute :uuid, String
        attribute :batch, Batch
        attribute :status, State

        def initialize(*args)
          super(*args)
          iteration
        end

        def iterate
          @iteration+=1
        end
        state_machine :status, :initial  => :pending do
          # This is the initial state. The item hasn't either been set as a source
          # or started. It can appear in the *inbox*.

          after_transition  :on => :start, :do => :iterate

          state :pending do
          end

          # the item creation process has been started.
          state :in_progress do
          end

          # The item exists and is available for the next step of the order.
          state :done do
            def uuid=(uuid)
              raise NoMethodError
            end
          end

          # The item has been used to create the next step of the order.
          # It's not going to be used anymore in the order.
          state :unused do
            def uuid=(uuid)
              raise NoMethodError
            end
          end

          # The item creation has failed. It can be reset to pending
          # and then restarted
          state :failed do
          end

          # The item has been cancelled by a user decision and can't be done.
          state :cancelled do
          end

          event :start do
            transition [:pending, :failed] => :in_progress
          end

          event :complete do
            transition [:pending, :in_progress] => :done
          end

          event :unuse do
            transition [:done] => :unused
          end

          event :cancel do
            transition [:pending, :in_progress, :failed] => :cancelled
          end

          event :fail do
            # Transition from pending allowed to be able to 'create' failed item
            transition [:pending, :in_progress]=> :failed
          end

          event :reset do
            transition [:failed, :in_progress] => :pending
          end
          end
        end
      end
    end
  end

__END_OF_item.rb__
filename='lib/lims-core/organization/order.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_order.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2 spell:spelllang=en 
require 'common'
require 'lims/core/resource'
require 'lims-core/organization/user'
require 'lims-core/organization/study'
require 'lims-core/organization/order/item'

require 'state_machine'

StateMachine::Machine.ignore_method_conflicts = true
module Lims::Core
  module Organization
    # An order represents the idea of 'work to be done'.
    # However, an order focuses more on the final outcomes than the steps to achieve it.
    # The way to fulfil this order is specified via a \`pipeline\` and its \`parameters\`, which **knows** how to do it.
    # This allows the flexibility for a pipeline to adapt its process without having to modify the corresponding order.
    # The current *progress* of the order - what has been done so far - is then no stored as "what steps have been done",
    # but more as "which *items* exits". To make this work ,we also needs to know how each items participates in the order, meaning its \`role\`.
    # For example, in the case that user U needs sample S to be sequenced, what we need to know is we *have* sample S as a **source** and want
    # we want a *sequence* as *result*.
    # To do so, we need to create a library from the sample. Once this library is created, it becomes part of the order as **library**.
    # The pipeline will then know that the **library** has been created and that the next step can start.
    # Note, there is no relation at a core level between this sample and this library. The pipeline *knows* that this **sample** is linked to that **library**.
    # Ultimately, someone wanted to sequence an existing library, can create an order with the same parameters, with the **library** given instead of the **sample**.
    class Order

      include Resource
      attribute :creator, User, :required => true, :writer => :private, :initializable=>true
      attribute :pipeline, String, :required => true
      attribute :items, HashString, :default => {}, :reader => :private, :writer => :private, :initializable => true

      attribute :status, State
      attribute :parameters, Hash, :default => {}
      attribute :state, Hash, :default => {}
      attribute :study, Study, :required => true, :writer => :private, :initializable=>true
      attribute :cost_code, String, :required => true, :writer  => :private, :initializable=>true

      # An order has a status, which is its progress from an end-user 
      # point of view. This status is more meant to be used by 
      # Order related applications (like ones dealing with creation
      # or tracking) that the pipeline. Ideally the pipeline should
      # be involved in the :in_progress state.
      # The status will affect the behavior of validation and 
      # certain methods.
      state_machine :status, :initial  => :draft do
        # This is the initial state. The order is not finalized yet.
        # It can be modified, and should not be *visible* by the pipeline.
        state :draft do
        end

        # The order has been *validated* by the user and it's ready 
        # to pe processed.
        state :pending do
        end

        state all - [:draft] do
          def creator=(creator)
            raise NoMethodError, "creator can't be assigned in #{status} mode"
          end

          def study=(study)
            raise NoMethodError, "study can't be assigned in #{status} mode"
          end

          def cost_code=(cost_code)
            raise NoMethodError, "cost code can't be assigned in #{status} mode"
          end
        end
        # the order has been physically started, .i.e it's belong
        # to a pipeline and some work is currently being done.
        state :in_progress do
        end

        # the order has been fulfilled with success. It should not be
        # modifiable without rewriting history.
        state :completed do
        end

        # For whatever reason, the order can not be completed.
        # Shouldn't be modifiable.
        state :failed do
        end

        # The order has been cancelled by a user decision.
        # Shouldn't be modifiable.
        state :cancelled do
        end

        event :build do
          transition :draft => :pending
        end

        event :start do
          transition :pending => :in_progress
        end

        event :complete do
          transition :in_progress => :completed
        end

        event :cancel do
          transition [:draft, :pending, :in_progress] => :cancel
        end

        event :fail do
          transition [:draft, :pending, :in_progress] => :failed
        end
      end

      # ========= Items ========
      # Redirect key to either items or attributes (default
      # Virtus behavior
      def [](key)
        key_is_for_items?(key) ? items[key.to_s] : super(key)
      end

      def []=(key, value)
        if key_is_for_items?(key) 
          raise RuntimeError, "items should be an array" unless value.is_a?(Array)
          items[key.to_s]=value 
        else
          super(key, value)
        end
      end

      # Add an item to the specified role
      # Ideally, uuid should be unique within a role
      # @param String role
      # @param Item item
      def add_item(role, item)
        role = role.to_s
        item_list = items.fetch(role) { |k| items[role] = [] }
        item_list << item
        return item
      end

      def_delegators :items, :each, :size , :keys, :values, :map, :mashr , :include?, :to_a , :fetch

      # Check if the argument is a key for items
      # or attributes
      # @param [Object] key
      # @return [Boolean]
      def key_is_for_items?(key)
        case key
        when String, Symbol then !respond_to?(key)
        end || false
      end
      private :key_is_for_items?

      # A source is an item required to complete the order.
      # There is nothing to do for it, so it's already in a done state.
      # As the source is meant to be used by the pipeline to fulfil the order
      # it needs an underlying object.
      # @param [String] role of the source
      # @param [Array, String] uuids of the underlying object
      # @return [Item]
      def add_source(role, uuids)
        uuids = [uuids] unless uuids.is_a?(Array)
        uuids.each do |uuid|
          Item.new(:uuid => uuid).tap do |item|
            item.complete
            self.add_item(role, item)
          end
        end
      end

      # A target is an item produced by the order.
      # It starts as pending and needs to be completed or failed.
      # @param [String] role of the target
      # @param [String] uuid of the underlying object
      # @return [Item]
      def add_target(role, uuids = nil)
        uuids = [uuids] unless uuids.is_a?(Array)
        uuids.each do |uuid|
          self.add_item(role, Item.new(:uuid => uuid))
        end
      end
    end
  end
end

__END_OF_order.rb__
filename='lib/lims-core/organization/project.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_project.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2 spell:spelllang=en 
require 'common'
require 'lims/core/resource'

module Lims::Core
  module Organization
    # A project corresponds to a source of funding.
    # It has a manager.
    class Project
      include Resource
    end
  end
end
__END_OF_project.rb__
filename='lib/lims-core/organization/releasable.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_releasable.rb__ > $filename
# vi: ts=2 sts=2 et sw=2 spell spelllang=en  
 require 'common'

 module Lims::Core
   module Organization
     module Releasable
       # Can be released to the outside world.
     end
   end
 end

__END_OF_releasable.rb__
filename='lib/lims-core/organization/study.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_study.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2 spell:spelllang=en 
require 'common'

require 'lims/core/resource'
require 'lims/core/organization/releasable'

module Lims::Core
  module Organization
    # A study. It as an owner, a title and data release attributes, EGA accession number.
    # Correspond roughly to a published paper.
    class Study
      include Resource
      include Releasable
    end
  end
end

__END_OF_study.rb__
filename='lib/lims-core/organization/user.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_user.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2 spell:spelllang=en 
require 'common'

module Lims::Core
  module Organization
    # A user. Anybody that can log into to the system.
    class User
      include Resource
    end
  end
end
__END_OF_user.rb__
filename='lib/lims-core/organization.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_organization.rb__ > $filename
# @private vi: ts=2 sw=2 et
require 'lims/core/organization/order'
require 'lims/core/organization/project'
require 'lims/core/organization/study'
require 'lims/core/organization/user'

module Lims::Core
  # This module contains the different classes related to users,
  # data release, funding, ordering etc. 
  module Organization
  end
end
__END_OF_organization.rb__
filename='lib/lims-core/laboratory/aliquot/aliquot_persistor.rb
mkdir -p $(dirname $filename)
cat <<__END_OF_aliquot.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2 spell:spelllang=en


require 'lims/core/persistence/persistor'
require 'lims/core/laboratory/aliquot'

module Lims::Core
  module Laboratory
    # @abstract
    # Base for all Aliquot persistor.
    # Real implementation classes (e.g. Sequel::Aliquot) should
    # include the suitable persistor.
    class Aliquot::AliquotPersistor < Persistor
      Model = Laboratory::Aliquot
    end
  end
end
__END_OF_aliquot.rb__
filename='lib/lims-core/organization/batch/batch_persistor.rb
mkdir -p $(dirname $filename)
cat <<__END_OF_batch.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2 spell:spelllang=en
require 'lims/core/persistence/persistor'
require 'lims/core/organization/batch'

module Lims::Core
  module Organization
    class Batch::BatchPersistor < Persistor
      Model = Organization::Batch
    end
  end
end
__END_OF_batch.rb__
filename='lib/lims-core/organization/batch/batch_filter_persistor.rb
mkdir -p $(dirname $filename)
cat <<__END_OF_batch_filter.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2 spell:spelllang=en
require 'lims/core/persistence/filter'
require 'lims/core/resource'

module Lims::Core
  module Organization
    class Batch::BatchFilterPersistor < Filter
      include Resource
      attribute :criteria, Hash, :required => true
      
      # For Sequel, keys needs to be a Symbol to be seen as column.
      # String are seen as 'value'
      def initialize(criteria)
        criteria = { :criteria => criteria } unless criteria.include?(:criteria)
        criteria[:criteria].rekey!{ |k| k.to_sym }
        super(criteria)
      end

      def call(persistor)
        persistor.batch_filter(criteria)
      end
    end

    class Persistor
      # @param [Hash] criteria 
      # @return [Persistor] 
      def batch_filter(criteria)
        raise NotImplementedError "batch_filter methods needs to be implemented for subclass of Persistor"
      end
    end
  end
end
__END_OF_batch_filter.rb__
filename='lib/lims-core/persistence/container.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_container.rb__ > $filename
module Lims::Core
  module Organization
    module Container

      # Save all children of the given container (gel, plate)
      # @param  id object identifier
      # @param [i.e. Laboratory::Gel] container
      # @return [Boolean]
      def save_children(id, container)
        # we use values here, so position is a number
        container.values.each_with_index do |element, position|
          @session.save(element, id, position)
        end
      end

      # Load all children of the given container (gel, plate)
      # Loaded object are automatically added to the session.
      # @param id object identifier
      # @param [i.e. Laboratory::Gel] container
      # @return [i.e. Laboratory::Gel, nil] 
      #
      def load_children(id, container)
        element.load_aliquots(id) do |position, aliquot|
          container[position] << aliquot
        end
      end

      # The specific container should implement this method
      # and call the correct element method
      def element
        raise NotImplementedError
      end
    end
  end
end
__END_OF_container.rb__
filename='lib/lims-core/persistence/container_element.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_container_element.rb__ > $filename
module Lims::Core
  module Organization
    module ContainerElement

      def save(element, container_id, position)
        #todo bulk save if needed
        element.each do |aliquot|
          save_as_aggregation(container_id, aliquot, position)
        end
      end

    end
  end
end
__END_OF_container_element.rb__
filename='lib/lims-core/persistence/filter.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_filter.rb__ > $filename
#vi: ts=2 sw=2 et
require 'common'

module Lims::Core
  module Organization
    # @abstract Base class of all filters.
    # A filter acts on persistors and can be chained.
    # Note: This class is not really usefull in a *Ruby world* and is mainly
    # here for documentation.
    class Filter
      # Transform a persistor to a "filtered persistor"
      # The filtered persistor loading only the filtered object.
      # Note that the actual implementation of the filter depends on the 
      # *type* of the persistor (Sequel for example).
      # @param persistor [Persistence::Persistor]
      # @return [Persistor]
      def call(persistor)
        raise NotImplementedError
      end
    end
  end
end

__END_OF_filter.rb__
filename='lib/lims-core/laboratory/flowcell/flowcell_persistor.rb
mkdir -p $(dirname $filename)
cat <<__END_OF_flowcell.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2 spell:spelllang=en


require 'lims/core/persistence/persistor'
require 'lims/core/laboratory/flowcell'

module Lims::Core
  module Laboratory
    # @abstract
    # Base for all Flowcell persistor.
    # Real implementation classes (e.g. Sequel::Flowcell) should
    # include the suitable persistor.
    class Flowcell::FlowcellPersistor < Persistor
      Model = Laboratory::Flowcell

      # @abstract
      # Base for all Lane persistor.
      # Real implementation classes (e.g. Sequel::Lane) should
      # include the suitable persistor.
      class Lane < Persistor
        Model = Laboratory::Flowcell::Lane
        def save(lane, flowcell_id, position)
          #todo bulk save if needed
          lane.each do |aliquot|
            save_as_aggregation(flowcell_id, aliquot, position)
          end
        end
      end
    end
  end
end
__END_OF_flowcell.rb__
filename='lib/lims-core/laboratory/gel/gel_persistor.rb
mkdir -p $(dirname $filename)
cat <<__END_OF_gel.rb__ > $filename
require 'lims/core/persistence/persistor'
require 'lims/core/persistence/container'
require 'lims/core/persistence/container_element'
require 'lims/core/laboratory/gel'

module Lims::Core
  module Laboratory

    # Base for all Gel persistor.
    # Real implementation classes (e.g. Sequel::Gel) should
    # include the suitable persistor.
    class Gel::GelPersistor < Persistor
      Model = Laboratory::Gel

      include Container

      # calls the correct element method
      def element
        window
      end

      def window
        @session.send("Gel::Window")
      end

      # Base for all Window persistor.
      # Real implementation classes (e.g. Sequel::Window) should
      # include the suitable persistor.
      class Window < Persistor
        Model = Laboratory::Gel::Window

        include ContainerElement

      end
    end
  end
end
__END_OF_gel.rb__
filename='lib/lims-core/persistence/identity_map.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_identity_map.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2 spell:spelllang=en

require 'common'

module Lims::Core
  module Laboratory
    # Mixing giving  an identity map behavior
    # ie a map (both way) between id and object
    module IdentityMap
      # Raised if there is any duplicate in the identity map 
      class DuplicateError < RuntimeError 
      end

      #Raised if the \`id\` is already associated to a different \`object\`
      class DuplicateIdError <DuplicateError
      end

      #Raised if the \`object\` is already associated to a different \`id\`
      class DuplicateObjectError < DuplicateError
      end

      # Look for the id associated to an object and yield it to the block
      # if found.
      def id_for(object, &block)
        @object_to_id[object].andtap(&block)
      end

      # Look for the object associated to an object and yield it to the block
      # if found.
      def object_for(id, &block)
        @id_to_object[id].andtap(&block)
      end

      # bound an id to an object
      def map_id_object(id, object)
        return nil unless id && object
        raise DuplicateIdError, id unless @id_to_object.fetch(id, object).equal? object
        raise DuplicateObjectError, object unless  @object_to_id.fetch(object, id).equal? id
        @id_to_object[id] = object
        @object_to_id[object] = id
      end

      def initialize(*args, &block)
        super(*args, &block)
        @id_to_object = {}
        @object_to_id = {}
      end
    end
  end
end
__END_OF_identity_map.rb__
filename='lib/lims-core/persistence/label_filter.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_label_filter.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2 spell:spelllang=en

require 'lims/core/persistence/filter'
require 'lims-core/resource'


module Lims::Core
  module Laboratory
    # Filter  performing a && between all the pairs of a map.
    # Key being the field
    # Value can be either a String, an Array  or a Hash.
    # Strings and Arrays are normal filters, whereas Hashes
    # correspond to a joined search. The criteria will apply to the 
    # joined object corresponding to the key.
    # @example
    #   {
    #     :status => [:pending, :in_progress],
    #     :item => {
    #       :status => [:pending],
    #       :uuid => <plate_uuid>
    #     }
    #    }
    #   Will look for all the orders in pending or in progress status
    #   *holding* a plate with a pending status.
    #    
    class LabelFilter < Filter 
      include Resource
      attribute :criteria, Hash, :required => true
      # For Sequel, keys needs to be a Symbol to be seen as column.
      # String are seen as 'value'
      def initialize(criteria)
        criteria = { :criteria => criteria } unless criteria.include?(:criteria)
        criteria[:criteria].rekey!{ |k| k.to_sym }
        super(criteria)
      end


      def call(persistor)
        persistor.label_filter(criteria)
      end
    end

    class Persistor
      # @param [Hash] criteria a 
      # @return [Persistor] 
      def label_filter(criteria)
        raise NotImplementedError "multi_criteria_filter methods needs to be implemented for subclass of Persistor"
      end
    end
  end
end

__END_OF_label_filter.rb__
filename='lib/lims-core/laboratory/labellable/labellable_persistor.rb
mkdir -p $(dirname $filename)
cat <<__END_OF_labellable.rb__ > $filename
require 'lims/core/persistence/persistor'
require 'lims/core/laboratory/labellable'

# needs to require all label subclasses
require 'lims/core/laboratory/sanger_barcode'

module Lims::Core
  module Laboratory
    class Labellable::LabellablePersistor < Persistor
      Model = Laboratory::Labellable

      def label
        @session.send("Labellable::Label")
      end

      # Saves all children of a given Labellable
      def save_children(id, labellable)
        labellable.each do |position, label_object|
          label.save(label_object, id, position)
        end
      end

      # Loads all children of a given Labellable
      def load_children(id, labellable)
        label.load(id) do |position, label|
          labellable[position]=label
        end
      end


      class Label < Persistor
        Model = Laboratory::Labellable::Label
      end
    end
  end
end
__END_OF_labellable.rb__
filename='lib/lims-core/persistence/logger/persistor.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_persistor.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2 spell:spelllang=en


module Lims::Core
  module Laboratory
    module Logger
      # Mixin giving extended the persistor classes with
      # the Logger (save) behavior.
      module Persistor
        private

        # Load an object to the underlying logger
        # @param [Resource] object the object 
        # @return  the Id if save successful
        def save_raw(object, *params)
          case object 
            when Resource then @session.log("#{object.class.name}: #{filter_attributes_on_save(object.attributes)}")
            else
            @session.log("#{object.inspect}")
            end
          object
        end

        # Overriden the default save new to add indentation
        # around children
        def save_new(object, *params)
          save_raw(object, *params).tap do |id|
            @session.with_indent("- ") { save_children(id, object) }
          end
        end

        # Upate a raw object, i.e. the object attributes
        # excluding any associations.
        # @param [Resource] object the object 
        # @param [Fixnum] id the Id of the object
        # @return [Fixnum, nil] the id 
        def update_raw(object, id, *params)
          id.tap do
            save_raw(object, *params)
          end
        end

        def save_as_aggregation(source_id, target, *params)
          @session.with_indent("#{params} - ") do
            super(source_id, target)
          end
        end

        def save_raw_association(source_id, target_id, *params)
        end
      end
    end
  end
end
__END_OF_persistor.rb__
filename='lib/lims-core/persistence/logger/session.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_session.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2 spell:spelllang=en

require 'logger'
require 'lims/core/persistence/session'

module Lims::Core
  module Laboratory
    module Logger
      # Logger specific implementation of a {Persistence::Session Session}.
      class Session < Persistence::Session

        attr_reader :indent_level
        def initialize(*args, &block)
          @indent_level = ""
          super(*args, &block)
        end

        def log(msg)
          @store.log(indent_level+msg)
        end

        # Execute a block with the specified indent level indicator.
        # @param [String] indent the indent level indicator
        def with_indent(indent=" - ", &block)
          temporarily('@indent_level' => @indent_level+indent, &block)
        end
      end
    end
  end
end
__END_OF_session.rb__
filename='lib/lims-core/persistence/logger/store.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_store.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2

require 'logger'
require 'lims/core/persistence'
require 'lims/core/persistence/store'

module Lims::Core
  module Laboratory
    module Logger
      # An Logger::Store, a store 'logging' object instead of 
      # saving them.
      class Store < Persistence::Store
        attr_reader :logger
        attr_reader :method

        # Create a store with an underlying logger.
        # @param [Logger, file] logger 
        # @param [Symbol, String] method the method call to
        # send information to the logger.
        def initialize(logger, method=:info, *args)
          @logger = case logger
                    when ::Logger then  logger
                    else ::Logger.new(logger)
                    end
          @method = method
          super(*args)
        end

        def log(msg)
          @logger.send(@method, msg)
        end
      end
    end
      finalize_submodule(Logger)
  end
end
__END_OF_store.rb__
filename='lib/lims-core/persistence/message_bus.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_message_bus.rb__ > $filename
require 'bunny'
require 'common'

module Lims
  module Core
    module Laboratory

      # Basic methods to publish messages on the bus
      # Use the bunny gem as RabbitMQ client
      class MessageBus

        include Virtus
        include Aequitas 
        attribute :connection_uri, String, :required => true, :writer => :private
        attribute :exchange_name, String, :required => true, :writer => :private
        attribute :durable, Boolean, :required => true, :writer => :private
        attribute :prefetch_number, Integer, :required => true, :writer => :private

        # Exception ConnectionError raised after a failed connection
        # to RabbitMQ server.
        class ConnectionError < StandardError
        end 

        # Exception InvalidSettingsError raised after a setting error
        class InvalidSettingsError < StandardError
        end

        # Initialize the message bus and check the required options 
        # are passed as parameters.
        # @param [Hash] settings
        def initialize(settings = {})
          @connection_uri = settings["url"]
          @exchange_name = settings["exchange_name"]
          @durable = settings["durable"]
          @prefetch_number = settings["prefetch_number"]
        end

        # Executed after a connection loss
        # The exception should be catched and rollback the actions.
        def connection_failure_handler
          Proc.new do
            raise ConnectionError, "can't connect to RabbitMQ server"
          end
        end

        # Create a new connection to the broker using
        # the connection settings.
        # Create a channel and setup a new exchange.
        def connect
          begin
            if valid?
              @connection = Bunny.new(connection_uri)
              @connection.start
              @channel = @connection.create_channel
              set_prefetch_number(prefetch_number)
              set_exchange(exchange_name, :durable => durable)
            else
              raise InvalidSettingsError, "settings are invalid"
            end
          rescue Bunny::TCPConnectionFailed, Bunny::PossibleAuthenticationFailureError => e
            connection_failure_handler.call
          end
        end  

        # Close the connection
        def close
          @connection.close 
        end

        # Create (or get if it already exists) a new topic
        # exchange with the given options.
        # Especially, the durable option can be set here to
        # mark the exchange as durable (survive a server restart)
        # @param [String] name
        # @param [Hash] exchange options
        def set_exchange(exchange_name, options = {})
          @exchange = @channel.topic(exchange_name, options)
        end
        private :set_exchange

        # Specifies the number of messages to prefetch.
        # @param [int] number of messages to prefetch
        def set_prefetch_number(number)
          @channel.prefetch(number)
        end
        private :set_prefetch_number

        # Set the message persistence behaviour.
        # If persistent, the message will be persisted to disk
        # and remain in the queue until it is consumed. 
        # Survive a server restart.
        # BUNNY ISSUE: bunny0.9pre4 hardcodes the persistent option. 
        # @see lib/bunny/channel.rb:174 :delivery_mode => 2
        # It is set all the time, meaning the messages will survive 
        # a server restart, if the queue and the exchange are durable.
        # @param [Bool] persistence
        def set_message_persistence(persistent)
          @message_persistence = persistent 
        end

        # Publish a message on the bus with the given options
        # The routing key is passed in the options.
        # @param [String] JSON message
        # @param [Hash] publishing options
        def publish(message, options = {})
          raise ConnectionError, "exchange is not reachable" unless @exchange.instance_of?(Bunny::Exchange)
          
          options.merge!(:persistent => @message_persistence) unless @message_persistence.nil? 
          @exchange.publish(message, options)
        end
      end
    end
  end 
end
__END_OF_message_bus.rb__
filename='lib/lims-core/persistence/multi_criteria_filter.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_multi_criteria_filter.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2 spell:spelllang=en

require 'lims/core/persistence/filter'
require 'lims-core/resource'


module Lims::Core
  module Laboratory
    # Filter  performing a && between all the pairs of a map.
    # Key being the field
    # Value can be either a String, an Array  or a Hash.
    # Strings and Arrays are normal filters, whereas Hashes
    # correspond to a joined search. The criteria will apply to the 
    # joined object corresponding to the key.
    # @example
    #   {
    #     :status => [:pending, :in_progress],
    #     :item => {
    #       :status => [:pending],
    #       :uuid => <plate_uuid>
    #     }
    #    }
    #   Will look for all the orders in pending or in progress status
    #   *holding* a plate with a pending status.
    #    
    class MultiCriteriaFilter <  Filter
      include Resource
      attribute :criteria, Hash, :required => true
      # For Sequel, keys needs to be a Symbol to be seen as column.
      # String are seen as 'value'
      def initialize(criteria)
        criteria = { :criteria => criteria } unless criteria.include?(:criteria)
        criteria[:criteria].rekey!{ |k| k.to_sym }
        super(criteria)
      end

      def call(persistor)
        persistor.multi_criteria_filter(criteria)
      end
    end

    class Persistor
      # @param [Hash] criteria a 
      # @return [Persistor] 
      def multi_criteria_filter(criteria)
        raise NotImplementedError "multi_criteria_filter methods needs to be implemented for subclass of Persistor"
      end
    end
  end
end

__END_OF_multi_criteria_filter.rb__
filename='lib/lims-core/laboratory/oligo/oligo_persistor.rb
mkdir -p $(dirname $filename)
cat <<__END_OF_oligo.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2 spell:spelllang=en


require 'lims/core/persistence/persistor'
require 'lims/core/laboratory/oligo'

module Lims::Core
  module Laboratory

    # Base for all Plate persistor.
    # Real implementation classes (e.g. Sequel::Plate) should
    # include the suitable persistor.
    class Oligo::OligoPersistor < Persistor
      Model = Laboratory::Oligo
    end
  end
end
__END_OF_oligo.rb__
filename='lib/lims-core/organization/order/order_persistor.rb
mkdir -p $(dirname $filename)
cat <<__END_OF_order.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2 spell:spelllang=en

require 'lims/core/persistence/persistor'
require 'lims/core/organization/order'

module Lims::Core
  module Organization
    # Base for all Order persistor.
    class Order::OrderPersistor < Persistor
      Model = Organization::Order

      # Saves all children of the given order
      # @param id obect identifier
      # @param [Organization::Order] order
      # @return [Boolean]
      def save_children(id, order)
        order.each do |role, items|
          items.each do |item|
            @session.save(item, id, role)
          end
        end
      end

      # Loads all children of the given order

      # @param  id object identifier
      # @param [Organization::Order] order
      # @return [Organization::Order, nil] 
      #
      def load_children(id, order)
        # We don't really need to keep the order of the item
        # however as the user can update an item via is index
        # it's need to be the same between what we display
        # and how we load items.
        # For this items are loaded sorted by id
        # So they should be always presented the same way (between and load and a save)
        item.loads(id) do |role, item|
          order.add_item(role, item)
        end
      end

      def item
        @session.send("Order::Item")
      end

      class Item < Persistor
        Model = Organization::Order::Item

        def filter_attributes_on_save(attributes, order_id=nil, role=nil)
          attributes = attributes.mash do |k,v|
            case k
            when :batch then [:batch_id, @session.id_for!(v)]
            else [k,v]
            end
          end
          attributes[:role] = role if role
          attributes[:order_id] = order_id if order_id
          uuid = attributes[:uuid]
          attributes[:uuid] = @session.pack_uuid(uuid) if uuid
          attributes
        end

        def filter_attributes_on_load(attributes)
          attributes = attributes.mash do |k,v|
            case k
            when :batch_id then [:batch, @session.batch[v]]
            else [k,v]
            end
          end
          uuid = attributes[:uuid]
          attributes[:uuid] = @session.unpack_uuid(uuid) if uuid
          attributes
        end
      end
    end
  end
end
__END_OF_order.rb__
filename='lib/lims-core/organization/order/order_filter_persistor.rb
mkdir -p $(dirname $filename)
cat <<__END_OF_order_filter.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2 spell:spelllang=en
require 'lims/core/persistence/filter'
require 'lims-core/resource'

module Lims::Core
  module Organization
    # Filter  performing a && between all the pairs of a map.
    # Key being the field
    # Value can be either a String, an Array  or a Hash.
    # Strings and Arrays are normal filters, whereas Hashes
    # correspond to a joined search. The criteria will apply to the 
    # joined object corresponding to the key.
    # @example
    #   {
    #     :status => [:pending, :in_progress],
    #     :item => {
    #       :status => [:pending],
    #       :uuid => <plate_uuid>
    #     }
    #    }
    #   Will look for all the orders in pending or in progress status
    #   *holding* a plate with a pending status.
    #    
    class Order::OrderFilterPersistor < Filter 
      include Resource
      attribute :criteria, Hash, :required => true
      # For Sequel, keys needs to be a Symbol to be seen as column.
      # String are seen as 'value'
      def initialize(criteria)
        criteria = { :criteria => criteria } unless criteria.include?(:criteria)
        criteria[:criteria].rekey!{ |k| k.to_sym }
        super(criteria)
      end

      def call(persistor)
        persistor.order_filter(criteria)
      end
    end

    class Persistor
      # @param [Hash] criteria a 
      # @return [Persistor] 
      def order_filter(criteria)
        raise NotImplementedError "order_filter methods needs to be implemented for subclass of Persistor"
      end
    end
  end
end

__END_OF_order_filter.rb__
filename='lib/lims-core/persistence/persistor.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_persistor.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2 spell:spelllang=en

require 'lims/core/persistence/identity_map'


module Lims::Core
  module Organization
    # @abstract Base class for all the persistors, needs to implements a \`self.model\`
    # returning the class to persist.
    # A persistor , is used to save and load it's cousin class.
    # The specific code of a persistor should be extended by writting
    # a persistor module in the sub-persistence module. This module will be 
    # automatically included to generated class. See {Persistence.finalize_submodule}.
    # Each instance can get an identity map, and or parameter
    # specific to a session/thread.
    class Persistor
      include IdentityMap

      def initialize (session, *args, &block)
        @session = session
        super(*args, &block)
      end

      # Associate class (without persistence).
      # @return [Class]
      def model
        self.class::Model
      end

      # Load a model by different criteria. Could be either :
      # - an Id
      # - a Hash 
      # - a list of Ids
      # This method will return either a single object or a list of object,
      # depending of the parameter.
      # Note that loaded object are automatically _added_ to the session.
      # @param [Fixnum, Hash] id the id in the database
      # @return [Object,nil] nil if  object not found.
      def [](id)
        case id
        when Fixnum then get_or_create_single_model(id)
        when Hash then find_by(filter_attributes_on_save(id), :single => true)
        end
      end

      # save an object and return is id or nil if failure
      # @return [Fixnum, nil]
      def save(object, *params)
        return nil if object.nil?
        id_for(object) { |id| update(object, id, *params) } ||
          map_id_object(save_new(object, *params) , object)
      end

      # deletes an object and returns its id or nil if failure
      # @return [Fixnum, nil]
      def delete(object, *params)
        return nil if object.nil?
        id_for(object) do |id|
          # We need to delet the children before the parent
          # to not break any constraints
          delete_children(id, object)
          delete_raw(object, id, *params)
        end
      end
      # save an association
      # Association doesn't have necessarily and id
      # therefore we don't use the indentity map.
      # Save objects if needed.
      # @param [Resource, Id] source the source of the association.
      # @param [Resource, Id] target the target of the association.
      # @param [Hash] params specific to the Store.
      def save_as_association(source, target, *params)
        save_raw_association(@session.id_for!(source), @session.id_for!(target), *params)
      end


      # save an aggregation
      # Aggregation doesn't have necessarily and id
      # therefore we don't use the indentity map.
      # Save objects if needed.
      # Aggregation differs from association in the fact that the 'parent' is already saved
      # and the children have to be saved.
      # @param [id] source_id 
      # @param [Resource] target will be saved.
      # @param [Hash] params specific to the Store.
      def save_as_aggregation(source_id, target, *params)
        save_raw_association(source_id, @session.save(target), *params)
      end

      # Load a model object (and its children) from its database id.
      # @param [Id] id in the database
      # @param [Hash] raw_attributes attributes to build the object
      # @return [Resource] the model object.
      # @raise error if object doesn't exists.
      def load_single_model(id, raw_attributes=nil)
        raw_attributes ||= load_raw_attributes(id)
        model.new(filter_attributes_on_load(raw_attributes) || {}).tap do |m|
          load_children(id, m)
        end
      end
      private :load_single_model

      # create or get an object if already in cache
      # The raw_attributes is there for convenience  to
      # create the object with parameters is they have already been loaded
      # (bulk load for example).
      def get_or_create_single_model(id, raw_attributes=nil)
        object_for(id) || load_single_model(id, raw_attributes).tap do |m|
          map_id_object(id, m)
          @session.on_object_load(m)
        end
      end
      protected :get_or_create_single_model

      # create or get a list of objects.
      # Only load the ones which aren't in cache
      # @param [Array<Id>] ids list of ids to get
      # @param [Array<Hash>] list of raw_attributes (@see get_or_create_single_model)
      # @return [Array<Resource>]
      # @todo bulk load if needed
      def get_or_create_multi_model(ids, raw_attributes_list=[])
        ids.zip(raw_attributes_list).map { |i, r| get_or_create_single_model(i, r) }
      end
      protected :get_or_create_multi_model

      # Create or get one or object matching the criteria
      # @param [Hash] criteria, map of (attributes, value) to match
      # @param [Boolean] single wether to check for uniquess or not
      # @return [Object,nil,Array<Object>] an Object or and Array depending of single.
      #
      def find_by(criteria, single=false)
        ids = ids_for(criteria)

        if single
          raise RuntimeError, "More than one object match the criteria" if ids.size > 1
          return nil if ids.size < 1
          get_or_create_single_model(ids.first)
        else
          get_or_create_multi_model(ids)
        end
      end
      protected :find_by

      # compute a list of ids matching the criteria
      # @param [Hash] criteria list of attribute/value pais
      # @return [Array<Id>] 
      def ids_for(criteria)
        raise NotImplementedError
      end


      def load_associated_elements()
      end

      def load_aggregated_elements(id, &block)
        load_raw_associations(id).each do |element_id|
        end
      end

      # @abstract
      # Returns the number of object in the store
      # @return [Fixnum]
      def count
        raise NotImplementedError
      end
      
      # @abstract
      # Load a slice. Doesn't return an object but a hash
      # allowing to build it.
      # @param [Fixnum] start (0 based)
      # @param [Fixnum] length
      # @yieldparam [Fixnum] key
      # @yieldparam [Hash] attributes of the object
      def for_each_in_slice(start, length)
        raise NotImplementedError
      end

      # Get a slice of object by offset, length.
      # +start+ here is an offset (starting at 0) not an Id.
      # @param [Fixnum] start (0 based)
      # @param [Fixnum] length
      # @return [Enumerable<Hash>]
      def slice(start, length)
        Enumerator.new do |yielder|
          for_each_in_slice(start, length) do |id, att|
            yielder << get_or_create_single_model(id, att)
          end
        end
      end

      protected
      # The primary key 
      # @return [Symbol]
      def primary_key()
        :id
      end

      # load the object without any dependency
      # @param id identifier of the object
      # @return the loaded object
      def load_raw_object(id)
        raise NotImplementedError
      end

      # Called to save a new object, i.e. which is not
      # already in the database.
      # @param [Resource] object the object 
      # @return [Fixnum, nil] the Id if save successful
      def save_new(object, *params)
        save_raw(object, *params).tap do |id|
          save_children(id, object)
        end
      end

      # @param object the object to save
      def save_raw(object, *params)
        raise NotImplementedError
      end

      # Save a object already in the database
      # @param [Resource] object the object 
      # @param [Fixum] id id in the database
      # @return [Fixnum, nil] the Id if save successful.
      def update(object, id, *params)
        # naive version , update everything.
        # Probably quicker than trying to guess what has changed
        id.tap do
          update_raw(object, id, *params)
          update_children(id, object)
        end
      end

      def delete_raw(object, id)
        raise NotImplementedError
      end

      # save children of a newly created object.
      # @param [Fixum] id id in the database
      # @param [Resource] object the object 
      def save_children(id, object)

      end

      # save children of an existing object.
      # @param [Fixum] id id in the database
      # @param [Resource] object the object 
      def update_children(id, object)
        delete_children(id, object)
        save_children(id, object)
      end

      def delete_children(id, object)
      end

      # Loads children from the database and set the to model object.
      # @param id primary key of the model object in the database.
      # @param m  instance of model to load
      def load_children(id, m)
      end

      # Transform  store fields to object attributes
      # This can be used to change the name of an attribute (its key)
      # or its value or both (example resource to resource_id)
      # This is the reverse of {#filter_attributes_on_save}
      # @param [Hash] attributes
      # @return [Hash]
      def filter_attributes_on_load(attributes)
        attributes
      end

      # Transform object attributes to store fields
      # This can be used to change the name of an attribute (its key)
      # or its value or both (example resource to resource_id)
      # @param [Hash] attributes
      # @return [Hash]
      def filter_attributes_on_save(attributes)
        attributes
      end

    end
  end
end
__END_OF_persistor.rb__
filename='lib/lims-core/laboratory/plate/plate_persistor.rb
mkdir -p $(dirname $filename)
cat <<__END_OF_plate.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2 spell:spelllang=en

require 'lims/core/persistence/persistor'
require 'lims/core/persistence/container'
require 'lims/core/persistence/container_element'
require 'lims/core/laboratory/plate'

module Lims::Core
  module Laboratory

    # Base for all Plate persistor.
    # Real implementation classes (e.g. Sequel::Plate) should
    # include the suitable persistor.
    class Plate::PlatePersistor < Persistor
      Model = Laboratory::Plate

      include Container

      # calls the correct element method
      def element
        well
      end

      def well
        @session.send("Plate::Well")
      end

      # Base for all Well persistor.
      # Real implementation classes (e.g. Sequel::Well) should
      # include the suitable persistor.
      class Well < Persistor
        Model = Laboratory::Plate::Well

        include ContainerElement

      end
    end
  end
end
__END_OF_plate.rb__
filename='lib/lims-core/laboratory/sample/sample_persistor.rb
mkdir -p $(dirname $filename)
cat <<__END_OF_sample.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2 spell:spelllang=en


require 'lims/core/persistence/persistor'
require 'lims/core/laboratory/sample'

module Lims::Core
  module Laboratory
    # @abstract
    # Base for all Sample persistor.
    # Real implementation classes (e.g. Sequel::Aliquot) should
    # include the suitable persistor.
    class Sample::SamplePersistor < Persistor
      Model = Laboratory::Sample

      # Doesn't update. At the moment, samples are managed as an external table
      # For testing convenience saving a new object is allowed but update is not.
      # We don't need to modify sample, so when called this method should do nothing.
      # Ideally the external table should be a read-only view.
      # @param [Resource] object the object 
      # @param [Fixum] id id in the database
      # @return [Fixnum, nil] the Id if save successful.
      def update(object, id, *params)
        id
      end

      # @see {update}
      def delete(object, *params)
      end
    end
  end
end
__END_OF_sample.rb__
filename='lib/lims-core/persistence/search.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_search.rb__ > $filename
#vi: ts=2 sw=2 et
require 'common'

require 'lims-core/resource'
require 'lims-core/persistence/persistor'
require 'lims-core/persistence/filter'

# We need to load all the possible filter to be able load them by name.
require_all('*filter')

module Lims::Core
  module Laboratory
    # base class handling searches. A Search represent a set of parameters 
    # which when executed returns a set of similar object (.i.e the same class).
    # A search is savable.
    class Search
      include Resource
      attribute :description, String, :required => true, :initializable => true, :write => :private
      attribute :model, Class, :required => true, :initializable => true, :writer => :private
      attribute :filter, Filter, :required => true, :initializable => true, :writer => :private

      # Main method. Take an session an return an filtered persistor.
      # @param [Session]
      # @return [Persistor]
      def call(session)
        filter.call(session.persistor_for(@model))
      end

      # Base persistor for Search object.
      # It should be called Persistence::Search but, this is 
      # already taken by the main Search class.
      class Persistor < Persistence::Persistor
        Model = Persistence::Search
      end
    end
  end
end

__END_OF_search.rb__
filename='lib/lims-core/persistence/sequel/aliquot.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_aliquot.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2 spell:spelllang=en

require 'lims/core/persistence/aliquot'
require 'lims/core/persistence/sequel/persistor'

module Lims::Core
  module Laboratory
    module Sequel
      # Not a aliquot but a aliquot persistor.
      class Aliquot < Persistence::Aliquot
        include Sequel::Persistor
        def self.table_name
          :aliquots
        end

        def filter_attributes_on_save(attributes)
          attributes.mash do |k,v|
            case k
            when :tag then [:tag_id, @session.id_for!(v)]
            when :sample then [:sample_id, @session.id_for!(v)]
            else [k, v]
            end
          end
        end

        def filter_attributes_on_load(attributes)
          attributes.mash do |k,v|
            case k
            when :tag_id then [:tag, @session.oligo[v]]
            when :sample_id then [:sample, @session.sample[v]]
            else [k, v]
            end
          end
        end

      end
    end
  end
end
__END_OF_aliquot.rb__
filename='lib/lims-core/persistence/sequel/batch.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_batch.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2 spell:spelllang=en

require 'lims/core/persistence/batch'
require 'lims/core/persistence/sequel/persistor'

module Lims::Core
  module Laboratory
    module Sequel
      class Batch < Persistence::Batch
        include Sequel::Persistor

        def self.table_name
          :batches
        end
      end
    end
  end
end
__END_OF_batch.rb__
filename='lib/lims-core/persistence/sequel/container.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_container.rb__ > $filename
module Lims::Core
  module Laboratory
    module Sequel
      module Container

        # The specific container should implement this method
        # and return the proper container_id with symbol type
        # i. e. :gel_id
        def container_id_sym
          raise NotImplementedError
        end

        # The specific container should implement this method
        # and return the proper dataset of the element of the container
        # i.e. in the case of Gel: Window::dataset(@session)
        def element_dataset
          raise NotImplementedError
        end

        # Delete all children of the given container
        # But don't destroy the 'external' elements (example aliquots)
        # @param [Fixnum] id the id in the database
        # @param [i.e. Laboratory::Gel] container
        def delete_children(id, gel)
          element_dataset.filter(container_id_sym => id).delete
        end

        # Load all children of the given container
        # Loaded object are automatically added to the session.
        # @param [Fixnum] id the id in the database
        # @param [i.e. Laboratory::Gel] container
        # @return [i.e. Laboratory::Gel, nil] 
        def load_children(id, container)
          element.load_aliquots(id) do |position, aliquot|
            container[position] << aliquot
          end
        end

      end
    end
  end
end
__END_OF_container.rb__
filename='lib/lims-core/persistence/sequel/container_element.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_container_element.rb__ > $filename
module Lims::Core
  module Laboratory
    module Sequel
      module ContainerElement

        def save_raw_association(container_id, aliquot_id, position)
            dataset.insert(container_id_sym => container_id,
                           :position => position,
                           :aliquot_id  => aliquot_id)
        end

        # Do a bulk load of aliquot and pass each to a block
        # @param container_id the id of the container to load.
        # @yieldparam [Integer] position
        # @yieldparam [Aliquot] aliquot
        def load_aliquots(container_id)
          element_dataset.join(Aliquot::dataset(@session), :id => :aliquot_id).filter(container_id_sym => container_id).each do |att|
            position = att.delete(:position)
            att.delete(:id)
            aliquot  = @session.aliquot.get_or_create_single_model(att[:aliquot_id], att)
            yield(position, aliquot)
          end
        end

      end
    end
  end
end
__END_OF_container_element.rb__
filename='lib/lims-core/persistence/sequel/filters.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_filters.rb__ > $filename
require 'lims/core/persistence/sequel/persistor'
require 'active_support/inflector'

module Lims::Core
  module Laboratory
    module Sequel
      # Implementes filter methods needed by persitors.
      module Filters
        # Implement a multicriteria filter for a Sequel::Persistor.
        # Value can be either a String, an Array  or a Hash.
        # Strings and Arrays are normal filters, whereas Hashes
        # correspond to a joined search. The criteria will apply to the 
        # joined object corresponding to the key.
        # @param [Hash<String, Object > criteria
        # @return [Persistor]
        def multi_criteria_filter(criteria)
          # We need to create the adequat dataset.
          dataset = __multi_criteria_filter(criteria).dataset
          # As the dataset can include join, we need to select only the columns
          # corresponding to the persistor
          self.class.new(self, dataset.qualify(table_name).distinct())
        end

        # Implements a label filter for a Sequel::Persistor.
        # Nil value would be ignored
        # @param [String, Nil] position of the label 
        # @param [String, Nil] value of the label
        # @param [String, Nil] type fo the label
        # @return [Persistor]
        def label_filter(criteria)
          labellable_dataset = @session.labellable.__multi_criteria_filter(criteria).dataset

          # join labellabe request to uuid_resource
          persistor = self.class.new(self, labellable_dataset.join("uuid_resources", :uuid => :"name"))

          # join everything to current resource table
          # Qualify method is needed to get only the fields related to the searched
          # resource. Otherwise, multiple id columns are returned which lead to a
          # ambiguous situation when we try to get the id of the resource. 
          # This leads to an incorrect uuid for the found resources.
          self.class.new(self, dataset.join(persistor.dataset, :key => primary_key).qualify)
        end

        # Implement an order filter for a Sequel::Persistor.
        # @param [Hash<String, Object>] criteria
        # @example
        #     {:order => {:item => {:status => "pending"}, :status => "draft"}}
        #     Create a request to get the resources in a draft order
        #     with a pending item status.
        #     @return [Persistor]
        def order_filter(criteria)
          criteria = criteria[:order] if criteria.keys.first.to_s == "order"
          order_persistor = @session.order.__multi_criteria_filter(criteria)
          order_dataset = order_persistor.dataset

          # If criteria doesn't include an item key, we need 
          # to make the join with the table items here.
          unless criteria.has_key?("item") or criteria.has_key?(:item)
            order_dataset = order_dataset.join(:items, :order_id => order_persistor.primary_key)
          end
          
          # Join order dataset with the uuid_resources table 
          order_dataset = order_dataset.join(:uuid_resources, :uuid => :items__uuid)            

          # Join order dataset with the resource dataset
          # Qualify method is needed to get only the fields related
          # to the resource table. Otherwise, id could be confused.
          # The expected request would be for example something like
          # select plates.* from ...
          # As a same resource could belong to multiple orders, distinct
          # is used to get only one copy of each resource.
          self.class.new(self, dataset.join(order_dataset, :key => primary_key).qualify.distinct)
        end

        # Implement a batch filter for a Sequel::Persistor.
        # @param [Hash<String, Object>] criteria
        # @example
        #   {:batch => {:uuid => '11111111-2222-3333-4444-555555555555'}}
        #   Create a request to get the resources which are referenced by
        #   an order item assigned to a batch with the given uuid.
        #   Is equivalent to the criteria:
        #   {:order => {:item => {:batch => {:uuid => '11111111-2222-3333-4444-555555555555'}}}}
        def batch_filter(criteria)
          order_filter({:order => {:item => criteria } })
        end

        protected
        # @param Hash criteria
        # @return Persistor
        def __multi_criteria_filter(criteria)
          # Extract critera recursively and apply subhashes to
          # joined table
          # Hash value are criteria for the corresponding joined tabled
          # We need to extract them and do the obvious join
          # Values are passed to filter_attributes_on save to get
          # the right format if needed.
          joined = criteria.reduce(self) do |persistor, (key, value)|
            case value
            when Hash
              criteria_persistor = persistor.send(key)
              filtered_value = criteria_persistor.filter_attributes_on_save(value.rekey {|k| k.to_sym})
              joined_persistor = criteria_persistor.__multi_criteria_filter(filtered_value)
              __join(joined_persistor)
            else persistor
            end
          end

          # We need to passes to filter are applied on the joined persistor.
          # This is needed because the __join function expected bare persistor 
          # and will loose any filter applied on the original persistor
          criteria.reduce(joined) do |persistor, (key, value)|
            case value
            when Hash
              persistor
            else
              self.class.new(persistor, persistor.dataset.filter(::Sequel.qualify(table_name, key) => value))
            end
          end
        end

        # Assume that the original persistor his *blank* ie 
        # it doesn't contain any SQL modifier
        # @param [Persistor] persistor
        # @return [Persistor]
        def __join(persistor)
          self.class.new(self, persistor.dataset.join(table_name, primary_key => :"#{table_name.to_s.singularize}_#{persistor.primary_key}"))
        end

      end
    end
  end
end

__END_OF_filters.rb__
filename='lib/lims-core/persistence/sequel/flowcell.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_flowcell.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2 spell:spelllang=en

require 'lims/core/persistence/flowcell'
require 'lims/core/persistence/sequel/persistor'

module Lims::Core
  module Laboratory
    module Sequel
      # Not a flowcell but a flowcell persistor.
      class Flowcell < Persistence::Flowcell
        include Sequel::Persistor

      # Not a lane but a lane {Persistor}.
        class Lane < Persistence::Flowcell::Lane
          include Sequel::Persistor
          def self.table_name
            :lanes
          end

          def save_raw_association(flowcell_id, aliquot_id, position)
            dataset.insert(:flowcell_id => flowcell_id,
                           :position => position,
                           :aliquot_id  => aliquot_id)
          end

          # Do a bulk load of aliquot and pass each of a block
          # @param flowcell_id the id of the flowcell to load.
          # @yieldparam [Integer] position
          # @yieldparam [Aliquot] aliquot
          def load_aliquots(flowcell_id)
            Lane::dataset(@session).join(Aliquot::dataset(@session), :id => :aliquot_id).filter(:flowcell_id => flowcell_id).each do |att|
              position = att.delete(:position)
              att.delete(:id)
              aliquot  = @session.aliquot.get_or_create_single_model(att[:aliquot_id],  att )
              yield(position, aliquot)
            end
          end
        end #class Lane

        def self.table_name
          :flowcells
        end

        # Save all children of the given flowcell
        # @param [Fixnum] id the id in the database
        # @param [Laboratory::Flowcell] flowcell
        # @return [Boolean]
        def save_children(id, flowcell)
          flowcell.each_with_index do |lane, position|
            @session.save(lane, id, position)
          end
        end

        # Delete all children of the given flowcell
        # But don't destroy the 'external' elements (example aliquots)
        # @param [Fixnum] id the id in the database
        # @param [Laboratory::Flowcell] flowcell
        def delete_children(id, flowcell)
          Lane::dataset(@session).filter(:flowcell_id => id).delete
        end

        def lane
          @session.send("Flowcell::Lane")
        end

        # Load all children of the given flowcell
        # Loaded object are automatically added to the session.
        # @param [Fixnum] id the id in the database
        # @param [Laboratory::Flowcell] flowcell
        # @return [Laboratory::Flowcell, nil] 
        #
        def load_children(id, flowcell)
          lane.load_aliquots(id) do |position, aliquot|
            flowcell[position] << aliquot
          end
        end
      end
    end
  end
end
__END_OF_flowcell.rb__
filename='lib/lims-core/persistence/sequel/gel.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_gel.rb__ > $filename
require 'lims/core/persistence/gel'
require 'lims/core/persistence/sequel/persistor'
require 'lims/core/persistence/sequel/container'
require 'lims/core/persistence/sequel/container_element'

module Lims::Core
  module Laboratory
    module Sequel
      # A gel persistor. It saves the gel's data to the DB.
      class Gel < Persistence::Gel
        include Sequel::Persistor
        include Container

        module GelContainerElement
          include ContainerElement

          def element_dataset
            Lims::Core::Persistence::Sequel::Gel::Window::dataset(@session)
          end

          def container_id_sym
            :gel_id
          end

        end

        # A window persistor. It saves the window's data to the DB.
        class Window < Persistence::Gel::Window
          include Sequel::Persistor
          include GelContainerElement

          def self.table_name
            :windows
          end

        end 
        #class Window

        def self.table_name
          :gels
        end

        def container_id_sym
          :gel_id
        end

        def element_dataset
          Window::dataset(@session)
        end
      end
    end
  end
end
__END_OF_gel.rb__
filename='lib/lims-core/persistence/sequel/labellable.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_labellable.rb__ > $filename
require 'lims/core/persistence/labellable'
require 'lims/core/persistence/sequel/persistor'

require 'lims/core/uuids/uuid_resource'

module Lims::Core
  module Laboratory
    module Sequel
      class Labellable < Persistence::Labellable
        include Sequel::Persistor

        def self.table_name
          :labellables
        end


        def save_raw_association(labellables_id, labels_id)
            dataset.insert(:labellables_id => labellables_id, :labels_id  => labels_id)
        end

        def filter_attributes_on_save(attributes, *params)
          attributes.delete(:content)
          if attributes[:type] == "resource"
            name = attributes[:name]
            attributes[:name] = @session.pack_uuid(name)
          end
          attributes
        end

        def filter_attributes_on_load(attributes, *params)
          if attributes[:type] == "resource"
            name = attributes[:name]
            attributes[:name] = @session.unpack_uuid(name)
          end
          attributes
        end

          # Mixin to be included by classes of Labellable::Labels
          class Label  < Persistence::Labellable::Label
            include Sequel::Persistor

            def self.table_name
              :labels
            end

            def load(labellable_id)
              dataset.filter(:labellable_id => labellable_id).each do |att|
                position = att.delete(:position)
                label =  Laboratory::Labellable::Label::new(att)
                yield(position, label)
              end
            end

            def filter_attributes_on_save(attributes, labellable_id=nil, position=nil)
              attributes.tap do
                attributes[:labellable_id]= labellable_id if labellable_id
                attributes[:position] = position if position
              end
            end
          end
        end
      end
    end
  end
__END_OF_labellable.rb__
filename='lib/lims-core/persistence/sequel/migrations/initial.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_initial.rb__ > $filename
# This module should not be require on it's own.
# Require migrations instead.

module Lims::Core::Persistence::Sequel::Migrations
  Initial = Proc.new do
    change do
      create_table :samples do
        primary_key :id
        String :name
      end

      create_table :oligos do
        primary_key :id
        String :sequence
      end

      create_table :aliquots do
        primary_key :id
        foreign_key :sample_id, :samples, :key => :id
        foreign_key :tag_id, :oligos, :key => :id
        Integer :quantity
        String :type
      end

      create_table :flowcells do
        primary_key :id
        Integer :number_of_lanes
      end

      create_table :lanes do
        #primary_key :flowcell_id, :position
        primary_key :id
        foreign_key :flowcell_id, :flowcells, :key => :id
        Integer :position
        foreign_key :aliquot_id, :aliquots, :key => :id
      end

      create_table :tubes do
        primary_key :id
      end

      create_table :tube_aliquots do
        primary_key :id
        Integer :tube_id
        foreign_key :aliquot_id, :aliquots, :key => :id
      end

      create_table :spin_columns do
        primary_key :id
      end

      create_table :spin_column_aliquots do
        primary_key :id
        Integer :spin_column_id
        foreign_key :aliquot_id, :aliquots, :key => :id
      end

      create_table :plates do
        primary_key :id
        Integer :number_of_rows
        Integer :number_of_columns
      end

      create_table :wells do
        primary_key :id
        foreign_key :plate_id, :plates, :key => :id
        Integer :position
        foreign_key :aliquot_id, :aliquots, :key => :id
      end

      create_table :tube_racks do
        primary_key :id
        Integer :number_of_rows
        Integer :number_of_columns
      end

      create_table :tube_rack_slots do
        primary_key :id
        foreign_key :tube_rack_id, :tube_racks, :key => :id
        Integer :position
        foreign_key :tube_id, :tubes, :key=> :id
      end

      create_table :tag_groups do
        primary_key :id
        String :name
      end

      create_table :tag_group_associations do
        primary_key :id
        foreign_key :tag_group_id, :tag_groups, :key => :id
        Integer :position
        foreign_key :oligo_id, :oligos, :key => :id
      end

      create_table :uuid_resources do
        primary_key :id
        String :uuid, :fixed => true, :size => 64
        String :model_class
        Integer :key
      end

      create_table :users do
        primary_key :id
      end

      create_table :studies do
        primary_key :id
      end

      create_table :orders do
        primary_key :id
        foreign_key :creator_id, :users, :key => :id

        String :pipeline
        String :parameters
        String :status
        blob :state
        foreign_key :study_id, :studies, :key => :id
        String :cost_code
      end

      create_table :items do
        primary_key :id
        foreign_key :order_id, :orders, :key => :id
        String :role
        foreign_key :resource_id, :uuid_resources, :key => :id
        String :uuid, :fixed => true, :size => 64
        String :status
        Integer :iteration, :default => 0
      end

      create_table :searches do
        primary_key :id
        String :description
        String :filter_type
        String :model
        blob :filter_parameters
      end

      create_table :labellables do
        primary_key :id
        String :name
        String :type
      end

      create_table :labels do
        primary_key :id
        foreign_key :labellable_id, :labellables, :key => :id
        String :type
        String :position
        String :value
      end
    end
  end
end
__END_OF_initial.rb__
filename='lib/lims-core/persistence/sequel/migrations.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_migrations.rb__ > $filename
require 'common'

# A namespace containing migrations mixin
module Lims
  module Core
    module Laboratory
      module Sequel
        module Migrations
        end
      end
    end
  end
end
require_all('migrations/*') 
__END_OF_migrations.rb__
filename='lib/lims-core/persistence/sequel/order.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_order.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2 spell:spelllang=en

require 'lims/core/persistence/order'
require 'lims/core/persistence/sequel/persistor'

module Lims::Core
  module Laboratory
    module Sequel
      # Not a order but a order persistor.
      class Order < Persistence::Order
        include Sequel::Persistor
        def self.table_name
          :orders
        end

        def filter_attributes_on_save(attributes, *params)
          attributes.mash do |k,v|
            case k
              # get id of object
            when  :creator then [:creator_id, @session.id_for!(v)]
            when :study then [:study_id, @session.id_for!(v)]
              # serialize structured object
            when :parameters, :state then [k, Marshal.dump(v) ]
            else [k, v]
            end
          end
        end

        def filter_attributes_on_load(attributes)
          attributes.mash do |k,v|
            case k
            when :creator_id then [:creator, @session.user[v]]
            when :study_id then [:study, @session.study[v]]
            when :parameters, :state then [k, Marshal.load(v) ]
            else [k, v]
            end
          end
        end

        class Item < Persistence::Order::Item
          include Sequel::Persistor

          def self.table_name
            :items
          end

          def loads(order_id)
            dataset.filter(:order_id => order_id).order(:id).each do |att|
              role = att.delete(:role)
              item = @session.order.item.get_or_create_single_model(att[:id], att)
              yield(role, item)
            end
          end
        end
      end
    end
  end
end
__END_OF_order.rb__
filename='lib/lims-core/persistence/sequel/persistor.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_persistor.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2 spell:spelllang=en

require 'lims/core/persistence/identity_map'
require 'lims/core/persistence/sequel/filters'
require 'active_support/inflector'


module Lims::Core
  module Laboratory
    module Sequel
      # Mixin giving extended the persistor classes with
      # the Sequel (load/save) behavior.
      module Persistor

        include Filters

        def self.included(klass)
          klass.class_eval do
            # @return [String] the name of SQL table.
            def self.table_name
              @table_name ||= name.split('::').last.pluralize.snakecase.to_sym
            end
            # The Sequel::Dataset.
            # Corresponds to table.
            # @param [Sequel::Session] session 
            # @return [::Sequel::Dataset]
            def self.dataset(session)
              session.database[self.table_name]
            end
          end
        end

        def initialize(session_or_persistor, dataset=nil, *args, &block )
          id_to_object, object_to_id = [nil, nil]
          case session_or_persistor
          when Sequel::Persistor
            # We link the session and the identity map variables,
            # so that object loaded via this persistor can be found (and their id)
            # through the origial persistor.
            # Hack to get those private variables.
            session, identity_map_parameters  =  session_or_persistor.instance_eval do
              [@session, [@id_to_object, @object_to_id]]
            end
            super(session, *args, &block)
            @id_to_object , @object_to_id = identity_map_parameters
          else Session
            super(session_or_persistor, *args, &block)
          end

          @dataset = dataset || self.class.dataset(@session)
        end

        # @return  [String] the name of the table
        def table_name
          self.class.table_name
        end


        # The Sequel::Dataset.
        # Corresponds to a table.
        # @return [::Sequel::Dataset]
        def dataset
          @dataset
        end


        # Returns the number of object in the store
        # @return [Fixnum]
        def count
          dataset.count
        end

        protected
        # load a slice.
        def for_each_in_slice(start, length)
          return if length == 0
          dataset.order(primary_key).limit(length, start).each do |h|
            key = h.delete(primary_key)
            yield(key, h)
          end
        end

        # The primary key 
        # @return [Symbol]
        def primary_key()
          :id
        end

        def load_raw_attributes(id, raw_attributes=nil)
          dataset[primary_key => id ]
        end

        def ids_for(criteria)
          # Use prepared statement
          # @todo cache prepared statement or move in UuidResourcePersistor
          # OLD dataset.select(primary_key)[criteria] || []
          #
          ds=dataset.select(primary_key).filter(criteria.keys.mash { |k| [k, :"\$#{k}"] })
          statement_name = :"#{table_name}__ids_for"
          ds.prepare(:select, statement_name)

          # for some reason, the prepared statement return an array of Hashes insteead
          # of an array of ids, as data.select(primary_key) will do
          (@session.database.call(statement_name, criteria) || []).map { |h| h[primary_key] }

        end

        # Save a raw object, i.e. the object
        # attributes excluding any associations.
        # @param [Resource] object the object 
        # @return [Fixnum, nil] the Id if save successful
        def save_raw(object, *params)
          # use prepared statement for everything
          # We only need it at the moment as a workaround for saving the UUID
          # So we might in the future either move it to a UuidResourcePersistor
          # or cached it by attributes
          # @todo benchmark against normal insert
          attributes = filter_attributes_on_save(object.attributes, *params)
          statement_name = :"#{table_name}__save_raw"
          dataset.prepare(:insert, statement_name, attributes.keys.mash { |k| [k, :"\$#{k}"] })
          @session.database.call(statement_name, attributes)
        end

        # Upate a raw object, i.e. the object attributes
        # excluding any associations.
        # @param [Resource] object the object 
        # @param [Fixnum] id the Id of the object
        # @return [Fixnum, nil] the id 
        def update_raw(object, id, *params)
          id.tap do
            attributes = filter_attributes_on_save(object.attributes, *params)
            return true if attributes == {}
            statement_name = :"#{table_name}__update_raw"
            dataset.filter(primary_key => id).prepare(:update, statement_name, attributes.keys.mash { |k| [k, :"\$#{k}"] })
            @session.database.call(statement_name, attributes)
          end
        end

        def delete_raw(objec, id, *params)
          id.tap do
            dataset.filter(primary_key => id).delete
          end
        end
      end
    end
  end
end
__END_OF_persistor.rb__
filename='lib/lims-core/persistence/sequel/plate.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_plate.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2 spell:spelllang=en

require 'lims/core/persistence/plate'
require 'lims/core/persistence/sequel/persistor'
require 'lims/core/persistence/sequel/container'
require 'lims/core/persistence/sequel/container_element'

module Lims::Core
  module Laboratory
    module Sequel
      # Not a plate but a plate persistor.
      class Plate < Persistence::Plate
        include Sequel::Persistor
        include Container

        module PlateContainerElement
          include ContainerElement

          def element_dataset
            Lims::Core::Persistence::Sequel::Plate::Well::dataset(@session)
          end

          def container_id_sym
            :plate_id
          end

        end

        # Not a well but a well {Persistor}.
        class Well < Persistence::Plate::Well
          include Sequel::Persistor
          include PlateContainerElement

          def self.table_name
            :wells
          end

        end #class Well

        def self.table_name
          :plates
        end

        def container_id_sym
          :plate_id
        end

        def element_dataset
          Well::dataset(@session)
        end
      end
    end
  end
end
__END_OF_plate.rb__
filename='lib/lims-core/persistence/sequel/search.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_search.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2 spell:spelllang=en

require 'lims/core/persistence/search'
require 'lims/core/persistence/sequel/persistor'


module Lims::Core
  module Laboratory
    module Sequel
      # Not a search but a search persistor.
      class Search < Persistence::Search::Persistor
        include Sequel::Persistor

        def self.table_name
          :searches
        end

        def filter_attributes_on_load(attributes)
          {
            :description => attributes[:description],
            :model => constant(attributes[:model]),
            :filter => Persistence.const_get(attributes[:filter_type]).new(Marshal.load(attributes[:filter_parameters]))
          }
        end
        def filter_attributes_on_save(attributes, *args)
          filter = attributes[:filter]
          {
            :description => attributes[:description],
            :model => attributes[:model].name,
            :filter_type => filter.class.name.split('::').last,
            :filter_parameters => Marshal.dump(filter.attributes)
          }
        end
      end
    end
  end
end
__END_OF_search.rb__
filename='lib/lims-core/persistence/sequel/session.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_session.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2 spell:spelllang=en

require 'sequel'
require 'lims/core/persistence'
require 'lims/core/persistence/uuidable'

module Lims::Core
  module Laboratory
    module Sequel
      # Sequel specific implementation of a {Persistence::Session Session}.
      class Session < Persistence::Session
        include Uuidable
        # Pack if needed an uuid to its store representation
        # @param [String] uuid
        # @return [Object]
        def self.pack_uuid(uuid)
          # Normal behavior shoulb be pack to binary data
          #Uuids::UuidResource::pack(uuid)
          #For now, we just compact it.
          Uuids::UuidResource::compact(uuid)

        end

        # Unpac if needed an uuid from its store representation
        # @param [Object] puuid
        # @return [String]
        def self.unpack_uuid(puuid)
          #Uuids::UuidResource::unpack(puuid)
          Uuids::UuidResource::expand(puuid)
        end
      end
    end
  end
end
__END_OF_session.rb__
filename='lib/lims-core/persistence/sequel/spin_column.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_spin_column.rb__ > $filename
require 'lims/core/persistence/spin_column'
require 'lims/core/persistence/sequel/persistor'

module Lims::Core
  module Laboratory
    module Sequel
      # a spin column persistor.
      class SpinColumn < Persistence::SpinColumn
        include Sequel::Persistor

        class SpinColumnAliquot < Persistence::SpinColumn::SpinColumnAliquot
          include Sequel::Persistor

          # Do a bulk load of aliquot and pass each to a block
          # @param spin_column_id the id of the spin column to load.
          # @yieldparam [Integer] position
          # @yieldparam [Aliquot] aliquot
          def load_aliquots(spin_column_id)
            dataset.join(Aliquot::dataset(@session), :id => :aliquot_id).filter(:spin_column_id => spin_column_id).each do |att|
              att.delete(:id)
              aliquot  = @session.aliquot.get_or_create_single_model(att[:aliquot_id], att)
              yield(aliquot)
            end
          end

          def save_raw_association(spin_column_id, aliquot_id)
              dataset.insert(:spin_column_id => spin_column_id, :aliquot_id  => aliquot_id)
          end
        end

        # Delete all children of the given spin column
        # But don't destroy the 'external' elements (example aliquots)
        # @param [Fixnum] id the id in the database
        # @param [Laboratory::SpinColumn] spin column
        def delete_children(id, spin_column)
          SpinColumnAliquot::dataset(@session).filter(:spin_column_id => id).delete
        end
      end
    end
  end
end
__END_OF_spin_column.rb__
filename='lib/lims-core/persistence/sequel/store.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_store.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2

require 'lims/core/persistence'
require 'lims/core/persistence/sequel/session'
require 'lims/core/persistence/sequel/persistor'

require 'sequel'

module Lims::Core
  module Laboratory
    module Sequel
      # An Sequel::Store, ie an wrapper around a database
      # using the sequel gem
      class Store < Persistence::Store
        attr_reader :database

        # Create a store with a Sequel::Database
        # We don't wrap for now the creation  of the database
        # @param [Sequel::Database] type underlying database
        def initialize(database, *args)
          raise RuntimeError unless database.is_a?(::Sequel::Database)
          @database = database
          super(*args)
        end

        # Execute given block within a transaction
        def transaction
          database.transaction do
            super
          end
        end
      end
    end
    finalize_submodule(Sequel)
  end
end
__END_OF_store.rb__
filename='lib/lims-core/persistence/sequel/tag_group.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_tag_group.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2 spell:spelllang=en

require 'lims/core/persistence/tag_group'
require 'lims/core/persistence/sequel/persistor'

module Lims::Core
  module Laboratory
    module Sequel
      # Not a tag_group but a tag_group persistor.
      class TagGroup < Persistence::TagGroup
        include Sequel::Persistor


         def save_raw_association(tag_group_id, oligo_id, position)
            Association::dataset(@session).insert(:tag_group_id => tag_group_id,
                           :position => position,
                           :oligo_id  => oligo_id)
          end

         def delete_children(id, group)
           return unless id.present?
           Association::dataset(@session).filter(primary_key => id).delete
         end


         class Association < Persistence::TagGroup::Association
           include Sequel::Persistor
           def self.table_name
             :tag_group_associations
           end

           # Load each oligos and pass them to the block
           # @param [Id] group_id id of the Tag group
           # @yieldparam [Oligo] oligo Object created or loaded
           # @yieldparam [Fixnum] position the index of Oligo in the TagGroup.
           def load_oligos(group_id, &block)
             dataset.join(Oligo::dataset(@session), :id => :oligo_id).filter(:tag_group_id => group_id).order(:position).each do |att|
               position = att.delete(:position)
               oligo_id = att.delete(:oligo_id)
               att.delete(:group_id)
               oligo = @session.oligo.get_or_create_single_model(oligo_id, att)
               block.call(oligo, position) if block
             end
           end
         end
      end
    end
  end
end
__END_OF_tag_group.rb__
filename='lib/lims-core/persistence/sequel/tube.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_tube.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2 spell:spelllang=en

require 'lims/core/persistence/tube'
require 'lims/core/persistence/sequel/persistor'

module Lims::Core
  module Laboratory
    module Sequel
      # Not a tube but a tube persistor.
      class Tube < Persistence::Tube
        include Sequel::Persistor

        class TubeAliquot < Persistence::Tube::TubeAliquot
          include Sequel::Persistor

          # Do a bulk load of aliquot and pass each to a block
          # @param tube_id the id of the tube to load.
          # @yieldparam [Integer] position
          # @yieldparam [Aliquot] aliquot
          def load_aliquots(tube_id)
            dataset.join(Aliquot::dataset(@session), :id => :aliquot_id).filter(:tube_id => tube_id).each do |att|
              att.delete(:id)
              aliquot  = @session.aliquot.get_or_create_single_model(att[:aliquot_id], att)
              yield(aliquot)
            end
          end

          def save_raw_association(tube_id, aliquot_id)
              dataset.insert(:tube_id => tube_id, :aliquot_id  => aliquot_id)
          end
        end

        # Delete all children of the given tube
        # But don't destroy the 'external' elements (example aliquots)
        # @param [Fixnum] id the id in the database
        # @param [Laboratory::Tube] tube
        def delete_children(id, tube)
          TubeAliquot::dataset(@session).filter(:tube_id => id).delete
        end

      end
    end
  end
end
__END_OF_tube.rb__
filename='lib/lims-core/persistence/sequel/tube_rack.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_tube_rack.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2 spell:spelllang=en

require 'lims/core/persistence/tube_rack'
require 'lims/core/persistence/sequel/persistor'

module Lims::Core
  module Laboratory
    module Sequel
      # Not a tube_rack but a tube_rack persistor.
      class TubeRack < Persistence::TubeRack
        include Sequel::Persistor

      # Not a well but a well {Persistor}.
        class Slot < Persistence::TubeRack::Slot
          include Sequel::Persistor
          def self.table_name
            :tube_rack_slots
          end

          def save_raw_association(tube_rack_id, tube_id, position)
              dataset.insert(:tube_rack_id => tube_rack_id,
                             :position => position,
                             :tube_id  => tube_id)
          end

          # Do a bulk load of aliquot and pass each to a block
          # @param tube_rack_id the id of the tube_rack to load.
          # @yieldparam [Integer] position
          # @yieldparam [Aliquot] aliquot
          def load_tubes(tube_rack_id)
            dataset.join(Tube::dataset(@session), :id => :tube_id).filter(:tube_rack_id => tube_rack_id).each do |att|
              position = att.delete(:position)
              att.delete(:id)
              tube  = @session.tube.get_or_create_single_model(att[:tube_id], att)
              yield(position, tube)
            end
          end
        end #class Well

        def self.table_name
          :tube_racks
        end

        # Delete the tube, rack association, but doesn't delete the tube.
        def delete_children(id, tube_rack)
          Slot.dataset(@session).filter(:tube_rack_id => id).delete
        end
      end
    end
  end
end
__END_OF_tube_rack.rb__
filename='lib/lims-core/persistence/sequel.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_sequel.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2 spell:spelllang=en
# please keep 2 empty lines to avoid to comment to be
# seen as Persistence doc.
require 'common'

module Lims::Core::Persistence
  # Persistence module using the {http://sequel.rubyforge.org/ sequel} gem.
  # It implements abstract/base classes : {Store}, {Session} etc.
  module Sequel
  end
end

# require everything
require 'lims-core/persistence/sequel/store'
__END_OF_sequel.rb__
filename='lib/lims-core/persistence/session.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_session.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2

require 'common'
require 'forwardable'

require 'lims/core/persistence/filter'

module Lims::Core
    module  Laboratory
      # A session is in charge of restoring and saving object throug the persistence layer.
      # A Session can not normally be created by the end user. It has to be in a Store::with_session
      # block, which acts has a transaction and save/update everything at the end of it.
      # It should also provides an identity map.
      # Session information (user, time) are also associated to the modifications of those objects.
      class Session

        UnmanagedObjectError = Class.new(RuntimeError)

        extend Forwardable
        # param [Store] store the underlying store.
        def initialize(store, *params)
          @store = store
          @objects = Set.new
          @to_delete = Set.new
          @in_session = false
          @saved = Set.new
          @persistor_map = {}
        end

        def_delegators :@store, :database

        # Execute a block and save every 'marked' object
        # in a transaction at the end.
        # @yieldparam [Session] session the created session.
        # @return the value of the block
        def with_session(*params, &block)
          @in_session = true
          to_return = block[self]
          @in_session = false
          save_all
          return to_return
        ensure
          @in_session = false
        end


        # Tell the session to be responsible of an object.
        # The object will be saved at the end of the session.
        # @example
        #   store.with_session do |session|
        #     session << Plate.new
        #   end
        # @param [Persistable] object the object to persist.
        # @return  the session, to allow for chaining
        def << (object)
          @objects << object
          self
        end

        # save the object in real.
        # To mark an object as 'to save' use the \`<<\` method
        # Note we can't make this method private because, the persistor
        # need it to save their children. To solve this, we raise an exception if it's inside a sess
        # @return [Boolean]
        def save(object, *options)
          raise RuntimeError, "Can't save object inside a session. Please considere the << method." unless @save_in_progress
          return id_for(object) if @saved.include?(object)
          @saved << object

          persistor_for(object).save(object, *options)
        end

        def method_missing(name, *args, &block)
          begin
            persistor_for(name)
          rescue NameError
            super(name, *args, &block)         
          end 
        end

        # Called by Persistor to inform the session
        # about the loading of an object.
        # MUST be called by persistors creating Resources.
        def on_object_load(object)
          self << object
        end

        # Returns the id of an object if exists.
        # @param [Resource, Id] object or id.
        # @return [Id, nil]
        def id_for(object)
          case object
          when Resource then persistor_for(object).id_for(object)
          else object # the object should be already an id
          end
        end

        # Returns the id of an object and save it if necessary
        # @param [Resource, Id] object or id.
        # @return [Id]
        def id_for!(object)
          return nil unless object
          id_for(object) || save(object)
        end

        # Check if the session 'mananage' already this object.
        # .i.e if it's been loaded or meant to be saved
        # @param [Resource] object
        # @return [Boolean]
        def managed?(object)
          @objects.include?(object)
        end

        # Mark an object as to be deleted.
        # The corresponding object will be deleted at the end of the session.
        # For most object you don't need to load it to delete it
        # but some needs (to delete the appropriate children).
        # The real delete is made by calling the {#delete_in_real} method.
        def delete(object)
          raise UnmanagedObjectError, "can't delete #{object.inspect}" unless managed?(object)
          @to_delete << object
        end

        # Pack if needed an uuid to its store representation
        # This method is need to lookup an uuid by name
        # @param [String] uuid
        # @return [Object]
        def self.pack_uuid(uuid)
          uuid
        end

        def pack_uuid(uuid)
          self.class.pack_uuid(uuid)
        end

        # Unpac if needed an uuid from its store representation
        # @param [Object] puuid
        # @return [String]
        def self.unpack_uuid(puuid)
          puuid
        end

        def unpack_uuid(uuid)
          self.class.unpack_uuid(uuid)
        end

        private
        # save all objects which needs to be
        def save_all()
          @store.transaction do
            @save_in_progress = true # allows saving
            @objects.each do |object|
              if @to_delete.include?(object)
                delete_in_real(object)
              else
                save(object)
              end
            end
            @save_in_progress = false
          end
        end

        # Call to 
        def delete_in_real(object, *options)
          raise RuntimeError, "Can't delete an object inside a session. Please considere the 'delete' method instead." unless @save_in_progress
          return id_for(object) if @saved.include?(object)
          @saved << object

          persistor_for(object).delete(object, *options)
        end

        # Create a new persistor sharing the same internal parameters
        # but with the "context" (datasest) of the new one.
        # This can be used to "reset" a filtered persistor to the current session.
        # @param [Persistor] persistor
        # @return [Persistor]
        def filter_persistor(persistor)
          # If the persistor session is the current session, there is nothing to do
          # just return the object as it is.
          return persistor if  persistor.instance_eval {@session} == self

          # we need first to find the original persistor, ie the one  that the user can call via
          # session.model
          original = persistor_for(persistor.class)
          persistor.class.new(original, persistor.dataset)
        end

        # Find the first persistor of the specified class.
        # Optimize if needed.
        # @param [Class]
        # @return [Persistor]
        def persistor_for_persistor_class(klass)
          @persistor_map.each do |name, persistor|
            return persistor if persistor.is_a?(klass)
          end
        end




        # Get the persistor corresponding to the object class
        # @param [Resource, String, Symbol, Persistor] object
        # @return [Persistor, nil]
        def persistor_for(object)
          if object.is_a?(Persistor)
            return filter_persistor(object)
          end
          name = persistor_name_for(object)
          @persistor_map[name]  ||= begin 
          persistor_class = @store.base_module.constant(name)
          raise NameError, "Persistor #{name} not defined for #{@store.base_module.name}" unless persistor_class &&  persistor_class.ancestors.include?(Persistor)
          persistor_class.new(self)
        end

      end

      public :persistor_for
      # Compute the class name of the persistor corresponding to the argument
      # @param [Resource, String, Symbol] object
      # @return [String]
      def  persistor_name_for(object)
        case object
        when String then object
        when Symbol then object.to_s
        when Class,Module
          if object.respond_to?(:base_class)
            return persistor_name_for(object.base_class)
          else
            object.name.sub(/^Lims::Core::(Persistence::)?\\w+::/, '')
          end
        else persistor_name_for(object.class)
        end.upper_camelcase
      end

    end
  end
end

__END_OF_session.rb__
filename='lib/lims-core/laboratory/spin_column/spin_column_persistor.rb
mkdir -p $(dirname $filename)
cat <<__END_OF_spin_column.rb__ > $filename
require 'lims/core/persistence/persistor'
require 'lims/core/laboratory/spin_column'

module Lims::Core
  module Laboratory

    # Base for all Spin Column persistor.
    # Real implementation classes (e.g. Sequel::SpinColumn) should
    # include the suitable persistor.
    class SpinColumn::SpinColumnPersistor < Persistor
      Model = Laboratory::SpinColumn

      # Save all children of the given spin column
      # @param  id object identifier
      # @param [Laboratory::SpinColumn] spin column
      # @return [Boolean]
      def save_children(id, spin_column)
        # we use values here, so position is a number
        spin_column.each do |aliquot|
          spin_column_aliquot.save_as_aggregation(id, aliquot)
        end
      end

      def  spin_column_aliquot
        @session.send("SpinColumn::SpinColumnAliquot")
      end

      class SpinColumn::SpinColumnPersistorAliquot < Persistor
      end

      # Load all children of the given spin column
      # Loaded object are automatically added to the session.
      # @param  id object identifier
      # @param [Laboratory::SpinColumn] spin column
      # @return [Laboratory::SpinColumn, nil] 
      #
      def load_children(id, spin_column)
        spin_column_aliquot.load_aliquots(id) do |aliquot|
          spin_column << aliquot
        end
      end
    end
  end
end
__END_OF_spin_column.rb__
filename='lib/lims-core/persistence/store.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_store.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2 spell:spelllang=en
require 'common'

require 'lims/core/persistence'
require 'lims/core/persistence/session'

module Lims::Core
    module  Laboratory
      # A store represents a persistent datastore, where object can be saved and restored.
      # A connection to a database, for example.
      class Store
        def self.const_missing(name)
          super(name)
        end

        # Retrieves the effective module of a class
        # Useful to call "sibling" classes.
        # @example
        #   class Sequel::Store < Store
        #     def session
        #        base_module::Session
        #   end
        #
        #   session will return a Sequel::Session instead of a ::Session.
        #
        # @return [Module]
        def self.base_module
          @base_module ||= begin
                            base_name = name.sub(/::\\w+\$/, '')
                            constant(base_name)
                          end
        end
        def base_module
          self.class.base_module
        end

        # Create a session and pass it to the block.
        # This is the only way to get a session.
        # @param [Array]
        # @yieldparam [Session] session the created session.
        # @return the value of the block
        def with_session(*params, &block)
          create_session(*params).with_session(&block)
        end


        # Create a session
        def create_session(*params)
          base_module::Session.new(self, *params)
        end

        # Execute given block within a transaction
        # If it make sense.
        def transaction
          yield
        end
      end
    end
end

__END_OF_store.rb__
filename='lib/lims-core/organization/study/study_persistor.rb
mkdir -p $(dirname $filename)
cat <<__END_OF_study.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2 spell:spelllang=en

require 'lims/core/persistence/persistor'
require 'lims/core/organization/study'

module Lims::Core
  module Organization
    # Base for all Study persistors.
    class Study::StudyPersistor < Persistor
      Model = Organization::Study
    end
  end
end
__END_OF_study.rb__
filename='lib/lims-core/laboratory/tag_group/tag_group_persistor.rb
mkdir -p $(dirname $filename)
cat <<__END_OF_tag_group.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2 spell:spelllang=en


require 'lims/core/persistence/persistor'
require 'lims/core/laboratory/tag_group'

module Lims::Core
  module Laboratory

    # Base for all Plate persistor.
    # Real implementation classes (e.g. Sequel::Plate) should
    # include the suitable persistor.
    class TagGroup::TagGroupPersistor < Persistor
      Model = Laboratory::TagGroup

      # Save all children of the given group
      # @param  id object identifier
      # @param [Laboratory::TagGroup] group
      # @return [Boolean]
      def save_children(id, group)
        group.each_with_index do |oligo, position|
          next unless oligo
          save_as_aggregation(id, oligo, position)
        end
      end

      # Load all children of the given group
      # Loaded object are automatically added to the session.
      # @param  id object identifier
      # @param [Laboratory::Plate] group
      # @return [Laboratory::Plate, nil] 
      #
      def load_children(id, group)
        association.load_oligos(id) do |oligo, position|
          group << nil while (group.size <= position)
          group[position] = oligo
        end
      end


      def association
        @session.send("TagGroup::Association")
      end

      # This class doesn't exist in the model
      # but is there to modelize the association.
      # It probably correspond to one table on the database.
      class Association < Persistor
      end
    end
  end
end
__END_OF_tag_group.rb__
filename='lib/lims-core/laboratory/tube/tube_persistor.rb
mkdir -p $(dirname $filename)
cat <<__END_OF_tube.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2 spell:spelllang=en


require 'lims/core/persistence/persistor'
require 'lims/core/laboratory/tube'

module Lims::Core
  module Laboratory

    # Base for all Tube persistor.
    # Real implementation classes (e.g. Sequel::Tube) should
    # include the suitable persistor.
    class Tube::TubePersistor < Persistor
      Model = Laboratory::Tube

      # Save all children of the given tube
      # @param  id object identifier
      # @param [Laboratory::Tube] tube
      # @return [Boolean]
      def save_children(id, tube)
        # we use values here, so position is a number
        tube.each do |aliquot|
          tube_aliquot.save_as_aggregation(id, aliquot)
        end
      end

      def  tube_aliquot
        @session.send("Tube::TubeAliquot")
      end

      class Tube::TubePersistorAliquot < Persistor
      end

      # Load all children of the given tube
      # Loaded object are automatically added to the session.
      # @param  id object identifier
      # @param [Laboratory::Tube] tube
      # @return [Laboratory::Tube, nil] 
      #
      def load_children(id, tube)
        tube_aliquot.load_aliquots(id) do |aliquot|
          tube << aliquot
        end
      end
    end
  end
end
__END_OF_tube.rb__
filename='lib/lims-core/laboratory/tube/tube_rack_persistor.rb
mkdir -p $(dirname $filename)
cat <<__END_OF_tube_rack.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2 spell:spelllang=en


require 'lims/core/persistence/persistor'
require 'lims/core/laboratory/tube_rack'

module Lims::Core
  module Laboratory

    # Base for all TubeRack persistor.
    # Real implementation classes (e.g. Sequel::TubeRack) should
    # include the suitable persistor.
    class Tube::TubeRackPersistor < Persistor
      Model = Laboratory::TubeRack

      # Save all children of the given tube_rack
      # @param  id object identifier
      # @param [Laboratory::TubeRack] tube_rack
      # @return [Boolean]
      def save_children(id, tube_rack)
        # we use values here, so position is a number
        tube_rack.values.each_with_index do |tube, position|
          next if nil
          slot.save_as_association(id, tube, position)
        end
      end

      # Load all children of the given tube_rack
      # Loaded object are automatically added to the session.
      # @param  id object identifier
      # @param [Laboratory::TubeRack] tube_rack
      # @return [Laboratory::TubeRack, nil] 
      #
      def load_children(id, tube_rack)
        slot.load_tubes(id) do |position, tube|
          tube_rack[position]= tube
        end
      end

      def slot
        @session.send("TubeRack::Slot")
      end

      class Slot < Persistor
      end
    end
  end
end
__END_OF_tube_rack.rb__
filename='lib/lims-core/organization/user/user_persistor.rb
mkdir -p $(dirname $filename)
cat <<__END_OF_user.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2 spell:spelllang=en

require 'lims/core/persistence/persistor'
require 'lims/core/organization/user'

module Lims::Core
  module Organization
    # Base for all User persistors.
    class User::UserPersistor < Persistor
      Model = Organization::User
    end
  end
end
__END_OF_user.rb__
filename='lib/lims-core/uuids/uuid_resource/uuid_resource_persistor.rb
mkdir -p $(dirname $filename)
cat <<__END_OF_uuid_resource.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2 spell:spelllang=en
require 'common'

require 'lims/core/persistence/persistor'
require 'lims/core/uuids/uuid_resource'

module Lims::Core
  module  Uuids
    class UuidResource::UuidResourcePersistor < Persistor
      Model = Uuids::UuidResource

      def filter_attributes_on_save(attributes)
        attributes.mash do |k,v|
          case k
          when :model_class then   [ k, @session.model_name_for(v) ]
          when :uuid then [ k, @session.pack_uuid(v) ]
          else [k, v]
          end
        end
      end

      def filter_attributes_on_load(attributes)
        attributes.mash do |k,v|
          case k
          when :model_class then [ k, @session.class_for(v) ]
          when :uuid then [ k, @session.unpack_uuid(v) ]
          else [k, v]
          end
        end
      end
    end
  end
end

__END_OF_uuid_resource.rb__
filename='lib/lims-core/persistence/uuidable.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_uuidable.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2 spell:spelllang=en

require 'sequel'
require 'lims/core/persistence'

module Lims::Core
  module Uuids
    # Add uuid behavior (lookup and creation) to a Session
    module Uuidable
      # lookup one or more objects  by uuid or resource_uuid
      # @param [String, Arrary<String>, UUidResource] args 
      # @return [Resource, nil, Array<Resource>]
      def [](args)
        case args
        when Uuids::UuidResource then for_uuid_resource(args)
        when String then for_uuid(args)
        when Array then for_uuids(args)
        else
          super(args)
        end
      end

      # Retrieve  id from an object or a Hash with a uuid key
      # A list of uuids will 
      def id_for(object)
        case object
        when Array
          object.map { |o| id_for(o) }
        when Hash
          id_for(object[:uuid] || object["uuid"])
        when String 
          # We assume it is an uuid
          self.uuid_resource[:uuid => pack_uuid(object)].andtap {  |ur| ur.key }
        else
          super
        end
      end
      # Compute the name (string) used to be saved in the Uuid table.
      # @param [Class] model_class class of the resource
      # @return [String]
      def model_name_for(model_class)
        persistor_name_for(model_class)
      end

      # Get the class from the class name. Inverse of {#model_name_for}.
      def class_for(model_name)
        persistor_for(model_name).model
      end

      def new_uuid_resource_for(object)
        object_id =  id_for(object)
        key  = object_id ? object_id : lambda { self.id_for(object) }
        Uuids::UuidResource.new(:key => key, :model_class => object.class).tap do |r|
          self << r
        end
      end

      def uuid_resource_for(object)
        self.uuid_resource[:key => id_for(object), :model_class => model_name_for(object.class)]
      end

      # Finds the uuid of an object if it exists
      def uuid_for(object)
        # We need to check if the object is managed and have alreday an id
        raise RuntimeError, "Unmanaged object" unless managed?(object)
        id_for(object) && uuid_resource_for(object).andtap { |r|  r.uuid }
      end


      # Find or create a uuid for an object
      def uuid_for!(object)
        uuid_for(object) || new_uuid_resource_for(object).uuid
      end

      # Delete the underlying resource of a UuidResource
      # @param [UuidResource] uuid_resource
      # @return [Id, nil] 
      def delete_resource(uuid_resource)
        delete(for_uuid_resource(uuid_resource))
        uuid_resource.key
      end


      protected
      # find/load the object referenced by a uuid resource.
      # Don't need to be called explicitely. use session[resource_uuid] instead
      # @param [UuidResource] uuid_resource
      # @return [Resource]
      def for_uuid_resource(uuid_resource)
          persistor_for(uuid_resource.model_class)[uuid_resource.key]
      end

      def for_uuid(uuid)
        self.uuid_resource[:uuid => uuid].andtap do |r|
          for_uuid_resource(r)
        end
      end

      # @todo bulk load
      def for_uuids(uuids)
        uuids.map { |u| for_uuid(u) }.compact
      end
    end
  end
end
__END_OF_uuidable.rb__
filename='lib/lims-core/persistence.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_persistence.rb__ > $filename
#vi: ts=2 sw=2 et
require 'common'
require 'facets/string'


module Lims::Core
  # Generic persistence layer.
  # The main objects are {Persistence::Session Session} which
  # is in charge of saving and restoring object and {Persistence::Store} via Persistors.
  # Persistors are mixins specific to each persistence types.
  # For example, see the {Sequel::Persistor}.
  module Uuids

    # Creates all the missing for a submodule.
    # Needs to be called  once for each submodule
    # if NO_AUTOLOAD is specified and no path are provided
    # We skip it. Thif function needs to be called with an explicit path
    # (which could be [] everything has already been preloaded)
    # @param [Module] mod module to finalize
    # @paths [Array<String>]  paths where the persistor to finalize are defined
    def self.finalize_submodule(mod, paths=nil)
      return if defined?(NO_AUTOLOAD) && !paths
      paths ||= ["#{mod.name.pathize.sub('lims/core/',"")}/*"]
      paths.map { |path| require_all(path) }
      generate_missing_classes(self, mod, mod::Persistor)

    end

    # Generate all the 'missing' persistors (.i.e. those
    # existing in the main Persistence module but which 
    # haven't been subclassed.
    # @param mod the module to add class into.
    def self.generate_missing_classes(base, mod, persistor)
      (base.constants(false)-mod.constants(false)).map { |c| base.const_get(c) }.each do |klass|
        case
        when klass.is_a?(Class) == false then next
        when klass == Persistor then next
        when klass.ancestors.include?(Persistor) 
          generate_persistor(klass, mod, persistor)
        end
      end
    end

    # Generate a persistor inheriting from  klass
    #  and extended with the 'local' persistor.
    def self.generate_persistor(klass, mod, persistor)
      class_name = klass.name.split("::").last
      generated_class = mod.class_eval %Q{
      class #{class_name} < ::#{klass.name}
        include ::#{persistor.name}
      end
    }

      # generate nested classes, ex Plate::Well
        generate_missing_classes(klass, generated_class, persistor)
    end
  end
end

require 'lims/core/persistence/store'
require 'lims/core/persistence/persistor'
require 'lims/core/persistence/uuid_resource'
require 'lims/core/persistence/session'
require 'lims/core/persistence/search'
require 'lims/core/persistence/message_bus'

unless  defined?(Lims::Core::NO_AUTOLOAD)
  require 'lims/core/laboratory//aliquot'
  require 'lims/core/laboratory//sample'
  require 'lims/core/laboratory//flowcell'
  require 'lims/core/laboratory//oligo'
  require 'lims/core/laboratory//plate'
  require 'lims/core/laboratory//labellable'
  require 'lims/core/organization//order'
  require 'lims/core/organization//user'
  require 'lims/core/organization//study'
  require 'lims/core/laboratory//tag_group'
  require 'lims/core/laboratory//tube'
  require 'lims/core/laboratory//spin_column'
end
__END_OF_persistence.rb__
filename='lib/lims-core/resource.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_resource.rb__ > $filename
# vi: ts=2 sts=2 et sw=2 spell spelllang=en  
require 'common'
require 'lims-core/base'

module Lims::Core
  module Resource
    def self.included(klass)
      klass.class_eval do
        include Base
      end
    end
  end
end

__END_OF_resource.rb__
filename='lib/lims-core/uuids/uuid_resource.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_uuid_resource.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2 spell:spelllang=en
require 'common'
require 'uuid'

require 'lims/core/resource'

module Lims::Core
    module Uuids
      # Bind a uuid (as a String) to a Resource (a key and a model)
      # The key is a FixNum to find the corresponding resource in the store
      # and the model is the real class of the object (or at least something allowing to find it)
      class UuidResource::UuidResourcePersistor
        include Resource
        attribute :key, Fixnum, :writer => :private, :initializable => true
        attribute :model_class, Class, :writer => :private, :initializable => true
        attribute :uuid, String, :writer => :private, :initializable => true

        class InvalidUuidError < RuntimeError
        end

        Generator = UUID.new
        Form = [8, 4, 4, 4, 12]
        Length = Form.inject { |m, n| m+n }
        ValidationRegexp = /#{Form.map { |n| "[0-9a-f]{#{n}}" }.join('-')}/i
        SplitRegexp = /#{Form.map { |n| "([0-9a-f]{#{n}})"}.join('')}/


          def key
            # Hack to get the id after the object being save
            @key.is_a?(Proc) ? @key.call : @key
          end
        def self.valid?(uuid)
          !!(uuid =~ ValidationRegexp)
        end

        def self.generate_uuid()
          Generator.generate
        end

        # Pack a string representation of an uuid to a char(16)
        def self.pack(to_pack)
          [compact(to_pack)].pack("H*")
        end

        def self.unpack(packed)
          expand(packed.unpack("H*").first)
        end

        # Convert the string representation of an Uuid to a bignum
        # @param [String] s
        # @return [Bignum]
        def self.string_to_bignum(s)
          compact(s).to_i(16)
        end

        # Convert a bignum to a string representation 
        # @param [Bignum] b
        # @return [String]
        def self.bignum_to_string(b)
          l = Form.inject { |m, n| m+n }
          expand("%0.*x" % [l,b])
        end

        def self.expand(s)
          match = SplitRegexp.match(s)
          raise InvalidUuidError.new(s) unless match
          match.captures.join('-')
        end

        def self.compact(s)
          s.tr('-', '')
        end

        def build_resource(attributes)
          model_class.new(attributes)
        end
        protected :build_resource

        def uuid
          @uuid ||= UuidResource.generate_uuid
        end
      end
    end
end

__END_OF_uuid_resource.rb__
filename='lib/lims-core/version.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_version.rb__ > $filename
module Lims
  module Core
    # Test a way to increment version in a merged-friendly way
    # Each user need to add an x, in its appropriate section (this will
    # avoid collision)
    # and clear eventually the minor version of everybody .
    # Please leave the marker of other developper
    #
    MINOR_DEV = %{
    --llh1
    --ke4
    x
    --mb14

  }
    MAJOR_DEV = %{
    --llh1
    --ke4
    --mb14

}


    VERSION = "1.4.0.#{MAJOR_DEV.scan(/\\sx/i).size}.#{MINOR_DEV.scan(/\\sx/i).size}"
  end
end
__END_OF_version.rb__
filename='lib/lims-core.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_lims-core.rb__ > $filename
# vi: spell:spelllang=en ts=2:sts=2:sw=2:et
require "lims-core/version"

require 'lims/core/actions'
require 'lims/core/laboratory'
require 'lims/core/organization'
 require 'lims/core/persistence'
# Persistence submodules need to be required manually. This is to avoid
# having to require and install all the store dependency (mysql, postgres) etc ...


# LIMS stands for Laboratory Information Management System.
# A namespace.
module Lims
  # The Core of the {Lims LIM S}ystem.
  # Includes the basic classes corresponding to the :  
  # 1. domain(s)
  # 2. Persistence Layer
  # 3. Business Logic layer (extension ?)
  #
  # The Core is split in the following submodule/namespace :
  # 1. {Laboratory} :
  #    Things used/found in the lab. Includes pure laboratory (inert things as {Laboratory::Plate plates}, {Laboratory::Tube tubes})
  #    and chemical one (as {Laboratory::Aliquot aliquots}, {Laboratory::Sample samples}).
  # 3. {LabProcess}
  #    Related to the work people/robot do in the laboratories.
  # 5. {Organization}
  #    Related to {Organization::User users}, data release ({Organization::Study studies}) and ordering ({Organization::Order orders}) and funding ({Organization::Project projects}) etc.
  # 10. {Actions}
  #     High level {Actions::Action actions} that can be performed on things (mostly laboratory).
  #   
  # 12. {Persistence}
  #
  #
  # This partition is more for clarity/documentation purposes and it's not meant to be really tight. 
  # However it's more likely than the submodules dependency will be a tree than a graph, (but it's not a necessity).   
  module Core
    # Your code goes here...
  end
end
__END_OF_lims-core.rb__
filename='spec/actions/action_examples.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_action_examples.rb__ > $filename
require 'actions/spec_helper'

shared_examples "an action" do
  context "to be valid" do
    its(:user) { should_not be_nil }
    its(:application) { should_not be_nil }
    its(:application) { should_not be_empty }
    its(:store) { should_not be_nil }

    it { should respond_to(:call) }
    it { should respond_to(:revert) }

    xit { subject.valid?.should be_true }
  end

  context "well implemented" do
  end
end

shared_context "for application" do |application_string|
        let(:user) { mock(:user) }
        let(:application) { application_string}
end
__END_OF_action_examples.rb__
filename='spec/actions/actions_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_actions_spec.rb__ > $filename
# Spec requirements
require 'actions/spec_helper'

#model requirements
__END_OF_actions_spec.rb__
filename='spec/actions/create_batch_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_create_batch_spec.rb__ > $filename
# Spec requirements
require 'actions/spec_helper'
require 'actions/action_examples'

#Model requirements
require 'lims/core/actions/create_batch'
require 'lims/core/persistence/store'

module Lims::Core
  module Actions
    describe CreateBatch do
      context "with a valid store" do
        include_context "create object"
        let (:store) { Persistence::Store.new }
        let(:user) { mock(:user) }
        let(:application) { "Test create batch" }
        let(:process) { mock(:process) }

        context "create a batch" do
          subject do
            described_class.new(:store => store, :user => user, :application => application)  do |a,s|
              a.process = process
            end
          end 

          it_behaves_like "an action"

          it "create a batch when called" do
            Persistence::Session.any_instance.should_receive(:save)
            result = subject.call
            result.should be_a(Hash)
            result[:batch].should be_a(Organization::Batch)
            result[:batch][:process].should == process
            result[:uuid].should == uuid
          end
        end
      end
    end
  end
end
__END_OF_create_batch_spec.rb__
filename='spec/actions/create_flowcell_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_create_flowcell_spec.rb__ > $filename
# Spec requirements
require 'actions/spec_helper'
require 'actions/action_examples'

require 'laboratory/flowcell_shared'

#Model requirement
require 'lims/core/actions/create_flowcell'

module Lims::Core
  module Actions

    shared_context "for empty flowcell" do
      subject do
        CreateFlowcell.new(:store => store, :user => user, :application => application) do |action,session|
          action.ostruct_update(number_of_lanes_hash)
        end
      end

      let (:flowcell_checker) do
        lambda do |flowcell|
          flowcell.each { |lane| lane.should be_empty }
        end
      end
    end
    
    shared_examples_for "creating a flowcell" do
      include_context "create object"
      it_behaves_like "an action"
      it "creates a flowcell when called" do
        result = subject.call()
        result.should be_a Hash

        flowcell = result[:flowcell]
        flowcell.number_of_lanes.should == number_of_lanes_hash[:number_of_lanes]
        flowcell_checker[flowcell]

        result[:uuid].should == uuid
      end
    end

    shared_context "for flowcell with a map of samples" do
      let(:lanes_description) do
        {}.tap do |lane|
          1.upto(number_of_lanes_hash[:number_of_lanes]) do |lane_number|
            lane[lane_number.to_s] = [{
              :sample => new_sample(lane_number),
              :quantity => nil
            }]
          end
        end
      end
      subject do
        CreateFlowcell.new(:store => store, :user => user, :application => application)  do |action,session|
          action.ostruct_update(number_of_lanes_hash)
          action.lanes_description = lanes_description
        end
      end

      let (:flowcell_checker) do
        lambda do |flowcell|
          lanes_description.each do |lane_name, expected_aliquots|
            aliquots = flowcell[lane_name.to_i-1]
            aliquots.size.should == 1
            aliquots.first.sample.should == expected_aliquots.first[:sample]
          end
        end
      end
    end

    shared_context "has number of lane" do |nb_of_lanes|
      let(:number_of_lanes_hash) { { :number_of_lanes => nb_of_lanes } }
    end
    
    shared_context "miseq flowcell" do
      include_context("has number of lane", 1)
    end
    
    shared_context "hiseq flowcell" do
      include_context("has number of lane", 8)
    end
    
    describe CreateFlowcell do
      context "valid calling context" do
        let!(:store) { Persistence::Store.new() }
        include_context "flowcell factory"
        include_context("for application",  "Test flowcell creation")
        
        # testing flowcell creation with miseq flowcell
        context do
          include_context "miseq flowcell"

          context do
            include_context "for empty flowcell"
            it_behaves_like('creating a flowcell')
          end
          context do
            include_context "for flowcell with a map of samples"
            it_behaves_like('creating a flowcell')
          end
        end
        
        # testing flowcell creation with hiseq flowcell
        context do
          include_context "hiseq flowcell"

          context do
            include_context "for empty flowcell"
            it_behaves_like('creating a flowcell')
          end
          context do
            include_context "for flowcell with a map of samples"
            it_behaves_like('creating a flowcell')
          end
        end
      end
    end
  end
end

__END_OF_create_flowcell_spec.rb__
filename='spec/actions/create_gel_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_create_gel_spec.rb__ > $filename
# Spec requirements
require 'actions/spec_helper'
require 'actions/action_examples'

require 'laboratory/plate_and_gel_shared'

#Model requirements
require 'lims/core/actions/create_gel'

module Lims::Core
  module Actions
    shared_context "for empty gel" do
      subject do
        CreateGel.new(:store => store, :user => user, :application => application)  do |a,s|
          a.ostruct_update(dimensions)
        end
      end

      let (:gel_checker) do
        lambda do |gel|
          gel.each  { |w| w.should be_empty }
        end
      end
    end
    shared_context "for gel with a map of samples" do
      let(:windows_description) do
        {}.tap do |h|
          1.upto(number_of_rows) do |row|
            1.upto(number_of_columns) do |column|
              h[Laboratory::Gel.indexes_to_element_name(row-1, column-1)] = [{
                :sample => new_sample(row, column),
                :quantity => nil
              }]
            end
          end
        end
      end
      subject do
        CreateGel.new(:store => store, :user => user, :application => application)  do |a,s|
          a.ostruct_update(dimensions)
          a.windows_description = windows_description
        end
      end

      let (:gel_checker) do
        lambda do |gel|
          windows_description.each do |window_name, expected_aliquots|
            aliquots = gel[window_name]
            aliquots.size.should == 1
            aliquots.first.sample.should == expected_aliquots.first[:sample]
          end
        end
      end
    end

    shared_examples_for "creating a gel" do
      include_context "create object"
      it_behaves_like "an action"
      it "creates a gel when called" do
        result = subject.call()
        result.should be_a Hash

        gel = result[:gel]
        gel.number_of_rows.should == dimensions[:number_of_rows]
        gel.number_of_columns.should == dimensions[:number_of_columns]
        gel_checker[gel]

        result[:uuid].should == uuid
      end
    end

    shared_context "has gel dimension" do |row, col|
      let(:number_of_rows) { row }
      let(:number_of_columns) { col }
      let(:dimensions) {{ :number_of_rows => row, :number_of_columns => col }}
    end

    describe CreateGel do
      context "valid calling context" do
        let!(:store) { Persistence::Store.new() }
        include_context "plate or gel factory"
        include_context("for application",  "Test gel creation")

        include_context("has gel dimension", 8, 12)

        context do
          include_context "for empty gel"
          it_behaves_like('creating a gel')
        end
        context do
          include_context "for gel with a map of samples"
          it_behaves_like('creating a gel')
        end
      end
    end
  end
end
__END_OF_create_gel_spec.rb__
filename='spec/actions/create_label_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_create_label_spec.rb__ > $filename
# Spec requirements
require 'actions/action_examples'
require 'actions/spec_helper'
require 'persistence/sequel/store_shared'

# Model requirements
require 'lims/core/actions/create_labellable'
require 'lims/core/actions/create_label'

module Lims::Core
  module Actions

    shared_context "setup required attributes for label" do
      let(:location) { "00000000-1111-2222-3333-444444444444" } # uuid of an asset (i.e. plate)
      let(:label_position) { "front barcode" }
      let(:label_type) { "sanger-barcode" }
      let(:label_value) { "1234-ABC" }
      let(:labellable) {
        Laboratory::Labellable.new({:name => location, :type => "resource"})
      }
    end

    shared_context "for Laballable with label content(s)" do
      let(:created_label) {
        CreateLabel.new(:store => store, :user => user, :application => application)  do |action, session|
          action.labellable = labellable
          action.type = label_type
          action.value = label_value
          action.position = label_position
        end
      }
    end

    shared_examples_for "a label" do
      subject { result }
      it { should be_a(Lims::Core::Laboratory::Labellable) }

      its(:positions) { should_not be_empty }
      its(:positions) { should be_a(Array) }
      its(:labels) { should_not be_empty }
      its(:labels) { should be_a(Array) }

      its(:positions) { subject[0].should == label_position }
      its(:labels) { subject[0].type.should == label_type }
      its(:labels) { subject[0].value.should == label_value }
    end

    shared_examples_for "a labellable" do
      subject { result }
      its(:name) { should == location }
      its(:name) { should_not be_empty }
      its(:name) { should be_a(String) }
      its(:type) { should_not be_empty }
      its(:type) { should be_a(String) }
    end

    shared_examples_for "a labellable action" do
      subject { created_label }
      it_behaves_like "an action"
    end

    shared_context "creating a Labellable with label(s)" do
      let(:result) { created_label.call() }
    end

    describe CreateLabel do
      context "with a valid store" do
        include_context "sequel store"
        include_context("setup required attributes for label")

        context "valid calling context" do
          include_context("for application", "Test create laballable with label content")

          context do
            include_context("for Laballable with label content(s)")
            include_context("creating a Labellable with label(s)")

            it_behaves_like "a label"
            it_behaves_like "a labellable"
            it_behaves_like "a labellable action"
          end
        end
      end
    end
  end
end
__END_OF_create_label_spec.rb__
filename='spec/actions/create_labellable_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_create_labellable_spec.rb__ > $filename
# Spec requirements
require 'actions/action_examples'
require 'actions/spec_helper'

# Model requirements
require 'lims/core/actions/create_labellable'

module Lims::Core
  module Actions
    shared_context "setup required attributes" do |name, type|
      let(:name) { name }
      let(:type) { type }
      let(:required_parameters) { { :name => name, :type => type } }
    end

    shared_context "for Labellable (without labels)" do
      subject do
        CreateLabellable.new(:store => store, :user => user, :application => application)  do |action, session|
          action.ostruct_update(required_parameters)
        end
      end

      let(:labellable_checker) {
        lambda { |labellable|
          labellable.name.should_not be_empty
          labellable.name.should be_a(String)
          labellable.type.should_not be_empty
          labellable.type.should be_a(String)
        }
      }
    end

    shared_examples_for "creating a Labellable" do
      include_context "create object"
      it_behaves_like "an action"
      it "creates a labellable when called" do
        result = subject.call()
        result.should be_a(Hash)

        labellable = result[:labellable]
        labellable.type.should == type
        labellable.name.should == name

        labellable_checker[labellable]

        result[:uuid].should == uuid
      end
    end

    describe CreateLabellable do
      context "with a valid store" do
        let!(:store) { Persistence::Store.new }
        include_context("setup required attributes", "my test plate", "plate")

        context "to be valid Laballable" do
          subject { Lims::Core::Laboratory::Labellable }
          specify { subject.new(required_parameters).should be_valid }
        end

        context "valid calling context" do
          include_context("for application", "Test create laballable")

          context do
            include_context("for Labellable (without labels)")
            it_behaves_like("creating a Labellable")
          end

        end
      end
    end
  end
end
__END_OF_create_labellable_spec.rb__
filename='spec/actions/create_order_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_create_order_spec.rb__ > $filename
# Spec requirements
require 'actions/spec_helper'
require 'actions/action_examples'

#Model requirements
require 'lims/core/actions/create_order'

module Lims::Core
  module Actions
    describe CreateOrder do
      shared_examples_for "creating an order" do
        include_context "create object"
        it_behaves_like "an action"

        it "creates an order object" do
          Persistence::Session.any_instance.should_receive(:save)
          result = subject.call 
          order = result[:order]
          order.should be_a Organization::Order
          order.creator.should == user
          order.pipeline.should == pipeline
          order.parameters.should == parameters
          order.study.should == study
          order.cost_code.should == cost_code 
          order.should_not respond_to(:items)

          sources.each do |role, uuid| 
            order[role].each do |item|
              item.should_not be_nil
              item.uuid.should == uuid
              item.done?.should == true
            end
          end 

          targets.each do |role, uuid|
            order[role].each do |item|
              item.should_not be_nil
              item.uuid.should == uuid
              item.pending?.should == true
            end
          end
        end
      end

      let!(:store) { Persistence::Store.new() }

      let(:pipeline) { mock(:pipeline) }
      let(:parameters) { mock(:parameters) }
      let(:sources) { {:source_role => mock(:source)} } 
      let(:targets) { {:target_role => mock(:target)} } 
      let(:study) { mock(:study) }
      let(:cost_code) { mock(:cost_code) }

      let(:create_order_parameters) { 
        { :store => mock(:store),
          :user => mock(:user),
          :application => "my application",
          :pipeline => pipeline,
          :parameters => parameters,
          :sources => sources,
          :targets => targets,
          :study => study,
          :cost_code => cost_code }
      }

      context "to be valid" do
        it do
          s = described_class.new(create_order_parameters)
          described_class.new(create_order_parameters).valid?.should == true
        end

        it "requires a cost code" do
          described_class.new(create_order_parameters - [:cost_code]).valid?.should == false
        end  
      end

      context "valid calling context" do
        include_context("for application",  "Test order creation")

        subject {
          CreateOrder.new(:store => store, :user => user, :application => application) do |a,s|
            a.pipeline = pipeline
            a.parameters = parameters
            a.sources = sources
            a.targets = targets
            a.study = study
            a.cost_code = cost_code
          end
        }

        it_behaves_like "creating an order"
      end
    end
  end
end

__END_OF_create_order_spec.rb__
filename='spec/actions/create_plate_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_create_plate_spec.rb__ > $filename
# Spec requirements
require 'actions/spec_helper'
require 'actions/action_examples'

require 'laboratory/plate_and_gel_shared'

#Model requirements
require 'lims/core/actions/create_plate'

module Lims::Core
  module Actions
    shared_context "for empty plate" do
      subject do
        CreatePlate.new(:store => store, :user => user, :application => application)  do |a,s|
          a.ostruct_update(dimensions)
          a.type = plate_type
        end
      end

      let (:plate_checker) do
        lambda do |plate|
          plate.each  { |w| w.should be_empty }
        end
      end
    end
    shared_context "for plate with a map of samples" do
      let(:wells_description) do
        {}.tap do |h|
          1.upto(number_of_rows) do |row|
            1.upto(number_of_columns) do |column|
              h[Laboratory::Plate.indexes_to_element_name(row-1, column-1)] = [{
                :sample => new_sample(row, column),
                :quantity => nil
              }]
            end
          end
        end
      end
      subject do
        CreatePlate.new(:store => store, :user => user, :application => application)  do |a,s|
          a.ostruct_update(dimensions)
          a.wells_description = wells_description
          a.type = plate_type
        end
      end

      let (:plate_checker) do
        lambda do |plate|
          wells_description.each do |well_name, expected_aliquots|
            aliquots = plate[well_name]
            aliquots.size.should == 1
            aliquots.first.sample.should == expected_aliquots.first[:sample]
          end
        end
      end
    end

    shared_examples_for "creating a plate" do
      include_context "create object"
      it_behaves_like "an action"
      it "creates a plate when called" do
        result = subject.call()
        result.should be_a Hash

        plate = result[:plate]
        plate.number_of_rows.should == dimensions[:number_of_rows]
        plate.number_of_columns.should == dimensions[:number_of_columns]
        plate.type.should == plate_type
        plate_checker[plate]

        result[:uuid].should == uuid
      end
    end

    shared_context "has plate dimension" do |row, col|
      let(:number_of_rows) { row }
      let(:number_of_columns) { col }
      let(:dimensions) {{ :number_of_rows => row, :number_of_columns => col }}
    end

    describe CreatePlate do
      context "valid calling context" do
        let!(:store) { Persistence::Store.new() }
        include_context "plate or gel factory"
        include_context("for application",  "Test plate creation")

        include_context("has plate dimension", 8, 12)
        let(:plate_type) { mock(:plate_type) }

        context do
          include_context "for empty plate"
          it_behaves_like('creating a plate')
        end
        context do
          include_context "for plate with a map of samples"
          it_behaves_like('creating a plate')
        end
      end
    end
  end
end
__END_OF_create_plate_spec.rb__
filename='spec/actions/create_search_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_create_search_spec.rb__ > $filename
# Spec requirements
require 'actions/spec_helper'
require 'actions/action_examples'


#Model requirements
require 'lims/core/actions/create_search'
require 'lims/core/persistence/search'
require 'lims/core/laboratory/plate'

module Lims::Core
  module Actions

    shared_examples_for "creating a search" do
      include_context "create object"
      it_behaves_like "an action"
      it "create a search object" do
        result = subject.call

        result.should be_a Hash

        search = result[:search]
        search.should be_a Persistence::Search
        search.model.should == model
        search.filter.criteria.should == criteria
      end
    end

    describe CreateSearch do
      context "valid calling context" do
        let!(:store) { Persistence::Store.new() }
        include_context("for application",  "Test search creation")

        before do
          Lims::Core::Persistence::Session.any_instance.tap do |session|
            session.stub(:search) {
              mock(:search).tap do |s|
              s.stub(:[]) 
              end
            }
          end
        end

        context "valid" do
          let(:model_name) { "plate" }
          let(:model) { Laboratory::Plate }
          let(:criteria) {{ :id => 1 }}
          let(:description) { "search description" }

          subject {  CreateSearch.new(:store => store, :user => user, :application => application)  do |a,s|
            a.description = description
            a.model = model_name
            a.criteria = criteria
          end
          }

          it_behaves_like "creating a search"

          context "with label criteria" do
            include_context "create object"
            let(:criteria) {{ :label => {:position => "front barcode"}}}
            it "uses a LabelFilter" do
              result = subject.call
              result.should be_a Hash
              search = result[:search]
              search.should be_a Persistence::Search
              search.filter.should be_a(Persistence::LabelFilter) 
            end
          end

          context "with order criteria" do
            include_context "create object"
            let(:criteria) { {:order => {:item => {:status => "pending"}, :status => "pending"}} }
            it "uses an OrderFilter" do
              result = subject.call
              result.should be_a Hash
              search = result[:search]
              search.should be_a Persistence::Search
              search.filter.should be_a(Persistence::OrderFilter)
            end
          end
        end

        context "invalid" do
          context "criteria not matching column" do
            let(:model_name) { "plate" }
            let(:model) { Laboratory::Plate }
            let(:criteria)  { { :dummy_attribute => :test } } 

            pending "needs implementatio" do
              it "should raise an error" do
                subject.call.should == false
              end
            end
          end
        end

      end

    end
  end
end

__END_OF_create_search_spec.rb__
filename='spec/actions/create_spin_column_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_create_spin_column_spec.rb__ > $filename
# Spec requirements
require 'actions/spec_helper'
require 'actions/action_examples'

#Model requirements
require 'lims/core/actions/create_spin_column'
require 'laboratory/tube_shared'
require 'lims/core/persistence/store'

module Lims::Core
  module Actions
    describe CreateSpinColumn do
      context "with a valid store" do
        include_context "create object"
        let (:store) { Persistence::Store.new }
        include_context("for application", "Test create spin column")

        context "create an empty spin column" do
          subject do 
            CreateSpinColumn.new(:store => store, :user => user, :application => application)  do |a,s|
            end
          end
          it_behaves_like "an action"
          it "create a spin column when called" do
            Persistence::Session.any_instance.should_receive(:save)
            result = subject.call
            result.should be_a(Hash)
            result[:spin_column].should be_a(Laboratory::SpinColumn)
            result[:uuid].should == uuid
          end
        end

        context "create a spin column with samples" do
          let(:sample) { new_sample(1) }
          subject do 
            CreateSpinColumn.new(:store => store, :user => user, :application => application, :aliquots => [{:sample => sample }]) do |a,s|
            end
          end
          it_behaves_like "an action"
          it "create a spin column when called" do
            Persistence::Session.any_instance.should_receive(:save)
            result = subject.call
            result.should be_a(Hash)
            result[:spin_column].should be_a(Laboratory::SpinColumn)
            result[:uuid].should == uuid
            result[:spin_column].first.sample.should == sample
          end
        end
      end
    end
  end
end
__END_OF_create_spin_column_spec.rb__
filename='spec/actions/create_tube_rack_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_create_tube_rack_spec.rb__ > $filename
# Spec requirements
require 'actions/action_examples'
require 'actions/spec_helper'

# Model requirements
require 'lims/core/actions/create_tube_rack'

module Lims::Core
  module Actions

    shared_context "has tube rack dimension" do |row, col|
      let(:number_of_rows) { row }
      let(:number_of_columns) { col }
      let(:dimensions) {{:number_of_rows => row, :number_of_columns => col}}
    end

    shared_context "for empty tube rack" do
      subject do
        CreateTubeRack.new(:store => store, :user => user, :application => application) do |a,s|
          a.ostruct_update(dimensions)
        end
      end

      let(:tube_rack_checker) do
        lambda do |tube_rack|
          tube_rack.each { |position| position.should be_nil }
        end
      end
    end

    shared_context "for a tube rack with tubes" do
      let(:tubes) {{
        "A1" => Laboratory::Tube.new,
        "B3" => Laboratory::Tube.new,
        "D5" => Laboratory::Tube.new,
        "F10" => Laboratory::Tube.new
      }} 

      subject do
        CreateTubeRack.new(:store => store, :user => user, :application => application) do |a,s|
          a.ostruct_update(dimensions)
          a.tubes = tubes
        end
      end

      let(:tube_rack_checker) do
        lambda do |tube_rack|
          tubes.each do |position, tube|
            tube_rack[position].should == tube
          end
        end
      end
    end

    shared_examples_for "creating a tube rack" do
      include_context "create object"
      it_behaves_like "an action"

      it "creates a tube rack when called" do
        result = subject.call
        result.should be_a Hash

        tube_rack = result[:tube_rack]
        tube_rack.number_of_rows.should == dimensions[:number_of_rows]
        tube_rack.number_of_columns.should == dimensions[:number_of_columns]
        tube_rack_checker[tube_rack]

        result[:uuid].should == uuid
      end
    end

    describe CreateTubeRack do
      context "valid calling context" do
        let!(:store) { Persistence::Store.new() }
        include_context "for application", "Test TubeRack creation"
        include_context "has tube rack dimension", 8, 12 

        context do
          include_context "for empty tube rack"
          it_behaves_like "creating a tube rack"
        end

        context do
          include_context "for a tube rack with tubes"
          it_behaves_like "creating a tube rack"
        end
      end
    end
  end
end
__END_OF_create_tube_rack_spec.rb__
filename='spec/actions/create_tube_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_create_tube_spec.rb__ > $filename
# Spec requirements
require 'actions/spec_helper'
require 'actions/action_examples'

#Model requirements
require 'lims/core/actions/create_tube'
require 'laboratory/tube_shared'
require 'lims/core/persistence/store'

module Lims::Core
  module Actions
    describe CreateTube do
      context "with a valid store" do
        include_context "create object"
        let (:store) { Persistence::Store.new }
        let(:user) { mock(:user) }
        let(:application) { "Test create tube" }
        let(:tube_type) { "Eppendorf" }
        let(:tube_max_volume) { 2 }

        context "create an empty tube" do
          subject do
            CreateTube.new(:store => store, :user => user, :application => application)  do |a,s|
              a.type = tube_type
              a.max_volume = tube_max_volume
            end
          end 
          it_behaves_like "an action"

          it "create a tube when called" do
            Persistence::Session.any_instance.should_receive(:save)
            result = subject.call
            result.should be_a(Hash)
            result[:tube].should be_a(Laboratory::Tube)
            result[:tube].type.should == tube_type
            result[:tube].max_volume.should == tube_max_volume
            result[:uuid].should == uuid
          end
        end

        context "create a tube with samples" do
          let(:sample) { new_sample(1) }
          subject do 
            CreateTube.new(:store => store, :user => user, :application => application) do |a,s|
              a.aliquots = [{:sample => sample }] 
              a.type = tube_type
              a.max_volume = tube_max_volume
            end
          end
          it_behaves_like "an action"
          it "create a tube when called" do
            Persistence::Session.any_instance.should_receive(:save)
            result = subject.call
            result.should be_a(Hash)
            result[:tube].should be_a(Laboratory::Tube)
            result[:uuid].should == uuid
            result[:tube].type.should == tube_type
            result[:tube].max_volume.should == tube_max_volume
            result[:tube].first.sample.should == sample
          end
        end
      end
    end
  end
end
__END_OF_create_tube_spec.rb__
filename='spec/actions/labware_action_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_labware_action_spec.rb__ > $filename
require 'actions/spec_helper'

require 'actions/action_examples'

module Lims::Core::Action
  describe "Plate::Stamping" do
    pending "Not Implemented" do
      it_behaves_like "an action"
      context "from a plate to another plate" do
        context "to another plate" do
          it "transfers all the wells to the other plate"
        end

        context "to many plates" do
          it "fails"
        end
      end 
    end
  end

  describe "Plate::Pooling" do
    pending "Not implemented" do
      it_behaves_like "an action"
      context "from a plate to another plate" do
        it "transfers wells to other plate grouped by pool"
      end
    end
  end

  describe "Plate::Rotating" do
    pending "Not implemented" do
      it_behaves_like "an action"
      context "from a plate to another plate" do
        context "if possible" do
          it "transfers the well in transposed way" 
        end
        context "if not possible" do
          it "fails"
        end
      end
      pending "Not implemented" do
      end

      describe "Plate::Cherrypicking" do
        pending "Not implemented" do
          context "from many plates to one plate" do
            it "transfers some wells to the destination plate"
          end 
        end
      end

      describe "Plate::Tagging" do
      end

      describe "plate to tubes" do
      end
    end
  end
end
__END_OF_labware_action_spec.rb__
filename='spec/laboratory/plate/plate_transfer_spec.rb
mkdir -p $(dirname $filename)
cat <<__END_OF_plate_transfer_spec.rb__ > $filename
# Spec requirements
require 'actions/spec_helper'
require 'actions/action_examples'
require 'laboratory/plate_and_gel_shared'

require 'persistence/sequel/store_shared'
#Model requirements
require 'lims/core/actions/plate_transfer'
require 'lims/core/persistence/sequel/store'
require 'logger'

module Lims::Core
  module Laboratory
    describe PlateTransfer do
      include_context "plate or gel factory"
        let(:user) { mock(:user) }
        let(:application) { "Test create plate" }
      def self.should_transfer 
        # @todo special test session class ?

        context "setup to transfert between valid plates" do
          let(:number_of_rows) { 8 }
          let(:number_of_columns) { 12 }
          let(:source) { new_plate_with_samples }
          let(:target) { new_empty_plate }
          subject do
            described_class.new(:store => store, :user => user, :application => application) do |a, s|
              a.target = target
              a.source = source
              a.transfer_map = { :C3 => :B1 }
            end 
          end
          it_behaves_like "an action"
          context "when called" do
            before { subject.call }
            it "should transfer samples" do
              target[:B1].should == source[:C3] 
            end
          end
        end
      end


      context "with a sequel store" do
        include_context "prepare tables"
        let(:db) { ::Sequel.sqlite('') }
        let(:store) { Persistence::Sequel::Store.new(db) }
        before (:each) { prepare_table(db) }

        context "with invalid paramters" do
          context "when called" do
          subject do
            described_class.new(:store => store, :user => user, :application => application)
          end
            before(:each)  {
              subject.call
            }

            its(:result) { should == nil }
            its(:errors) { should_not be_empty }
          end
        end
        # should_transfer

        context "with plates ids" do
          let(:number_of_rows) { 8 }
          let(:number_of_columns) { 12 }
          let(:source_id) do 
            store.with_session  do |s|
              s << plate=new_plate_with_samples
              lambda { s.plate.id_for(plate) } # called after save
            end.call
          end

          let(:target_id) do 
            store.with_session  do |s|
              s << plate=new_empty_plate
              lambda { s.id_for(plate) }
            end.call
          end

          context "when called without updating aliquot type" do
            subject do
              described_class.new(:store => store, :user => user, :application => application) do |a, s|
                a.source = s.plate[source_id]
                a.target = s.plate[target_id]
                a.transfer_map = { :C3 => :B1 }
              end 
            end
            before { subject.call }
            it "should save the transfered plates" do 
              store.with_session do |s|
                source, target = [source_id, target_id].map { |i| s.plate[i] }
                target[:B1].should == source[:C3]
              end
            end
          end

          context "when called updating aliquot type" do
            let(:aliquot_type) { "sample" }
            subject do
              described_class.new(:store => store, :user => user, :application => application) do |a, s|
                a.source = s.plate[source_id]
                a.target = s.plate[target_id]
                a.transfer_map = { :C3 => :B1 }
                a.aliquot_type = aliquot_type
              end 
            end
            before { subject.call }
            it "should save the transfered plates" do
              store.with_session do |s|
                source, target = [source_id, target_id].map { |i| s.plate[i] }
                target[:B1].should_not == source[:C3]
                target[:B1].each do |aliquot|
                  aliquot.type.should == aliquot_type
                end
                source[:C3].each do |aliquot|
                  aliquot.type.should be_nil
                end
              end
            end
          end
        end
      end
    end
  end
end
__END_OF_plate_transfer_spec.rb__
filename='spec/actions/sequel/create_search_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_create_search_spec.rb__ > $filename
# Spec requirements
require 'actions/action_examples'
require 'persistence/sequel/store_shared'

#Model requirements
require 'lims/core/actions/create_search'
require 'lims/core/persistence/search'

module Lims::Core
  module Laboratory

    describe CreateSearch do
      context "valid calling context" do

        include_context("for application",  "Test search creation")
        include_context "sequel store"
        let(:model_name) { "plate" }
        let(:criteria) {{ :id => 1 }}
        let(:description) { "search description" }

        subject {  CreateSearch.new(:store => store, :user => user, :application => application)  do |a,s|
          a.description = description
          a.model = model_name
          a.criteria = criteria
        end
        }
  
        context "two identical searches" do 
          it "must not store a search if one similar already exists in the database" do
            expect do
              subject.call
              subject.call
            end.to change { db[:searches].count }.by(1) 
          end

          it "should return an existing search from database if the search already exists" do
            result = subject.call
            result_new_search = subject.call
            result[:search].should == result_new_search[:search]
          end
        end

      end
    end
  end
end

__END_OF_create_search_spec.rb__
filename='spec/actions/spec_helper.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_spec_helper.rb__ > $filename
require 'spec_helper'

require 'lims/core/persistence/store'
require 'lims/core/persistence/session'

shared_context "create object" do
  let (:uuid) { "00000000-1111-2222-3333-444444444444" }
  before do 
    Lims::Core::Persistence::Session.any_instance.tap do |session|
      session.stub(:save)
      session.stub(:uuid_for!) { uuid }
    end
  end
end


__END_OF_spec_helper.rb__
filename='spec/actions/tag_well_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_tag_well_spec.rb__ > $filename
# Spec requirements
require 'actions/spec_helper'
require 'actions/action_examples'

require 'persistence/sequel/spec_helper'
require 'laboratory/plate_and_gel_shared'
require 'persistence/sequel/store_shared'

#Model requirements
require 'lims/core/actions/tag_wells'

require 'lims/core/persistence/sequel/store'


module Lims::Core
  module Laboratory
    describe TagWells do
      include_context "plate or gel factory"
      let(:number_of_rows) {8}
      let(:number_of_columns) {12}
      context "with a sequel store" do
        include_context "sequel store"

        context "and everything already in the database" do
          let(:plate_id) { save(new_plate_with_samples(1)) }
          let(:oligo_1_id) { save(Laboratory::Oligo.new("AAA")) }
          let(:oligo_2_id) { save(Laboratory::Oligo.new("TAG")) }
          let(:well_to_tag_id_map) { { :C1 => oligo_1_id, :F7 => oligo_2_id } }

          let(:user) { mock(:user) }
          let(:application) { "Test assign tag to well" }
          subject { described_class.new(:store => store, :user => user, :application => application) do |a,s|
            a.plate = s.plate[plate_id]
            a.well_to_tag_map = well_to_tag_id_map.map { |w,t_id| [w, s.oligo[t_id]] }
          end
          }

          it "tags the well as expected" do
            subject.call
            store.with_session do |session|
              plate = session.plate[plate_id]
              oligo_1 = session.oligo[oligo_1_id]
              oligo_2 = session.oligo[oligo_2_id]

              plate.each_with_index do  |well, name|
                well.each do |aliquot|
                  #puts "well #{name}, tag #{aliquot.tag}"
                  aliquot.tag.should == case name
                                        when "C1" then oligo_1
                                        when "F7" then oligo_2
                                        else nil
                                        end
                end
              end
            end
          end
        end

        context "with an empty database" do
      let(:number_of_rows) {3}
      let(:number_of_columns) {1}
          let(:user) { mock(:user) }
          let(:application) { "Test assign tag to well" }
          subject { described_class.new(:store => store, :user => user, :application => application) do |a,s|
            s << a.plate=new_plate_with_samples(1)
            a.well_to_tag_map = { "C1" => Laboratory::Oligo.new("TAG") }
          end
          }

          it "should save everything" do
            plate_id = subject.call { |a, s| s.id_for(a.plate) }
            store.with_session do |session|
              plate = session.plate[plate_id]
              plate[:C1].first.tag.should == "TAG"
            end
          end
        end
      end
    end
  end
end
__END_OF_tag_well_spec.rb__
filename='spec/actions/transfer_plates_to_plates_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_transfer_plates_to_plates_spec.rb__ > $filename
# Spec requirements
require 'persistence/sequel/spec_helper'
require 'persistence/sequel/store_shared'
require 'laboratory/plate_and_gel_shared'
require 'laboratory/tube_rack_shared'

# Model requirements
require 'lims/core/actions/transfer_plates_to_plates'

shared_examples_for "transfer from many plates to many gels" do
  it "transfers the contents of plate-like(s) to plate-like(s)" do
    subject.call
    store.with_session do |session|
      plate1, plate2 = [plate1_id, plate2_id].map { |id| session.plate[id] }
      gel1, gel2 = [gel1_id, gel2_id].map { |id| session.gel[id] }

      plate1["A1"].quantity.should == final_quantity_plate1_A1
      plate1["C3"].quantity.should == final_quantity_plate1_C3

      gel1["B2"].should_not be_nil
      gel1["E8"].should_not be_nil

      gel1["B2"].each do |aliquot|
        aliquot.type.should == type1
      end

      gel1["E8"].each do |aliquot|
        aliquot.type.should == type1
      end

      plate2["A1"].quantity.should == final_quantity_plate2_A1
      plate2["C3"].quantity.should == final_quantity_plate2_C3

      gel2["B2"].should_not be_nil
      gel2["E8"].should_not be_nil

      gel2["B2"].each do |aliquot|
        aliquot.type.should == type2
      end

      gel2["E8"].each do |aliquot|
        aliquot.type.should == type2
      end
    end
  end
end

shared_examples_for "transfer from many racks to many plates" do
  it "transfers the contents of plate-like(s) to plate-like(s)" do
    subject.call
    store.with_session do |session|
      rack1, rack2 = [rack1_id, rack2_id].map { |id| session.tube_rack[id] }
      plate1, plate2 = [plate1_id, plate2_id].map { |id| session.plate[id] }

      rack1["A1"].quantity.should == final_quantity_rack1_A1
      rack1["C3"].quantity.should == final_quantity_rack1_C3
      plate1["B2"].should_not be_nil
      plate1["E8"].should_not be_nil

      plate1["B2"].each do |aliquot|
        aliquot.type.should == type1
        aliquot.quantity.should == final_quantity_plate1_B2
      end

      plate1["E8"].each do |aliquot|
        aliquot.type.should == type1
        aliquot.quantity.should == final_quantity_plate1_E8
      end

      rack2["A1"].quantity.should == final_quantity_rack2_A1
      rack2["C3"].quantity.should == final_quantity_rack2_C3
      plate2["B2"].should_not be_nil
      plate2["E8"].should_not be_nil

      plate2["B2"].each do |aliquot|
        aliquot.type.should == type2
        aliquot.quantity.should == final_quantity_plate2_B2
      end

      plate2["E8"].each do |aliquot|
        aliquot.type.should == type2
        aliquot.quantity.should == final_quantity_plate2_E8
      end
    end
  end
end

module Lims::Core
  module Laboratory
    describe TransferPlatesToPlates do
      include_context "plate or gel factory"
      include_context "tube_rack factory"

      context "with a sequel store" do
        include_context "sequel store"

        context "and everything already in the database" do
          let(:user) { mock(:user) }
          let(:application) { "test transfer plate-like(s) to plate-like(s) with a given transfer map" }
          let(:number_of_rows) { 8 }
          let(:number_of_columns) { 12 }

          context "with valid parameters" do
            let(:type1) { "RNA" }
            let(:type2) { "DNA" }
            context "transfer from 2 plates to 2 gels" do
              let(:quantity1) { 100 }
              let(:quantity2) { 100 }
              let(:final_quantity_plate1_A1) { 40 }
              let(:final_quantity_plate1_C3) { 40 }
              let(:final_quantity_plate2_A1) { 70 }
              let(:final_quantity_plate2_C3) { 70 }
              let(:final_quantity_gel1_B2) { 60 }
              let(:final_quantity_gel1_E8) { 60 }
              let(:final_quantity_gel2_B2) { 30 }
              let(:final_quantity_gel2_E8) { 30 }
              let(:plate1_id) { save(new_plate_with_samples(5, quantity1)) }
              let(:plate2_id) { save(new_plate_with_samples(5, quantity2)) }
              let(:gel1_id) { save(new_empty_gel) }
              let(:gel2_id) { save(new_empty_gel) }

              subject { described_class.new(:store => store, 
                                            :user => user, 
                                            :application => application) do |action, session|
                plate1, plate2 = [plate1_id, plate2_id].map { |id| session.plate[id] }
                gel1, gel2 = [gel1_id, gel2_id].map { |id| session.gel[id] }

                action.transfers = [ { "source" => plate1,
                                       "source_location" => "A1",
                                       "target" => gel1,
                                       "target_location" => "B2",
                                       "fraction" => 0.6,
                                       "aliquot_type" => type1},
                                     { "source" => plate1,
                                       "source_location" => "C3",
                                       "target" => gel1,
                                       "target_location" => "E8",
                                       "fraction" => 0.6,
                                       "aliquot_type" => type1},
                                     { "source" => plate2,
                                       "source_location" => "A1",
                                       "target" => gel2,
                                       "target_location" => "B2",
                                       "fraction" => 0.3,
                                       "aliquot_type" => type2},
                                     { "source" => plate2,
                                       "source_location" => "C3",
                                       "target" => gel2,
                                       "target_location" => "E8",
                                       "fraction" => 0.3,
                                       "aliquot_type" => type2},
                ]
              end
              }

              it_behaves_like "transfer from many plates to many gels"
            end

            context "transfer from 2 racks to 2 plates", :focus => true do
              let(:quantity1) { 1000 }
              let(:quantity2) { 1000 }
              let(:final_quantity_rack1_A1) { 940 }
              let(:final_quantity_rack1_C3) { 940 }
              let(:final_quantity_rack2_A1) { 970 }
              let(:final_quantity_rack2_C3) { 970 }
              let(:final_quantity_plate1_B2) { 60 }
              let(:final_quantity_plate1_E8) { 60 }
              let(:final_quantity_plate2_B2) { 30 }
              let(:final_quantity_plate2_E8) { 30 }
              let(:rack1_id) { save(new_tube_rack_with_samples(5, quantity1, 1000)) }
              let(:rack2_id) { save(new_tube_rack_with_samples(5, quantity2, 1000)) }
              let(:plate1_id) { save(new_empty_plate) }
              let(:plate2_id) { save(new_empty_plate) }
        
              subject { described_class.new(:store => store, 
                                            :user => user, 
                                            :application => application) do |action, session|
                rack1, rack2 = [rack1_id, rack2_id].map { |id| session.tube_rack[id] }
                plate1, plate2 = [plate1_id, plate2_id].map { |id| session.plate[id] }

                  action.transfers = [ { "source" => rack1,
                                       "source_location" => "A1",
                                       "target" => plate1,
                                       "target_location" => "B2",
                                       "amount" => 60,
                                       "aliquot_type" => type1},
                                     { "source" => rack1,
                                       "source_location" => "C3",
                                       "target" => plate1,
                                       "target_location" => "E8",
                                       "amount" => 60,
                                       "aliquot_type" => type1},
                                     { "source" => rack2,
                                       "source_location" => "A1",
                                       "target" => plate2,
                                       "target_location" => "B2",
                                       "amount" => 30,
                                       "aliquot_type" => type2},
                                     { "source" => rack2,
                                       "source_location" => "C3",
                                       "target" => plate2,
                                       "target_location" => "E8",
                                       "amount" => 30,
                                       "aliquot_type" => type2}
                ]
              end
              }
        
              it_behaves_like "transfer from many racks to many plates"
            end
          end

        end
      end
    end
  end
end
__END_OF_transfer_plates_to_plates_spec.rb__
filename='spec/actions/transfer_tubes_to_tubes_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_transfer_tubes_to_tubes_spec.rb__ > $filename
#Spec requirements
require 'persistence/sequel/store_shared'

require 'persistence/sequel/spec_helper'
require 'laboratory/tube_shared'
require 'laboratory/spin_column_shared'

# Model requirements
require 'lims/core/actions/transfer_tubes_to_tubes'

shared_examples_for "transfer tube to spin column" do
  it "transfers a tube like(s)'s content to tube-like(s) as expected" do
    subject.call
    store.with_session do |session|
      tube1, tube2 = [tube1_id, tube2_id].map { |id| session.tube[id] }
      spin_column1, spin_column2 = [spin_column1_id, spin_column2_id].map { |id| session.spin_column[id] }

      spin_column1.size.should == tube1.size
      spin_column1.each do |aliquot|
        aliquot.type.should == type1
        aliquot.quantity.should == finalQuantity1
      end
      spin_column2.size.should == tube2.size
      spin_column2.each do |aliquot|
        next if aliquot.type == Lims::Core::Laboratory::Aliquot::Solvent
        aliquot.type.should == type2
        aliquot.quantity.should == finalQuantity2
      end
    end
  end
end

shared_examples_for "transfer spin column to tube" do
  it "transfers a tube like(s)'s content to tube-like(s) as expected" do
    subject.call
    store.with_session do |session|
      tube1, tube2 = [tube1_id, tube2_id].map { |id| session.tube[id] }
      spin_column1, spin_column2 = [spin_column1_id, spin_column2_id].map { |id| session.spin_column[id] }

        tube1.size.should == spin_column1.size
      tube1.each do |aliquot|
        aliquot.type.should == type1
        aliquot.quantity.should == finalQuantity1
      end
      tube2.size.should == spin_column2.size
      tube2.each do |aliquot|
        aliquot.type.should == type2
        aliquot.quantity.should == finalQuantity2
      end
    end
  end
end

shared_examples_for "transfer a tube content to a spin column and a tube" do
  it "transfers a tube like(s)'s content to tube-like(s) as expected" do
    subject.call
    store.with_session do |session|
      tube1, tube2 = [tube1_id, tube2_id].map { |id| session.tube[id] }
      spin_column1 = session.spin_column[spin_column1_id]

      spin_column1.size.should == tube1.size
      spin_column1.each do |aliquot|
        aliquot.type.should == type1
        aliquot.quantity.should == finalQuantity1
      end
      tube2.size.should == tube1.size
      tube2.each do |aliquot|
        aliquot.type.should == type2
        aliquot.quantity.should == finalQuantity2
      end
    end
  end
end

module Lims::Core
  module Laboratory
    describe TransferTubesToTubes do
      include_context "spin column factory"
      include_context "tube factory"

      context "with a sequel store" do
        include_context "sequel store"

        context "and everything already in the database" do
          let(:user) { mock(:user) }
          let(:application) { "test transfer tube-like(s) to tube-like(s)" }

          context "with valid parameters" do
            let(:type1) { "NA" }
            let(:type2) { "DNA" }
            context "transfer tubes to spin columns with amount" do
              let(:quantity1) { 100 }
              let(:quantity2) { 100 }
              let(:spin_column1_id) { save(new_empty_spin_column) }
              let(:spin_column2_id) { save(new_empty_spin_column) }
              let(:tube1_id) { save(new_tube_with_samples(10, quantity1)) }
              let(:tube2_id) { save(new_tube_with_samples(10, quantity2).tap do |tube|
                    tube.each { |a| a.type = type2 unless a.type }
                  end
                ) }
              let(:amount1) { 600 }
              let(:amount2) { 400 }
              let!(:finalQuantity1) { 100 }
              let!(:finalQuantity2) { 100 }

              subject { described_class.new(:store => store, 
                                            :user => user, 
                                            :application => application) do |action, session|
                tube1, tube2 = [tube1_id, tube2_id].map { |id| session.tube[id] }
                spin_column1, spin_column2 = [spin_column1_id, spin_column2_id].map { |id| session.spin_column[id] }

                action.transfers = [ { "source" => tube1,
                                        "target" => spin_column1,
                                        "amount" => amount1,
                                        "aliquot_type" => type1},
                                     { "source" => tube2,
                                       "target" => spin_column2,
                                       "amount" => amount2
                                       # We don't change the type of this one
                                       # so, it should be the same as the initial tube
                                     }
                                   ]
              end
              }

              it_behaves_like "transfer tube to spin column"
            end

            context "transfer spin columns to tubes with fraction" do
              let(:quantity1) { 100 }
              let(:quantity2) { 100 }
              let(:number_of_samples) { 10 }
              let(:spin_column1_id) { save(new_spin_column_with_samples(number_of_samples, quantity1)) }
              let(:spin_column2_id) { save(new_spin_column_with_samples(number_of_samples, quantity2)) }
              let(:tube1_id) { save(new_empty_tube) }
              let(:tube2_id) { save(new_empty_tube) }
              let(:fraction1) { 0.6 }
              let(:fraction2) { 0.4 }
              let!(:finalQuantity1) { 60 }
              let!(:finalQuantity2) { 40 }

              subject { described_class.new(:store => store, 
                                            :user => user, 
                                            :application => application) do |action, session|
                tube1, tube2 = [tube1_id, tube2_id].map { |id| session.tube[id] }
                spin_column1, spin_column2 = [spin_column1_id, spin_column2_id].map { |id| session.spin_column[id] }
                
                action.transfers = [ { "source" => spin_column1,
                                        "target" => tube1,
                                        "fraction" => fraction1,
                                        "aliquot_type" => type1},
                                     { "source" => spin_column2,
                                       "target" => tube2,
                                       "fraction" => fraction2,
                                       "aliquot_type" => type2}
                                   ]
              end
              }

              it_behaves_like "transfer spin column to tube"
            end

            context "transfer from tubes to spin column and tube with fraction" do
              let(:quantity1) { 100 }
              let(:number_of_samples) { 10 }
              let(:tube1_id) { save(new_tube_with_samples(number_of_samples, quantity1)) }
              let(:tube2_id) { save(new_empty_tube) }
              let(:spin_column1_id) { save(new_empty_spin_column) }
              let(:fraction1) { 0.6 }
              let(:fraction2) { 1 }
              let!(:finalQuantity1) { 60 }
              let!(:finalQuantity2) { 40 }
              let(:type1) { "DNA" }
              let(:type2) { "NA" }

              subject { described_class.new(:store => store, 
                                            :user => user, 
                                            :application => application) do |action, session|
                tube1, tube2 = [tube1_id, tube2_id].map { |id| session.tube[id] }
                spin_column1 = session.spin_column[spin_column1_id]

                action.transfers = [ { "source" => tube1,
                                        "target" => spin_column1,
                                        "fraction" => fraction1,
                                        "aliquot_type" => type1},
                                     { "source" => tube1,
                                       "target" => tube2,
                                       "fraction" => fraction2,
                                       "aliquot_type" => type2
                                     }
                                   ]
              end
              }

              it_behaves_like "transfer a tube content to a spin column and a tube"
            end
          end
        end
      end
    end
  end
end
__END_OF_transfer_tubes_to_tubes_spec.rb__
filename='spec/actions/transfer_wells_to_tubes_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_transfer_wells_to_tubes_spec.rb__ > $filename
# Spec requirements
require 'actions/spec_helper'
require 'actions/action_examples'

require 'persistence/sequel/spec_helper'
require 'laboratory/plate_and_gel_shared'
require 'laboratory/tube_shared'
require 'persistence/sequel/store_shared'

#Model requirements
require 'lims/core/actions/transfer_wells_to_tubes'

require 'lims/core/persistence/sequel/store'

require 'logger'
PS=Lims::Core::Persistence::Sequel

module Lims::Core
  module Laboratory
    describe TransferWellsToTubes do
      include_context "plate or gel factory"
      include_context "tube factory"
      let(:number_of_rows) {8}
      let(:number_of_columns) {12}
      context "with a sequel store" do
        include_context "prepare tables"
        let(:db) { ::Sequel.sqlite('') }
        let(:store) { PS::Store.new(db) }
        before (:each) { prepare_table(db) }

        context "and everything already in the database" do
          let(:plate_id) { save(new_plate_with_samples(1)) }
          let(:tube1_id) { save(new_empty_tube) }
          let(:tube2_id) { save(new_empty_tube) }

          let(:user) { mock(:user) }
          let(:application) { "test transfer wells to tubes" }

          context "with valid parameters" do
            subject { described_class.new(:store => store, :user => user, :application => application) do |a,s|
              a.plate = s.plate[plate_id]
              tube1, tube2 = [tube1_id, tube2_id].map { |id| s.tube[id] }
              a.well_to_tube_map =  {"A1" => tube1, "C3" => tube2}
            end
            }

            it "transfers the well as expected" do
              subject.call
              store.with_session do |session|
                plate = session.plate[plate_id]
                tube1, tube2 = [tube1_id, tube2_id].map { |id| session.tube[id] }
                tube1.should == plate["A1"]
                tube2.should == plate["C3"]
              end
            end
          end

          context "with invalid parameters like" do
            context "two wells going in the same tube" do
              subject { described_class.new(:store => store, :user => user, :application => application) do |a,s|
                a.plate = s.plate[plate_id]
                tube1, tube2 = [tube1_id, tube2_id].map { |id| s.tube[id] }
                a.well_to_tube_map =  {"A1" => tube1, "C3" => tube1}
              end
              }

              pending "not implemented" do
              it "should raise an exception" do
                expect { subject.call}.to raise_error(Action::InvalidParameters)
              end
            end
            end
          end
        end

        context "with an empty database" do
          let(:number_of_rows) {3}
          let(:number_of_columns) {5}
          let(:user) { mock(:user) }
          let(:application) { "Test assign tag to well" }
          let(:tube) {  new_empty_tube }
          let(:plate) { new_plate_with_samples }
          subject { described_class.new(:store => store, :user => user, :application => application) do |a,s|
            a.plate = plate
            a.well_to_tube_map = {"C3" => tube } 
          end
          }

          it "should save all the tubes" do
            plate_id, tube_id = subject.call { |a, s| [s.id_for(plate), s.id_for(tube)] }
            store.with_session do |session|
              tube.should === plate["C3"]
            end
          end
        end
      end
    end
  end
end
__END_OF_transfer_wells_to_tubes_spec.rb__
filename='spec/laboratory/tube/tube_rack_move_spec.rb
mkdir -p $(dirname $filename)
cat <<__END_OF_tube_rack_move_spec.rb__ > $filename
# Spec requirements
require 'actions/action_examples'
require 'persistence/sequel/store_shared'
require 'laboratory/tube_rack_shared'

# Model requirements
require 'lims/core/actions/tube_rack_move'
require 'lims/core/persistence/sequel/store'

module Lims::Core
  module Laboratory
    describe TubeRackMove do
      context "with a sequel store" do
        include_context "for application", "test tube rack move"
        include_context "sequel store"
        include_context "tube_rack factory"

        let(:number_of_rows) { 8 }
        let(:number_of_columns) { 12 }

        let(:source1_id) {
          store.with_session do |session|
            rack = new_tube_rack_with_samples(1)
            session << rack
            lambda { session.tube_rack.id_for(rack) }
          end.call
        }

        let(:source2_id) {
          store.with_session do |session|
            rack = new_tube_rack_with_samples(1)
            session << rack
            lambda { session.tube_rack.id_for(rack) }
          end.call
        }

        let(:target1_id) {
          store.with_session do |session|
            rack = target_tube_rack1
            session << rack
            lambda { session.tube_rack.id_for(rack) }
          end.call
        }

        let(:target2_id) {
          store.with_session do |session|
            rack = target_tube_rack2
            session << rack
            lambda { session.tube_rack.id_for(rack) }
          end.call
        }

        context "invalid action parameters" do
          subject { described_class.new(:store => store, :user => user, :application => application) }
          before(:each) { subject.call }
          its(:result) { should be_nil }
          its(:errors) { should_not be_empty }
        end

        # Tube already present in target tube rack
        context "invalid transfer" do
          let(:target_tube_rack1) { new_tube_rack_with_samples(1) }

          subject do
            described_class.new(:store => store, :user => user, :application => application) do |action, session|
              action.moves = [
                {"source" => session.tube_rack[source1_id],
                 "source_location" => "A4",
                 "target" => session.tube_rack[target1_id],
                 "target_location" => "E9" }
              ]
            end
          end

          it "fails" do
            expect { subject.call }.to raise_error(Laboratory::TubeRack::RackPositionNotEmpty)
          end
        end

        context "valid transfer", :focus => true do
          let(:target_tube_rack1) { new_empty_tube_rack }
          let(:target_tube_rack2) { new_empty_tube_rack }
          before(:each) { subject.call }
          its(:result) { subject.size.should == 2 }
          subject do
            described_class.new(:store => store, :user => user, :application => application) do |action,session|
              source_tube_rack1, source_tube_rack2 = [source1_id, source2_id].map { |uuid| session.tube_rack[uuid] }
              action.moves = [
                {"source" => source_tube_rack1,
                 "source_location" => "A1",
                 "target" => target_tube_rack1,
                 "target_location" => "B9" },
                {"source" => source_tube_rack1,
                 "source_location" => "B2",
                 "target" => target_tube_rack2,
                 "target_location" => "F3" },
                {"source" => source_tube_rack2,
                 "source_location" => "C5",
                 "target" => target_tube_rack1,
                 "target_location" => "D4" },
                {"source" => source_tube_rack2,
                 "source_location" => "E8",
                 "target" => target_tube_rack2,
                 "target_location" => "A9" }
              ]
            end
          end

          it "saves the transfered rack" do
            store.with_session do |session|
              source_tube_rack1, source_tube_rack2 = [source1_id, source2_id].map { |uuid| session.tube_rack[uuid] }
              source_tube_rack1[:A1].should be_nil
              source_tube_rack1[:B2].should be_nil
              source_tube_rack2[:C5].should be_nil
              source_tube_rack2[:E8].should be_nil

              target_tube_rack1[:B9].should_not be_nil
              target_tube_rack1[:B9].should be_a(Lims::Core::Laboratory::Tube)
              target_tube_rack1[:D4].should_not be_nil
              target_tube_rack1[:D4].should be_a(Lims::Core::Laboratory::Tube)
              target_tube_rack2[:F3].should_not be_nil
              target_tube_rack2[:F3].should be_a(Lims::Core::Laboratory::Tube)
              target_tube_rack2[:A9].should_not be_nil
              target_tube_rack2[:A9].should be_a(Lims::Core::Laboratory::Tube)
            end
          end
        end
      end
    end
  end
end
__END_OF_tube_rack_move_spec.rb__
filename='spec/laboratory/tube/tube_rack_transfer_spec.rb
mkdir -p $(dirname $filename)
cat <<__END_OF_tube_rack_transfer_spec.rb__ > $filename
# Spec requirements
require 'actions/action_examples'
require 'persistence/sequel/store_shared'
require 'laboratory/tube_rack_shared'

# Model requirements
require 'lims/core/actions/tube_rack_transfer'
require 'lims/core/persistence/sequel/store'


module Lims::Core
  module Laboratory
    describe TubeRackTransfer do
      context "with a sequel store" do
        include_context "for application", "test tube rack transfer"
        include_context "prepare tables"
        include_context "tube_rack factory"

        let(:number_of_rows) { 8 }
        let(:number_of_columns) { 12 }
        let(:db) { ::Sequel.sqlite('') }
        let(:store) { Persistence::Sequel::Store.new(db) }
        before(:each) { prepare_table(db) }

        let(:source_id) {
          store.with_session do |session|
            rack = new_tube_rack_with_samples(1) 
            session << rack
            lambda { session.tube_rack.id_for(rack) }
          end.call
        }

        let(:target_id) {
          store.with_session do |session|
            rack = new_empty_tube_rack.tap do |r|
              r["E9"] = new_empty_tube
            end
            session << rack
            lambda { session.tube_rack.id_for(rack) }
          end.call
        }


        context "invalid action parameters" do
          subject { described_class.new(:store => store, :user => user, :application => application) }
          before(:each) { subject.call }
          its(:result) { should be_nil }
          its(:errors) { should_not be_empty }
        end


        # No tube in target rack B1
        context "invalid transfer" do 
          subject do
            described_class.new(:store => store, :user => user, :application => application) do |a,s|
              a.source = s.tube_rack[source_id]
              a.target = s.tube_rack[target_id]
              a.transfer_map = {:A4 => :B1}
            end
          end

          it "fails" do
            expect { subject.call }.to raise_error(TubeRackTransfer::NoTubeInTargetLocation)
          end
        end


        context "valid transfer" do
          before(:each) { subject.call }
          subject do
            described_class.new(:store => store, :user => user, :application => application) do |a,s|
              a.source = s.tube_rack[source_id]
              a.target = s.tube_rack[target_id]
              a.transfer_map = {:A4 => :E9}
            end
          end

          it "saves the transfered rack" do
            store.with_session do |session|
              source = session.tube_rack[source_id]
              target = session.tube_rack[target_id]
              target[:E9].should_not be_nil
              source[:A4].quantity.should == 0
            end
          end
        end
      end
    end
  end
end
__END_OF_tube_rack_transfer_spec.rb__
filename='spec/actions/update_order_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_update_order_spec.rb__ > $filename
# Spec requirements
require 'actions/spec_helper'
require 'actions/action_examples'


#Model requirements
require 'lims/core/actions/update_order'
require 'lims/core/organization/order'
module Lims::Core
  module Laboratory

    shared_context "draft order" do
      let(:order_creation_parameter) { {} }
      let(:post_init_event) { [] }
    end

    shared_context "no items" do
      let(:order_items) { { } }
    end

    shared_examples_for "items" do
      let(:pending_uuid) { "11111111-1111-0000-0000-111111111111" }
      let(:in_progress_uuid) { "11111111-1111-0000-0000-222222222222" }
      let(:done_uuid) { "11111111-1111-0000-0000-333333333333" }
      let(:item) { Organization::Order::Item.new(:uuid =>   new_uuid) }
      let(:role) { "role" } 
      let(:order_items) { { "pending" => [Organization::Order::Item.new(:uuid => pending_uuid)],
          "in_progress" => [Organization::Order::Item.new(:uuid => in_progress_uuid).tap { |i| i.start! }],
          "done" => [Organization::Order::Item.new(:uuid => done_uuid).tap { |i| i.complete! }]
        }
      }
    end

    shared_examples_for "adding items" do |event=nil, new_status=nil|
      let(:new_uuid) { "22222222-1111-0000-0000-111111111111" }
      include_context "order updated"
      let(:parameters) { item_parameters.tap { |h| h[:event] = event if event } }
      context "add pending item#{event} and set send #{event}" do
        let(:item_parameters) { { :items => { "role1" => { new_uuid => {}  } } } }
        it "has a new role" do
          updated_order.should  include("role1")
        end
        it "has the correct item"  do
          updated_order["role1"].first.uuid.should == new_uuid
        end
        it "'s item has the correct status_name" do
          updated_order["role1"].first.status_name.should == :pending
        end

        it "has the correst status " do
          new_status ||= order.status
          updated_order.status.should == new_status
        end
      end
      context "add pending item and assigned it to a batch " do
        let(:item_parameters) { { :items => { "role1" => { new_uuid => {"batch" => batch}  } } } }
        it "has a new role" do
          updated_order.should include("role1")
        end
        it "has the correct item"  do
          updated_order["role1"].first.uuid.should == new_uuid
        end
        it "is assigned to a batch" do
          updated_order["role1"].first.batch.should == batch
        end
        it "'s item has the correct status_name" do
          updated_order["role1"].first.status_name.should == :pending
        end
        it "has the correst status " do
          new_status ||= order.status
          updated_order.status.should == new_status
        end
      end
      context "add pending item at the end#{ event and "set send #{event}"}" do
        let(:item_parameters) { { :items => { "role1" => { "last" => {  "uuid" => new_uuid } } } } }
        it "has a new role" do
          updated_order.should  include("role1")
        end
        it "has the correct item"  do
          updated_order["role1"].first.uuid.should == new_uuid
        end
        it "'s item has the correct status_name" do
          updated_order["role1"].first.status_name.should == :pending
        end

        it "has the correct status " do
          new_status ||= order.status
          updated_order.status.should == new_status
        end
      end
      # skiping status_name
      context "add done item in existing role" do
        let(:item_parameters) { { :items => { "done" => { new_uuid => { "event" => :complete } } } } }
        it "has the correct item"  do
          updated_order["done"].last.uuid.should == new_uuid
        end
        it "has the correct status_name" do
          updated_order["done"].last.status_name.should == :done
        end

        it "has the correst status " do
          new_status ||= order.status
          updated_order.status.should == new_status
        end
      end
      context "add done item and assign it to a bash" do
        let(:item_parameters) { { :items => { "role1" => { new_uuid => { "event" => :complete,
                                                                         "batch" => batch} } } } }
        it "has a new role" do
          updated_order.should  include("role1")
        end
        it "has the correct item"  do
          updated_order["role1"].first.uuid.should == new_uuid
        end
        it "has the correct status_name" do
          updated_order["role1"].first.status_name.should == :done
        end
        it "is assigned to a batch" do
          updated_order["role1"].first.batch.should == batch
        end
        it "has the correst status " do
          new_status ||= order.status
          updated_order.status.should == new_status
        end
      end
      context "add failed item" do
        let(:item_parameters) { { :items => { "role1"=> { new_uuid => { "event" => :fail } } } } }

        it "has a new role" do
          updated_order.should  include("role1")
        end
        it "has the correct item"  do
          updated_order["role1"].first.uuid.should == new_uuid
        end
        it "has the correct status_name" do
          updated_order["role1"].first.status_name.should == :failed
        end

        it "has the correst status " do
          new_status ||= order.status
          updated_order.status.should == new_status
        end
      end
      context "add cancelled item" do
        let(:item_parameters) { { :items => { "role1" => {  new_uuid => { "event" => :cancel } } } } }
        it "has a new role" do
          updated_order.should  include("role1")
        end
        it "has the correct item"  do
          updated_order["role1"].first.uuid.should == new_uuid
        end
        it "has the correct status_name" do
          updated_order["role1"].first.status_name.should == :cancelled
        end

        it "has the correst status " do
          new_status ||= order.status
          updated_order.status.should == new_status
        end
      end
    end

    shared_examples_for "updating item" do |role, item_event, new_item_status, event=nil, new_status=nil|
    include_context "order updated"
    let(:parameters) do
      item_parameters.tap do |h|
        h[:event] = event if event
      end
    end
    context "#{item_event} #{role} item#{ event and "set send #{event}"}" do
      let(:item_parameters) { { :items => { role => { "0" => { "event" => item_event,
                                                               "batch" => batch} } } } }
      it "has the correct item"  do
        updated_order.should include(role)
      end
      it "'s item has the correct status_name" do
        updated_order[role].first.status.should == new_item_status
      end
      it "is assigned correctly to a batch" do
        updated_order[role].first.batch.should == batch
      end
      it "has the correct status " do
        new_status ||= order.status
        updated_order.status.should == new_status
      end
    end
    end
    shared_examples_for "not updating item" do |role, item_event, event=nil, new_status=nil|
    include_context "order updated"
    let(:parameters) { item_parameters.tap { |h| h[:event] = event if event } }
    context "#{item_event} #{role} item#{ event and "set send #{event}"}" do
      let(:item_parameters) { { :items => { role => { "0" => { "event" => item_event } } } } }
      it "raise an error"  do
        expect { updated_order }.to raise_error StateMachine::InvalidTransition
      end
    end
    end

    shared_examples_for "update underlying items" do |event=nil, new_status=nil|
      #it_behaves_like "not updating items" do
      it_behaves_like "updating item", "pending", "start", "in_progress", event, new_status
      it_behaves_like "updating item", "in_progress", "complete", "done", event, new_status
      it_behaves_like "updating item", "in_progress", "fail", "failed", event, new_status
      it_behaves_like "updating item", "in_progress", "cancel", "cancelled", event, new_status
      it_behaves_like "not updating item", "done", "start", "in_progress"
    end


    shared_examples_for "order updaded" do
      include_context "update object"
      it_behaves_like "an action"
      context "order is already saved" do
        let!(:result) { action.call }
        it "updates the order" do |status_name|

          result.should be_a Hash

          updated_order = result[:order]
          update_order.should == expected_order
        end
      end
    end

    shared_context "order updated" do
      let(:order) { Organization::Order.new(order_creation_parameter.merge(:items => order_items)).tap do |order|
          post_init_event.each { |event| order.public_send("#{event}!")  }
        end
      }
      let(:result) { action.call }
      let(:updated_order) { result[:order] }
    end

    shared_context "updating variable" do |key, value|
      include_context "order updated"
      context key do
        let(:parameters) { { key => value  } }
        it do
          updated_order[key].should == value
        end

      end
    end
    shared_context "not updating variable" do |key|
      include_context "order updated"
      context key do
        let(:parameters) { { key => "dummy value"  } }
        it do
          expect { updated_order[key] }.to raise_error
        end

      end
    end

    shared_context "updating states" do
      it_behaves_like "updating variable", :pipeline, "new pipeline "
      it_behaves_like "updating variable", :parameters, {:my_param => :new_value }
      it_behaves_like "updating variable", :state, {:my_state => :new_value }
    end

    shared_context "changing status" do |event, new_status|
      context event do
        include_context "order updated"
        let(:parameters) { {:event => event} }
        it "set new status" do
          updated_order.status.should == new_status
        end
      end
    end
    shared_context "not changing status" do |event|
      context event do
        include_context "order updated"
        let(:parameters) { {:event => event} }
        it "fail" do
          expect {
            updated_order
          }.to raise_error StateMachine::InvalidTransition
        end
      end
    end

    shared_context "updatable draft order" do
      it_behaves_like "adding items"
      it_behaves_like "updating states"

      # only draft
      it_behaves_like "updating variable", :cost_code, "new cost code"
      it_behaves_like "updating variable", :creator, "new user"
      it_behaves_like "updating variable", :study, "new study"

      it_behaves_like "changing status", :build, "pending"
      it_behaves_like "adding items", :build, "pending"
      it_behaves_like "not changing status", :start
      it_behaves_like "changing status", :fail, "failed"
    end

    shared_context "updatable pending order" do
      it_behaves_like "adding items"
      it_behaves_like "updating states"

      it_behaves_like "not updating variable", :cost_code, "new cost code"
      it_behaves_like "not updating variable", :creator, "new user"
      it_behaves_like "not updating variable", :study, "new study"

      it_behaves_like "changing status", :start, "in_progress"
      it_behaves_like "adding items", :start, "in_progress"
      it_behaves_like "not changing status", :build
      it_behaves_like "changing status", :fail, "failed"
    end

    shared_context "frozen order" do
      pending "not implemented, we can't constraint to do update item depending on order state" do
        it_behaves_like "not updating item", "pending", "start"
        it_behaves_like "updating item", "pending", "start", "in_progress"
      end


      it_behaves_like "not updating variable", :cost_code, "new cost code"
      it_behaves_like "not updating variable", :creator, "new user"
      it_behaves_like "not updating variable", :study, "new study"
      pending do
        it_behaves_like "not updating variable", :pipeline, "new pipeline"
      end

      it_behaves_like "not changing status", :build
      it_behaves_like "not changing status", :start
      it_behaves_like "not changing status", :complete
    end

    describe UpdateOrder do
      context "valid calling context" do
        let!(:store) { Persistence::Store.new() }
        include_context("for application",  "Test search creation")
        let(:batch) { mock(:batch) }
        let(:action) { described_class.new(:store => store , :user => user, :application => application) do |action, session|

            action.order = order
            action.ostruct_update(parameters)
          end
        }

        context do
          subject { action }
          it_behaves_like "an action"
        end

        context "saves stubbed" do
          include_context "create object" # stub all save


          context "draft order" do
            include_context "draft order"
            context "with no items" do
              include_context "no items"
              it_behaves_like "updatable draft order"

            end

            context "with items" do
              include_context "items"
              it_behaves_like "updatable draft order"
              it_behaves_like "update underlying items"
            end
          end

          context "pending order" do
            let(:order_creation_parameter) { {} }
            let(:post_init_event) { [ "build"]}
            context "with no items" do
              include_context "no items"
              it_behaves_like "updatable pending order"

            end

            context "with items" do
              include_context "items"
              it_behaves_like "updatable pending order"
              it_behaves_like "update underlying items"
            end
          end

          context "order in  progress" do
            let(:order_creation_parameter) { {} }
            let(:post_init_event) { %w[build start] }
            include_context "items"
            it_behaves_like "adding items"
            it_behaves_like "updating states"

            it_behaves_like "not updating variable", :cost_code, "new cost code"
            it_behaves_like "not updating variable", :creator, "new user"
            it_behaves_like "not updating variable", :study, "new study"

            it_behaves_like "changing status", :complete, "completed"
            it_behaves_like "adding items", :complete, "completed"
            it_behaves_like "not changing status", :build
            it_behaves_like "changing status", :fail, "failed"

          end

          context "failed order" do
            let(:order_creation_parameter) { {} }
            let(:post_init_event) { %w[build fail] }
            include_context "items"
            it_behaves_like "frozen order"
          end
          context "order done" do
            let(:order_creation_parameter) { {} }
            let(:post_init_event) { %w[build start complete] }
            include_context "items"
            it_behaves_like "frozen order"
          end
        end
      end
    end
  end
end

__END_OF_update_order_spec.rb__
filename='spec/actions/update_plate_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_update_plate_spec.rb__ > $filename
# Spec requirements
require 'actions/spec_helper'
require 'actions/action_examples'
require 'laboratory/plate_and_gel_shared'

# Model requirements
require 'lims/core/actions/update_plate'
require 'lims/core/laboratory/plate'

module Lims::Core
  module Laboratory
    describe UpdatePlate do
      include_context "for application", "test update tube rack"
      include_context "plate or gel factory"
      include_context "create object"

      let!(:store) { Persistence::Store.new }
      let(:plate) { new_plate_with_samples }
      let(:number_of_rows) { 8 }
      let(:number_of_columns) { 12 }
      let(:plate_type) { "new plate type" }
      let(:aliquot_type) { "DNA" }
      let(:aliquot_quantity) { 5 }
      let(:action) {
        described_class.new(:store => store, :user => user, :application => application) do |a,s|
          a.plate = plate 
          a.aliquot_type = aliquot_type
          a.aliquot_quantity = aliquot_quantity
          a.type = plate_type
        end
      }
      let(:result) { action.call }
      let(:updated_plate) { result[:plate] }
      subject { action }

      it_behaves_like "an action"

      it "updates the plate" do
        result.should be_a Hash
        updated_plate.should be_a Laboratory::Plate
      end

      it "changes the plate type" do
        updated_plate.type.should == plate_type        
      end

      it "changes aliquots type in each well" do
        updated_plate.each do |well|
          well.each do |aliquot|
            aliquot.type.should == aliquot_type
          end
        end
      end

      it "changes aliquots quantity in each well" do
        updated_plate.each do |well|
          well.each do |aliquot|
            aliquot.quantity.should == aliquot_quantity
          end
        end
      end
    end
  end
end
__END_OF_update_plate_spec.rb__
filename='spec/actions/update_tube_rack_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_update_tube_rack_spec.rb__ > $filename
# Spec requirements
require 'actions/spec_helper'
require 'actions/action_examples'
require 'laboratory/tube_rack_shared'

# Model requirements
require 'lims/core/actions/update_tube_rack'
require 'lims/core/laboratory/tube_rack'

module Lims::Core
  module Laboratory
    describe UpdateTubeRack do
      include_context "for application", "test update tube rack"
      include_context "tube_rack factory"
      include_context "create object"

      let!(:store) { Persistence::Store.new }
      let(:tube_rack) { new_tube_rack_with_samples }
      let(:number_of_rows) { 8 }
      let(:number_of_columns) { 12 }
      let(:aliquot_type) { "DNA" }
      let(:aliquot_quantity) { 5 }
      let(:action) {
        described_class.new(:store => store, :user => user, :application => application) do |a,s|
          a.tube_rack = tube_rack 
          a.aliquot_type = aliquot_type
          a.aliquot_quantity = aliquot_quantity
        end
      }
      let(:result) { action.call }
      let(:updated_tube_rack) { result[:tube_rack] }
      subject { action }

      it_behaves_like "an action"

      it "updates the tube rack" do
        result.should be_a Hash
        updated_tube_rack.should be_a Laboratory::TubeRack
      end

      it "changes aliquots type in each tube" do
        updated_tube_rack.each do |tube|
          tube.each do |aliquot|
            aliquot.type.should == aliquot_type
          end
        end
      end

      it "changes aliquots quantity in each tube" do
        updated_tube_rack.each do |tube|
          tube.each do |aliquot|
            aliquot.quantity.should == aliquot_quantity
          end
        end
      end
    end
  end
end
__END_OF_update_tube_rack_spec.rb__
filename='spec/actions/update_tube_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_update_tube_spec.rb__ > $filename
# Spec requirements
require 'actions/spec_helper'
require 'actions/action_examples'
require 'laboratory/tube_shared'

# Model requirements
require 'lims/core/actions/update_tube'
require 'lims/core/laboratory/tube'

module Lims::Core
  module Laboratory
    describe UpdateTube do
      context "valid calling context" do
        include_context "for application", "test update tube" 
        include_context "tube factory"
        include_context "create object"

        let!(:store) { Persistence::Store.new() }
        let(:tube_type) { "Eppendorf" }
        let(:tube_max_volume) { 2 }
        let(:aliquot_type) { "DNA" }
        let(:aliquot_quantity) { 5 }
        let(:action) { 
          described_class.new(:store => store, :user => user, :application => application) do |a,s|
            a.tube = new_tube_with_samples
            a.aliquot_type = aliquot_type
            a.aliquot_quantity = aliquot_quantity
            a.type = tube_type
            a.max_volume = tube_max_volume
          end
        }
        let(:result) { action.call }
        let(:updated_tube) { result[:tube] }
        subject { action }

        it_behaves_like "an action"

        it "updates the tube" do
          result.should be_a Hash
          updated_tube.should be_a Laboratory::Tube
        end

        it "changes the aliquots type" do
          updated_tube.each do |aliquot|
            aliquot.type.should == aliquot_type
          end
        end

        it "changes the aliquots quantity" do
          updated_tube.each do |aliquot|
            aliquot.quantity.should == aliquot_quantity
          end
        end
        
        it "changes the tube type" do
          updated_tube.type.should == tube_type
        end

        it "changes the tube max volume" do
          updated_tube.max_volume.should == tube_max_volume
        end
      end
    end
  end
end
__END_OF_update_tube_spec.rb__
filename='spec/laboratory/aliquot_shared.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_aliquot_shared.rb__ > $filename
module Lims::Core
  module Laboratory
    shared_context "aliquot factory" do
      def new_sample(i=1, j=1)
        Sample.new(["Sample", i, j].compact.conjoin(" ", "/"))
      end

      def new_aliquot(i=nil, j=nil, q=nil)
        sample = Sample
        aliquot = Aliquot.new(:sample => new_sample(i,j))
        aliquot.quantity = q if q
        aliquot
      end
    end
  end
end
__END_OF_aliquot_shared.rb__
filename='spec/laboratory/aliquot_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_aliquot_spec.rb__ > $filename
# Spec requirements
require 'laboratory/spec_helper'

# Model requirements
require 'lims/core/laboratory/aliquot'

module Lims::Core::Laboratory
  describe Aliquot do
    context "to be valid" do
      let (:aliquot) {Aliquot.new(:quantity=>10)}

      xit "must have everything needed" do
        aliquot.valid?.should be_true
      end
      it "must have an owner"
      xit "must have a type" do
        # this is an example to mostly test yard-rspec.
        aliquot.type=nil
        aliquot.valid?.should be_false
      end
      it "must have a quantity" do
      pending "we might use nil quanity for unknown quantity" do
        aliquot.quantity=nil
        aliquot.valid?.should eq false
      end
      end

      xit "must have a positive quantity" do
        aliquot.quantity=-5
        aliquot.valid?.should  be_false
      end

      it "should be in a receptacle"
      it "can't be empty"
    end

    context "a solvent" do
      subject{ described_class.new(:type => Aliquot::Solvent) }
      its(:dimension) { should == Aliquot::Volume }
      its(:unit) { should == "ul" }

      context "with a quantity" do
        subject{ described_class.new(:type => Aliquot::Solvent, :quantity => 1000) }
        it "can have a quantity added to it " do
          subject.increase_quantity(50).should == 1050
        end
        it "can have an unknown quantity added to it " do
          subject.increase_quantity(nil).should == 1000
        end
      end

    end
      context "without a quantity" do
        it "can have a quantity added to it " do
          subject.increase_quantity(50).should == 50
        end
        it "can have an unknown quantity added to it " do
          subject.increase_quantity(nil).should == nil
        end
      end

    context "#add_quantity" do
      it do
        Aliquot::add_quantity(nil,nil).should == nil
        Aliquot::add_quantity(nil,2).should == 2
        Aliquot::add_quantity(1,2).should == 3
      end
    end
  end
end
__END_OF_aliquot_spec.rb__
filename='spec/laboratory/container_examples.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_container_examples.rb__ > $filename
# Spec requirements
require 'laboratory/spec_helper'

shared_examples "a container" do |contained|
  it { subject.should respond_to(:each) }
  it { subject.should respond_to(:size) }

  it "has many 'contained' objects" do
    subject.each do |content|
      content.should be_a(contained) unless content.nil?
    end
  end
end

module Lims::Core::Laboratory
  shared_examples "a hash" do
    it "can be indexed with a symbol " do
      subject[:B3].should be_a(container)
      aliquot = Aliquot.new
      subject[:B3] << aliquot
      subject[:B3].should include(aliquot)
    end

    it "can be indexed with a string " do
      subject["B3"].should be_a(container)
      aliquot = Aliquot.new
      subject["B3"] << aliquot
      subject["B3"].should include(aliquot)
    end

    it "raise an exception if container doesn't exit" do
      expect { subject[:A13] }.to raise_error(error_container_does_not_exists)
      expect { subject[:I1] }.to raise_error(error_container_does_not_exists)
    end

    it "has a key for each wells" do
      subject.keys.size.should be == size
      subject.keys.should include("B3")
      subject.keys.should include("H12")
      subject.keys.should_not include("L2")
    end

    it { should respond_to(:values) }

    it "iterates as a Hash" do
      subject.each_with_index do |w, index|
        index.should be_a(String)
        w.should be_a(container)
      end
    end

    it "'s values can be iterated an modified" do
      aliquot= Aliquot.new
      index = 3
      subject.values.each_with_index do |w, i|
        if i == index
          w << aliquot
          break
        end
      end
      subject[index].should include(aliquot)
    end

    it "can be iterated with index (String)" do
      aliquot= Aliquot.new
      index = "A3"
      subject.each_with_index do |w, i|
        if i == index
          w << aliquot
          break
        end
      end
      subject[index].should include(aliquot)
    end
  end
end
__END_OF_container_examples.rb__
filename='spec/laboratory/flowcell_examples.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_flowcell_examples.rb__ > $filename
# Spec requirements
require 'spec_helper'

# Model requirements

require 'lims/core/laboratory/flowcell'

shared_context "flowcell factory" do
  def new_flowcell_with_samples(sample_nb=5)
    Flowcell.new.tap do |flowcell|
      flowcell.each_with_index do |lane, i|
        1.upto(sample_nb) do |j|
          lane << Aliquot.new(:sample => "Sample ##{i+1}/#{j+1}")
        end
      end
    end
  end

  def new_empty_flowcell
    Flowcell.new
  end
end
__END_OF_flowcell_examples.rb__
filename='spec/laboratory/flowcell_shared.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_flowcell_shared.rb__ > $filename
# Spec requirements
require 'spec_helper'

# Model requirements

require 'lims/core/laboratory/flowcell'
require 'facets/array'

module Lims::Core
  module Laboratory
    shared_context "flowcell factory" do
      def new_flowcell_with_samples(sample_nb=5)
        Flowcell.new(:number_of_lanes => number_of_lanes).tap do |flowcell|
          flowcell.each_with_index do |lane, i|
            1.upto(sample_nb) do |j|
              lane <<  new_aliquot(i,j)
            end
          end
        end
      end

      def new_empty_flowcell
        Flowcell.new(:number_of_lanes => number_of_lanes)
      end

      def new_sample(i=1, j=1)
        Sample.new(["Sample", i, j].compact.conjoin(" ", "/"))
      end

      def new_aliquot(i=nil, j=nil)
        sample = Sample
          Aliquot.new(:sample => new_sample(i,j))
      end

    end
  end
end
__END_OF_flowcell_shared.rb__
filename='spec/laboratory/flowcell_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_flowcell_spec.rb__ > $filename
# Spec requirements
require 'laboratory/spec_helper'
require 'laboratory/located_examples'
require 'laboratory/container_examples'
require 'laboratory/labellable_examples'

require 'laboratory/receptacle_examples'

# Model requirements
require 'lims/core/laboratory/flowcell'

module Lims::Core::Laboratory
  shared_examples "contains lanes" do
    its(:size) { should eq(number_of_lanes) } 
    it_behaves_like "a container", Flowcell::Lane

    it "can have a content put in one lane" do
      aliquot = Aliquot.new
      subject[0] << aliquot
      subject[0].should include(aliquot)
    end
    it "can have an aliquot added in one lane" do
      aliquot = Aliquot.new
      subject[0] << aliquot
      subject[0].should include(aliquot)
    end
  end

  describe Flowcell  do
    subject {described_class.new(:number_of_lanes => number_of_lanes)}
    
    context "of type MiSeq" do
      let (:number_of_lanes) { 1 }
      it_behaves_like "located" 
      it_behaves_like "contains lanes"
      it_behaves_like "labellable"
    end

    context "of type HiSeq" do
      let (:number_of_lanes) { 8 }
      it_behaves_like "located" 
      it_behaves_like "contains lanes"
      it_behaves_like "labellable"
    end
  end
  
  describe Flowcell::Lane  do
    it "belongs  to a flowcell "  # contained by a flowcell
    it_behaves_like "receptacle"
  end
end
__END_OF_flowcell_spec.rb__
filename='spec/laboratory/gel_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_gel_spec.rb__ > $filename
# Spec requirements
require 'laboratory/located_examples'
require 'laboratory/container_examples'
require 'laboratory/labellable_examples'

require 'laboratory/receptacle_examples'

# Model requirements
require 'lims/core/laboratory/gel'

module Lims::Core::Laboratory
  shared_examples "a valid gel" do
    it_behaves_like "located" 
    context "contains windows" do
      it_behaves_like "a container", Gel::Window
    end
  end

  describe Gel do
    context "with 12x8 windows" do
      let(:number_of_rows) { 8 }
      let(:number_of_columns) { 12}
      let(:size) { number_of_rows*number_of_columns }

      let(:container) { Gel::Window }
      let(:error_container_does_not_exists) { Gel::IndexOutOfRangeError }

      subject { described_class.new(:number_of_columns => number_of_columns, :number_of_rows =>number_of_rows) }

      its(:number_of_rows) {should == number_of_rows }
      its(:number_of_columns) { should == number_of_columns }
      its(:size) { should eq(size) }

      it_behaves_like "a valid gel"
      it_behaves_like "a hash"
      it_behaves_like "labellable"
    end
  end

  describe Gel::Window do
    it "belongs to a gel "  # contained by a gel
    it_behaves_like "receptacle"
  end
end
__END_OF_gel_spec.rb__
filename='spec/laboratory/label_examples.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_label_examples.rb__ > $filename
# Spec requirements
require 'laboratory/spec_helper'


# Expect a create_parameters hash
shared_examples "label" do 
    context "to be valid" do
      let(:excluded_parameters) { [] }
      subject { described_class.new(create_parameters - excluded_parameters) }
      it  "valid" do
        subject.valid?.should == true
      end
      it_behaves_like "requires", :value

      its(:type) { should be_a(String) }
    end
end

__END_OF_label_examples.rb__
filename='spec/laboratory/labellable_examples.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_labellable_examples.rb__ > $filename
# Spec requirements
require 'laboratory/spec_helper'

shared_examples "labellable" do
  it "has one labels"
  it "has many labels"

  it "can have a label added to it"
  it "can be found by one of it's labels"
  it "can be found by many of it's labels"

end

__END_OF_labellable_examples.rb__
filename='spec/laboratory/labellable_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_labellable_spec.rb__ > $filename
# Spec requirements
require 'laboratory/spec_helper'
require 'laboratory/located_examples'
require 'laboratory/container_examples'
require 'laboratory/labellable_examples'

require 'laboratory/receptacle_examples'
# Model requirements
require 'lims/core/laboratory/labellable'

module Lims::Core::Laboratory
  shared_examples_for "label creator" do |type, klass|
    it "should create the correct label class" do
      described_class.new(:type => type).should be_a klass
    end
  end
  describe Labellable  do
    let(:barcode) { mock(:barcode) do |barcode| 
        barcode.stub(:value) {"12345"}
        barcode.stub(:type) { "barcode 1d" }
      end
    }
    context "to be valid" do
      let(:name) { "my plate" }
      let(:type) { "plate" }
      let(:create_parameters) { {:name => name, :type => type} }
      let(:excluded_parameters) { [] }
      subject { described_class.new(create_parameters - excluded_parameters) }
      it  "valid" do
        subject.valid?.should == true
      end
      it_behaves_like "requires", :name
      it_behaves_like "requires", :type
    end
    it_behaves_like "a container", Labellable::Label
    context "a hash" do

      it "can be indexed with a string " do
        subject["barcode"].should be_nil
        subject["barcode"] = barcode
        subject["barcode"].should == barcode
      end

      it { should respond_to(:values) }
      it { should respond_to(:positions) }

      it "iterates as a Hash" do
        subject.each do |position, label|
          index.should be_a(String)
          label.should be_a(Labellable::Label)
        end
      end

      it "can be iterated with index (String)" do
        subject["barcode"] = barcode
        subject.each_with_index do |label, position|
        end
      end
    end
  end

  describe Labellable::Label do
    it_behaves_like "label creator", "sanger-barcode", SangerBarcode
    it_behaves_like "label creator", "2d-barcode", Barcode2D
    it_behaves_like "label creator", "ean13-barcode", EAN13Barcode
  end
end
__END_OF_labellable_spec.rb__
filename='spec/laboratory/lane_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_lane_spec.rb__ > $filename
# Spec requirements
require 'laboratory/spec_helper'
require 'laboratory/receptacle_examples'

# Model requirements
require 'lims/core/laboratory/flowcell'

module Lims::Core::Laboratory
  describe Flowcell::Lane  do
    it "belongs  to a flowcell "  # contained by a flowcell
    it_behaves_like "receptacle"
  end
end
__END_OF_lane_spec.rb__
filename='spec/laboratory/located_examples.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_located_examples.rb__ > $filename
# Spec requirements
require 'laboratory/spec_helper'

shared_examples "located" do
  it "requires a location"
end

shared_examples "movable" do
  it "be moved from somewhere to somewhere else"
end

# Maybe not needed
shared_examples "has an history location" do
  it "has a location at a specific time"
end
__END_OF_located_examples.rb__
filename='spec/laboratory/oligo_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_oligo_spec.rb__ > $filename
# Spec requirements
require 'laboratory/spec_helper'

# Model requirements
require 'lims/core/laboratory/oligo'

module Lims::Core::Laboratory
  describe Oligo do
    let(:sequence_1) { "AAA" }
    let(:sequence_2) { "CCCT" }
    context "to be valid" do
      pending "validation not implemented yet" do
        it "requires a sequence" do
          Oligo.new(:sequence => "")
          Oligo.valid?.should == false
        end

        it "require a valid sequence" do
          Oligo.new("ABC")
          Oligo.valid?.should == false
        end
      end
    end
    context "#string behavior" do
      subject { Oligo.new(sequence_1) }

      it "should be displayed its sequence" do
        subject.to_s.should == sequence_1.to_s
        STDOUT.should_receive(:write).with(sequence_1)
        print subject.to_s

      end

      it "should be compared to its sequence" do
        subject.should == sequence_1
      end

      its(:size) { should == sequence_1.size }
    end

    it "should compare sequences" do
      Oligo.new(sequence_1).should == Oligo.new(sequence_1)
      Oligo.new(sequence_1).should_not == Oligo.new(sequence_2)
    end
  end
end

__END_OF_oligo_spec.rb__
filename='spec/laboratory/plate_and_gel_shared.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_plate_and_gel_shared.rb__ > $filename
# Spec requirements
require 'spec_helper'
require 'laboratory/aliquot_shared'

# Model requirements

require 'lims/core/laboratory/plate'
require 'facets/array'

module Lims::Core
  module Laboratory
    shared_context "plate or gel factory" do
      include_context "aliquot factory"

      def new_plate_with_samples(sample_nb=5, quantity=nil)
        new_plate_or_gel_with_samples(Plate, sample_nb, quantity)
      end

      def new_gel_with_samples(sample_nb=5, quantity=nil)
        new_plate_or_gel_with_samples(Gel, sample_nb, quantity)
      end

      def new_plate_or_gel_with_samples(asset_to_create, sample_nb, volume=100, quantity=nil)
        asset_to_create.new(:number_of_rows => number_of_rows, :number_of_columns => number_of_columns).tap do |asset|
          asset.each_with_index do |w, i|
            1.upto(sample_nb) do |j|
              w <<  new_aliquot(i,j,quantity)
            end
            w << Aliquot.new(:type => Aliquot::Solvent, :quantity => volume) if volume
          end
        end
      end

      def new_empty_plate
        new_empty_plate_or_gel(Plate)
      end

      def new_empty_gel
        new_empty_plate_or_gel(Gel)
      end

      def new_empty_plate_or_gel(asset_to_create)
        asset_to_create.new(:number_of_rows => number_of_rows, :number_of_columns => number_of_columns)
      end

    end
  end
end
__END_OF_plate_and_gel_shared.rb__
filename='spec/laboratory/plate_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_plate_spec.rb__ > $filename
# Spec requirements
require 'laboratory/spec_helper'
require 'laboratory/located_examples'
require 'laboratory/container_examples'
require 'laboratory/labellable_examples'

require 'laboratory/receptacle_examples'
# Model requirements
require 'lims/core/laboratory/plate'

module Lims::Core::Laboratory
  shared_examples "a valid plate" do
    it_behaves_like "located" 
    context "contains wells" do
      it_behaves_like "a container", Plate::Well
    end
  end

  describe Plate  do
    context "with 12x8 wells" do
      let(:number_of_rows) { 8 }
      let(:number_of_columns) { 12}
      let(:size) { number_of_rows*number_of_columns }

      let(:container) { Plate::Well }
      let(:error_container_does_not_exists) { Plate::IndexOutOfRangeError }

      subject { described_class.new(:number_of_columns => number_of_columns, :number_of_rows =>number_of_rows) }

      its(:number_of_rows) {should == number_of_rows }
      its(:number_of_columns) { should == number_of_columns }
      its(:size) { should eq(size) }

      it_behaves_like "a valid plate"
      it_behaves_like "a hash"
      it_behaves_like "labellable"

      it "sets a type" do
        type = mock(:type)
        subject.type = type
        subject.type.should == type
      end

      context "#pools" do
        it "each well belongs to only one pool" do
          pools = subject.pools
          pools.should_not be_empty

          # wells appears only once
          pooled_wells = pools.values.flatten(1)
          pooled_wells.size.should == pooled_wells.uniq.size
        end

        it "each well belong to at least one pool" do
          pooled_wells = Set.new(subject.pools.values.flatten(1))

          subject.each_with_index do |well, name|
            next if well.empty?
            pooled_wells.should include(name)
          end

        end

        context "#stub" do
          it "are arranged by column" do
            pools = subject.pools

            pools.size.should == subject.number_of_columns
            pools.keys.should == [1, 2, 3, 4, 5, 6, 7 ,8, 9 , 10, 11, 12]
            pools[1].should == %w(A1 B1 C1 D1 E1 F1 G1 H1)
          end
        end
      end

    end
  end

  describe Plate::Well  do
    it "belongs  to a plate "  # contained by a plate
    it_behaves_like "receptacle"
  end
end
__END_OF_plate_spec.rb__
filename='spec/laboratory/receptacle_examples.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_receptacle_examples.rb__ > $filename
# Spec requirements
require 'laboratory/spec_helper'

Lab=Lims::Core::Laboratory

shared_examples "add contents" do
  it "can have a chemical content added to it" do
    expect {
      subject << [ Lab::Aliquot.new(:type => 1), Lab::Aliquot.new(:type => "new type") ]
    }.to change{subject.size}.by(2)
  end

  it "can have an aliquot added to it" do
    expect {
      subject << Lab::Aliquot.new(:type => "new type")
    }.to change{subject.size}.by(1)
  end
end


shared_examples "can have a fraction of its content taken" do |volume, aliquot_quantity, fraction_taken, volume_in_target, aliquot_quantity_in_target, volume_left, aliquot_quantity_left |
  context "take #{fraction_taken} of #{volume}/#{aliquot_quantity}" do
    subject { described_class.new.tap { |r| r << Lab::Aliquot.new(:quantity=>aliquot_quantity) << Lab::Aliquot.new(:quantity => volume, :type => Lab::Aliquot::Solvent) } } 
    let(:aliquot) { subject[0] }
    let!(:taken ) { described_class.new << subject.take_fraction(fraction_taken) }

    it "leaves the correct volume" do
      subject.volume.should == volume_left
    end
    it "leaves the correct aliquot quantity" do
      aliquot.quantity.should == aliquot_quantity_left
    end

    it "gives the correct volume to the target" do
      taken.volume.should == volume_in_target
    end
    it "gives the correct aliquot quantity to the target" do
      taken[0].quantity.should == aliquot_quantity_in_target
    end
  end
end

shared_examples "can have its content taken" do |volume, aliquot_quantity, amount_taken, volume_in_target, aliquot_quantity_in_target, volume_left, aliquot_quantity_left |
  context "take #{amount_taken} of #{volume}/#{aliquot_quantity}" do
    subject { described_class.new.tap { |r| r << Lab::Aliquot.new(:quantity=>aliquot_quantity) << Lab::Aliquot.new(:quantity => volume, :type => Lab::Aliquot::Solvent) } } 
    let(:aliquot) { subject[0] }
    let!(:taken ) { described_class.new << subject.take_amount(amount_taken) }

    it "leaves the correct volume" do
      subject.volume.should == volume_left
    end

    it "leaves the correct aliquot quantity" do
      aliquot.quantity.should == aliquot_quantity_left
    end

    it "gives the correct volume to the target" do
      taken.volume.should == volume_in_target
    end

    it "gives the correct aliquot quantity to the target" do
      taken[0].quantity.should == aliquot_quantity_in_target
    end
  end
end

shared_examples "receptacle" do
  context "when first created" do
    its(:size) { should eq(0) }
    it { should be_empty}
    include_examples "add contents"
  end

  context "#take" do
    context "unknown volume" do
      context "known amount" do
        it_behaves_like "can have its content taken", nil, 5, 20.0, nil, nil, nil, 5
        it_behaves_like "can have its content taken", nil, nil, 20.0, nil, nil, nil, nil
      end
      context "unknow amount" do
        it_behaves_like "can have its content taken", nil, 5, nil, nil, nil, nil, 5
        it_behaves_like "can have its content taken", nil, nil, nil, nil, nil, nil, nil
      end
    end
    context "known volume" do
      context "known amount" do
        it_behaves_like "can have its content taken", 100, 5, 20.0, 20, 1, 80, 4
        it_behaves_like "can have its content taken", 100, nil, 20.0, 20, nil, 80, nil
        it_behaves_like "can have its content taken", 100, 5, 200.0, 100, 5, 0, 0 
      end
      context "unknow amount" do
        it_behaves_like "can have its content taken", 100, 5, nil, nil, nil, 100,5
        it_behaves_like "can have its content taken", 100, nil, nil, nil, nil, 100, nil
      end
    end
  end
  context "#take fraction" do
    context "unknown volume" do
      context "known amount" do
        it_behaves_like "can have a fraction of its content taken", nil, 5, 0.20, nil, 1, nil, 4
        it_behaves_like "can have a fraction of its content taken", nil, nil, 0.20, nil, nil, nil, nil
      end
      context "unknow amount" do
        it_behaves_like "can have a fraction of its content taken", nil, 5, nil, nil, nil, nil, 5
        it_behaves_like "can have a fraction of its content taken", nil, nil, nil, nil, nil, nil, nil
      end
    end
    context "known volume" do
      context "known amount" do
        it_behaves_like "can have its content taken", 100, 5, 20.0, 20, 1, 80, 4
        it_behaves_like "can have its content taken", 100, nil, 20.0, 20, nil, 80, nil
      end
      context "unknow amount" do
        it_behaves_like "can have its content taken", 100, 5, nil, nil, nil, 100, 5
        it_behaves_like "can have its content taken", 100, nil, nil, nil, nil, 100, nil
      end
    end
  end



  context "with a chemical content" do
    let(:aliquot) { Lab::Aliquot.new(:quantity=>5) }
    let(:solvent) {  Lab::Aliquot.new(:quantity => 100, :type => Lab::Aliquot::Solvent) }
    subject { described_class.new.tap { |r| r << solvent << aliquot } }

    include_examples "add contents"
    it { should_not be_empty }

    it "has the correct volume" do
      subject.volume.should == solvent.quantity
    end

    it "has the correct quantitie" do
      subject.quantity(Lab::Aliquot::Volume).should == 100
      subject.quantity(Lab::Aliquot::AmountOfSubstance).should == 5
    end

    context  "can be mixed" do
      context "with a substance" do
        before(:all) { subject << Lab::Aliquot.new(:quantity => 5) }
        it { subject.quantity(Lab::Aliquot::AmountOfSubstance).should == 10 }
        it { subject.quantity(Lab::Aliquot::Volume).should == 100 }
      end
    end
    context "with a solvent" do
      before(:all) { (subject << Lab::Aliquot.new(:quantity => 50, :type => Lab::Aliquot::Solvent)) }
      it { subject.quantity(Lab::Aliquot::AmountOfSubstance).should == 5 }
      it { subject.quantity(Lab::Aliquot::Volume).should == 150 }
    end

  end

  context "with an unknow quantity" do
    let(:aliquot) { Lab::Aliquot.new(:quantity=>5) }
    let(:solvent) {  Lab::Aliquot.new(:quantity => 100, :type => Lab::Aliquot::Solvent) }
    subject { described_class.new.tap { |r| r << aliquot } }
    its(:volume) { should == nil }
  end

end

__END_OF_receptacle_examples.rb__
filename='spec/laboratory/sample_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_sample_spec.rb__ > $filename
# Spec requirements
require 'laboratory/spec_helper'
require 'organization/releasable_examples'

# Model requirements
require 'lims/core/laboratory/sample'

module Lims::Core::Laboratory
  describe Sample do
    it_behaves_like "releasable"

    context "to be valid" do
      it "requires a name" do
        sample = described_class.new
        sample.valid?.should eq false
      end
    end
  end
end

__END_OF_sample_spec.rb__
filename='spec/laboratory/sanger_barcode_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_sanger_barcode_spec.rb__ > $filename
# Spec requirements
require 'laboratory/spec_helper'
require 'laboratory/label_examples'

# Model requirements
require 'lims/core/laboratory/sanger_barcode'

module Lims::Core::Laboratory

  describe SangerBarcode do
    let(:create_parameters) { {:value => "hello"} }
    it_behaves_like "label"
  end
end
__END_OF_sanger_barcode_spec.rb__
filename='spec/laboratory/spec_helper.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_spec_helper.rb__ > $filename
require 'spec_helper'
require 'lims-core/laboratory'


__END_OF_spec_helper.rb__
filename='spec/laboratory/spin_column_shared.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_spin_column_shared.rb__ > $filename
# Model requirements
require 'lims/core/laboratory/spin_column'

module Lims::Core
  module Laboratory
    shared_context "spin column factory" do
      def new_spin_column_with_samples(sample_nb=5, quantity=100, volume=100)
        SpinColumn.new.tap do |spin_column|
          1.upto(sample_nb) do |i|
            spin_column <<  new_aliquot(quantity, i)
          end
          spin_column << L::Aliquot.new(:type => L::Aliquot::Solvent, :quantity => volume) if volume
        end
      end

      def new_empty_spin_column
        SpinColumn.new
      end
    end
  end
end
__END_OF_spin_column_shared.rb__
filename='spec/laboratory/spin_column_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_spin_column_spec.rb__ > $filename
# Spec requirements
require 'laboratory/located_examples'
require 'laboratory/receptacle_examples'
require 'laboratory/labellable_examples'

# Model requirement
require 'lims/core/laboratory/spin_column'

module Lims::Core::Laboratory
  describe SpinColumn  do
    it_behaves_like "located" 
    it_behaves_like "receptacle"
    it_behaves_like "labellable"
  end
end
__END_OF_spin_column_spec.rb__
filename='spec/laboratory/tag_group_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_tag_group_spec.rb__ > $filename
# Spec requirements
require 'laboratory/spec_helper'
require 'laboratory/container_examples'

# Model requirements
require 'lims/core/laboratory/tag_group'

module Lims::Core::Laboratory
  describe TagGroup do
    let(:sequence_1) { "AAA" }
    let(:sequence_2) { "CCC" }
    let(:oligo_1) { Oligo.new(sequence_1) }
    let(:oligo_2) { Oligo.new(sequence_2) }
    context "to be valid" do
      pending "validation not implemented yet" do
      it "should contains each oligo sequence once. " do
        2.times { subject << oligo_1 }

        subject.valid?.should be_false
      end
      it "requires a name" do
        described_class.new(:name => nil)
      end
      end
    end
    context "empty" do
      subject { described_class.new(:name => "my group") }
      it_behaves_like "a container", Oligo
      it "can have an oligo added" do
        expect { subject << Oligo.new(sequence_1)}.to change { subject.size }.by(1)
      end
    end
    context "non empty" do
      subject { described_class.new(:name => "my group").tap do |g|
        g << Oligo.new(sequence_1) << Oligo.new(sequence_2)
      end
      }

      it_behaves_like "a container", Oligo
      it "can have an oligo added" do
        expect { subject << oligo_1 << oligo_2 }
      end

      it "can be indexed" do
        subject[0].should == oligo_1
        subject[1].should == oligo_2
      end
    end
  end
end

__END_OF_tag_group_spec.rb__
filename='spec/laboratory/tube_rack_shared.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_tube_rack_shared.rb__ > $filename
# Spec requirements
require 'spec_helper'
require 'laboratory/aliquot_shared'

# Model requirements

require 'lims/core/laboratory/tube_rack'
require 'facets/array'

module Lims::Core
  module Laboratory
    shared_context "tube_rack factory" do
      include_context "aliquot factory"

      def new_tube_rack_with_samples(sample_nb=5, quantity=nil, volume=100)
        TubeRack.new(:number_of_rows => number_of_rows, :number_of_columns => number_of_columns).tap do |tube_rack|
          tube_rack.each_with_index do |slot, i|
            tube = Tube.new
            tube_rack[i] = tube
            1.upto(sample_nb) do |j|
              tube <<  new_aliquot(i,j,quantity)
            end
            tube << Aliquot.new(:type => Aliquot::Solvent, :quantity => volume) if volume
          end
        end
      end

      def new_empty_tube_rack()
        TubeRack.new(:number_of_rows => number_of_rows, :number_of_columns => number_of_columns)
      end

      def new_empty_tube()
        Tube.new
      end

    end
  end
end
__END_OF_tube_rack_shared.rb__
filename='spec/laboratory/tube_rack_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_tube_rack_spec.rb__ > $filename
require 'laboratory/container_examples'
require 'laboratory/labellable_examples'
require 'lims/core/laboratory/tube_rack'

module Lims::Core::Laboratory
  shared_examples "a tube rack hash" do
    it "can be indexed with a symbol " do
      subject[:B5].should be_a(Tube)
    end

    it "can be indexed with a string " do
      subject["B5"].should be_a(Tube)
    end

    it "raise an exception if the position in the rack doesn't exit" do
      expect { subject[:A13] }.to raise_error(TubeRack::IndexOutOfRangeError)
      expect { subject[:I1] }.to raise_error(TubeRack::IndexOutOfRangeError)
    end

    it "has a key for each position" do
      subject.keys.size.should be == size
      subject.keys.should include("B3")
      subject.keys.should include("H12")
      subject.keys.should_not include("L2")
    end

    it { should respond_to(:keys) }
    it { should respond_to(:values) }

    it "iterates as a Hash" do
      subject.each_with_index do |element, index|
        index.should be_a(String)
        [NilClass, Tube].should include(element.class)
      end
    end
  end


  describe TubeRack do
    context "with 12x8 available placements for tubes" do
      let(:number_of_rows) { 8 }
      let(:number_of_columns) { 12 }
      let(:size) { number_of_rows * number_of_columns }
      subject { 
        described_class.new(:number_of_columns => number_of_columns, :number_of_rows => number_of_rows).tap do |rack|
          rack[:A1] = Lims::Core::Laboratory::Tube.new
          rack[:B5] = Lims::Core::Laboratory::Tube.new
          rack[:E3] = Lims::Core::Laboratory::Tube.new
        end
      }

      its(:number_of_rows) { should == number_of_rows }
      its(:number_of_columns) { should == number_of_columns }

      it "cannot store something else than tubes" do
        expect { subject[:A2] = "something" }.to raise_error(ArgumentError)
      end

      it "cannot replace a tube if it already exists in the rack" do
        expect { subject[:A1] = Lims::Core::Laboratory::Tube.new }.to raise_error(TubeRack::RackPositionNotEmpty)
      end

      it_behaves_like "a container", Tube
      it_behaves_like "a tube rack hash"
      it_behaves_like "labellable"
    end
  end
end

__END_OF_tube_rack_spec.rb__
filename='spec/laboratory/tube_shared.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_tube_shared.rb__ > $filename
# Spec requirements
require 'spec_helper'

# Model requirements

require 'lims/core/laboratory/tube'
require 'facets/array'

L=Lims::Core::Laboratory
def new_sample(i=1)
  L::Sample.new(:name => "Sample ##{i}")
end

def new_aliquot(q=1, i=1)
  aliquot = L::Aliquot.new(:sample => new_sample(i), :quantity => q)
end


module Lims::Core
  module Laboratory
    shared_context "tube factory" do
      def new_tube_with_samples(sample_nb=5, quantity=100, volume=100)
        Tube.new.tap do |tube|
          1.upto(sample_nb) do |i|
            tube <<  new_aliquot(quantity, i)
          end
          tube << L::Aliquot.new(:type => L::Aliquot::Solvent, :quantity => volume) if volume
        end
      end

      def new_empty_tube
        Tube.new
      end
    end
  end
end
__END_OF_tube_shared.rb__
filename='spec/laboratory/tube_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_tube_spec.rb__ > $filename
# Spec requirements
require 'laboratory/spec_helper'
require 'laboratory/located_examples'
require 'laboratory/receptacle_examples'
require 'laboratory/labellable_examples'

# Model requirements
require 'lims/core/laboratory/tube'

module Lims::Core::Laboratory
  describe Tube  do

    def self.it_can_assign(attribute)
      it "can assign #{attribute}" do
        value = mock(:attribute)
        subject.send("#{attribute}=", value)
        subject.send(attribute).should == value
      end
    end

    it_behaves_like "located" 
    it_behaves_like "receptacle"
    it_behaves_like "labellable"

    it_can_assign :type
    it_can_assign :max_volume

    it "sets a type" do
      type = mock(:type)
      subject.type = type
      subject.type.should == type
    end

    it "sets a max volume" do
      max_volume = mock(:max_volume)
      subject.max_volume = max_volume
      subject.max_volume.should == max_volume
    end
  end
end
__END_OF_tube_spec.rb__
filename='spec/organization/batch_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_batch_spec.rb__ > $filename
# Spec requirements
require 'spec_helper'

# Model requirements
require 'lims/core/organization/batch'

module Lims::Core::Organization
  describe Batch do
    def self.it_has_a(attribute, type=nil)
      it "responds to #{attribute}" do
        subject.should respond_to(attribute)
      end

      if type
        it "'s #{attribute} is a #{type}" do
          subject.send(attribute).andtap { |v| v.should be_a(type) }
        end
      end
    end

    def self.it_can_assign(attribute)
      it "can assign #{attribute}" do
        value = mock(:attribute)
        subject.send("#{attribute}=", value)
        subject.send(attribute).should == value
      end
    end

    it_can_assign :process
    it_has_a :process

    it "sets a process" do
      process = mock(:process)
      subject.process = process
      subject.process.should == process
    end
  end
end
__END_OF_batch_spec.rb__
filename='spec/organization/order/item_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_item_spec.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2 spell:spelllang=en 
require 'spec_helper'

require 'lims-core/organization/order/item'

module Lims
  module Core
    module Organization
      describe Order::Item do
        #== Macro ====
        def self.it_has_a(attribute, type=nil)
          it "responds to #{attribute}" do
            subject.should respond_to(attribute)
          end

          if type
            it "'s #{attribute} is a #{type}" do
              subject.send(attribute).andtap { |v| v.should be_a(type) }
            end
          end
        end

        def self.it_needs_a(attribute)
          context "is invalid" do
            subject {  described_class.new(creation_parameters.except(attribute)) }
            it { subject.valid?.should == false }
            context "after validation" do
              before { subject.validate }
              it "#{attribute} is required" do
                subject.errors[attribute].should_not be_empty
              end
            end
          end
        end

        def self.it_can_not_be_modified(attribute)
          it "can't assign #{attribute}" do
            begin
              subject.should_not respond_to("#{attribute}=")
            rescue
              # if responds to, try to call the 
              expect {
                subject.send("#{attribute}=", nil)
              }.to raise_error(NoMethodError)
            end
          end
        end
        #=== End of Macro ===
	

				it_has_a :status
				it_has_a :iteration
				it_has_a :uuid
        it_has_a :batch

				it "is initially in a pending status" do
					subject.status.should == "pending"
				end

				# state machine
				context "pending" do
					its(:iteration) { should == 0 }
					it "can be started" do
						subject.start.should == true
					end

					context "source" do
						before(:each) { subject.complete }
						its(:status) { should == "done" }
						its(:done?) { should be_true }
						its(:iteration) { should == 0 }

						it_can_not_be_modified :iteration
						it_can_not_be_modified :uuid

						it "can't no be reset" do
							subject.reset.should == false
						end
					end

					context "in progress" do
						before(:each) { subject.start }
						its(:status) { should == "in_progress" }
						its(:iteration) { should == 1 }

						it "can fail" do
							subject.fail.should == true
						end

						it "can succeed" do
							subject.complete.should == true
						end

						context "failed" do
							before(:each) { subject.fail }
							it "can be reset to pending" do
								subject.reset.should == true
							end

							it "can be restarted" do
								subject.start.should == true
							end
							it "increments iteration when started" do
								subject.reset
								subject.start
								subject.iteration.should == 2
							end

							it "increments when restarted" do
								subject.start
								subject.iteration.should == 2
							end
						end
					end

          context "unused" do
            before(:each) { 
              subject.complete
              subject.unuse
            }
            its(:status) { should == "unused" }
            its(:unused?) { should be_true }
            its(:iteration) { should == 0 }

            it_can_not_be_modified :iteration
            it_can_not_be_modified :uuid

            it "can't be reset" do
              subject.reset.should == false
            end
          end
        end
      end
    end
  end
end

__END_OF_item_spec.rb__
filename='spec/organization/order_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_order_spec.rb__ > $filename
require 'spec_helper'

require 'lims-core/organization/order'


share_examples_for "terminal state" do
  it "can' be started" do
    subject.start.should == false
  end
  it "can' be completed" do
    subject.complete.should == false
  end
  it "can' be failed" do
    subject.fail.should == false
  end            
  it "can' be built" do
    subject.build.should == false
  end

  it "can't be completed" do
    subject.complete.should == false
  end
end

shared_examples_for "unmodifiable states" do
  it_can_not_be_modified :creator
  it_can_not_be_modified :study
  it_can_not_be_modified :cost_code
end

module Lims
  module Core
    module Organization
      describe Order do
        #== Macro ====
        def self.it_has_a(attribute, type=nil)
          it "responds to #{attribute}" do
            subject.should respond_to(attribute)
          end

          if type
            it "'s #{attribute} is a #{type}" do
              subject.send(attribute).andtap { |v| v.should be_a(type) }
            end
          end
        end

        def self.it_needs_a(attribute)
          context "is invalid" do
            subject {  Order.new(creation_parameters.except(attribute)) }
            it { subject.valid?.should == false }
            context "after validation" do
              before { subject.validate }
              it "#{attribute} is required" do
                subject.errors[attribute].should_not be_empty
              end
            end
          end
        end

        def self.it_can_assign(attribute)
          it "can assign #{attribute}" do
            value = mock(:attribute)
            subject.send("#{attribute}=", value)
            subject.send(attribute).should == value
          end
        end

        def self.it_can_not_be_modified(attribute)
          it "can't assign #{attribute}" do
            begin
              subject.should_not respond_to("#{attribute}=")
            rescue
              # if responds to, try to call the 
              expect {
                subject.send("#{attribute}=", mock(:attribute))
              }.to raise_error(NoMethodError)
            end
          end
        end
        #=== End of Macro ===

        let(:creator) { mock(:creator) }
        let(:pipeline) { "pipeline 1" }
        let(:parameters) { { :read_lenght => 26 } }
        let(:study) { mock(:study) }
        let(:cost_code) { "cost code" }
        let(:items) { {:source => mock(:source) } }
        let!(:creation_parameters) { { :creator => creator,
          :pipeline => pipeline,
          :parameters => parameters,
          :study => study, 
          :cost_code => cost_code }}

        # todo validation depends of the state
        context "to be valid" do
          it_needs_a :creator
          it_needs_a :pipeline
          it_needs_a :study
          it_needs_a :cost_code

          it "has private items" do
            subject.should_not respond_to(:items)
          end
        end

        it_has_a :creator
        it_has_a :pipeline
        it_has_a :parameters, Hash
        it_has_a :study
        it_has_a :status, String
        it_has_a :state, Hash
        it_has_a :cost_code, String

        it_can_not_be_modified :items

        context "valid" do
          subject { Order.new (creation_parameters) }
          its(:valid?) { should be_true }


          its(:status) { should == "draft" }

          context "#items" do
            let (:item) { mock(:item) }
            let(:role) { "role#1" }
            it "can have item added to it" do
              subject.add_item(role, item)
              subject[role].should include(item)
            end

            it "returns nil for unknown role" do
              subject[:unknown_role].should == nil
            end

            it "accepts items at initialization" do
              order = Order.new(creation_parameters.merge(:items => { role => [item] }))
              order[role].should include(item)
            end

            it "can have a source added" do
              subject.add_source(:source, source_uuid="source_id")
              subject[:source].first.tap do |source|

                source.done?.should == true
                source.uuid.should == source_uuid
                source.iteration.should == 0
              end
            end

            it "can have a target added" do
              subject.add_target(:target)
              subject[:target].first.tap do |target|
                target.pending?.should == true
                target.iteration.should == 0
              end
            end

            context "with items" do
              let (:item2) { mock(:item2) }
              let (:item3) { mock(:item3) }
              let(:role2) { "role#2" }
              let(:items) { { role => [item], role2 => [item2, item3] } }
              subject { Order.new(creation_parameters.merge(items)) }
              it "can iterate over all the items" do
                roles = []
                items = []
                subject.should respond_to(:each) do |l_role, l_item|
                  l_item.should == case l_role
                                   when role then [item]
                                   when role2 then [item2, item3]
                                   else raise "Wrong Role"
                                   end
                end
              end
            end

          end
          context "draft" do
            its(:status) { should == "draft" }
            it "can be built" do
              subject.build.should == true
            end

            it"can be cancelled" do
              subject.cancel.should == true
            end

            it "can' be started" do
              subject.start.should == false
            end
            it"can be cancelled" do
              subject.cancel.should == true
            end
            it "can't be finished" do
              subject.complete.should == false
            end

            it_can_assign :creator
            it_can_assign :study
            it_can_assign :cost_code

            it "can have a creator set" do
              creator = mock(:creator)
              (subject.creator=creator).should == creator
            end

            it "can have a study set" do
              study = mock(:study)
              (subject.study=study).should == study
            end

            context "-> pending" do
              before(:each) { subject.build }
              it_can_not_be_modified :creator
              it_can_not_be_modified :study
              it_can_not_be_modified :cost_code

              its(:status) { should == "pending" }

              it"can be cancelled" do
                subject.cancel.should == true
              end

              it "can be started" do
                subject.start.should == true
              end

              it "can't be finished" do
                subject.complete.should == false
              end

              context "-> in progress" do
                before(:each) { subject.start }
                its(:status) { should == "in_progress" }
                it_behaves_like "unmodifiable states"

                it"can be cancelled" do
                  subject.cancel.should == true
                end

                context "-> cancelled" do
                  before(:each) { subject.cancel }
                  it_behaves_like "terminal state"
                end


                it "can' be started" do
                  subject.start.should == false
                end

                it "can be failed" do
                  subject.fail.should == true
                  subject.status.should == "failed"
                end

                context "-> failed" do
                  before(:each) { subject.fail }
                  it_behaves_like "terminal state"
                end

                it "can be completed" do
                  subject.complete.should == true
                  subject.status.should == "completed"
                end
                context "-> completed" do
                  before(:each) { subject.complete }
                  it_behaves_like "terminal state"
                end
              end
            end
          end
        end
      end
    end
  end
end

__END_OF_order_spec.rb__
filename='spec/organization/releasable_examples.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_releasable_examples.rb__ > $filename
# Spec requirements
require 'organization/spec_helper'

module Lims::Core::Organization
  shared_examples "releasable" do

    xit "is releasable" do
       described_class.new.is_a?(Releasable).should eq true
    end

    context "when it's been released" do
      it "should have an accession number"
      it "can have it's accession number modified"
    end

    context "to be releasable" do
      it "has data release attribute set"
      it "has data release policy set"
    end

    context  "to be sent to EBI" do
      it "corresponds to  an XML file" #might be xml generator 
    end
  end
end
__END_OF_releasable_examples.rb__
filename='spec/organization/spec_helper.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_spec_helper.rb__ > $filename
require 'spec_helper'
require 'lims-core/organization'


__END_OF_spec_helper.rb__
filename='spec/organization/study_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_study_spec.rb__ > $filename
# Spec requirements
require 'organization/spec_helper'
require 'organization/releasable_examples'

# Model requirements
require 'lims/core/organization/study'

module Lims::Core::Organization
  describe Study do
    it_behaves_like "releasable"
  end
end

__END_OF_study_spec.rb__
filename='spec/persistence/identity_map_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_identity_map_spec.rb__ > $filename
# Spec requirements
require 'persistence/spec_helper'

# Model requirements
require 'lims/core/persistence/identity_map'




module Lims::Core::Persistence
  class IdentityMapClass
    include IdentityMap
  end

  describe IdentityMapClass do

    context "with a object mapped to an id" do
      let(:id) { 1 }
      let(:object) { "Object 1" }
      before {subject.map_id_object(id,object) }

      it "must find the object by id" do
        subject.object_for(id).should == object
      end

      it "must find the id by object" do
        subject.id_for(object).should == id
      end

      it "must fail when mapping another object with the same id" do
        expect { subject.map_id_object(id, "Object #2") }.to raise_error(IdentityMap::DuplicateIdError)
      end

      it "must fail when mapping another id with the same object" do
        expect { subject.map_id_object(2, object) }.to raise_error(IdentityMap::DuplicateObjectError)
      end

      it "must not fail when mapping it again" do
        expect { subject.map_id_object(id, object) }.not_to raise_error(IdentityMap::DuplicateError)
      end

      it "must yield the object" do
        subject.object_for(id) do |o|
          o.should == object
        end
      end

      it "must not yield if the object can't be found" do
        subject.object_for("wrong id") do |o|
          raise "not found"
        end.should be_nil
      end
    end
  end
end
__END_OF_identity_map_spec.rb__
filename='spec/persistence/logger/plate_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_plate_spec.rb__ > $filename
# Spec requirements
require 'persistence/logger/spec_helper'
require 'laboratory/plate_and_gel_shared'

# Model requirements
require 'lims/core/persistence/logger/store'

module Lims::Core::Persistence
  describe Logger::Store do
    include_context "plate or gel factory"
    context "initialized with a logger" do
      let(:number_of_rows) { 1 }
      let(:number_of_columns) { 2 }
      let (:logger) { ::Logger.new(\$stdout) }
      let(:plate) { new_plate_with_samples(2) }
      subject { described_class.new(logger) }
      it "should log plate to stdout" do
        logger.should_receive(:send).with(:info, 'Lims::Core::Laboratory::Plate: {:type=>nil, :number_of_rows=>1, :number_of_columns=>2}')
        logger.should_receive(:send).with(:info, '- [0] - Lims::Core::Laboratory::Aliquot: {:sample=>"Sample A1/1", :tag=>nil, :quantity=>nil, :type=>nil}')
        logger.should_receive(:send).with(:info, '- [0] - Lims::Core::Laboratory::Aliquot: {:sample=>"Sample A1/2", :tag=>nil, :quantity=>nil, :type=>nil}')
        logger.should_receive(:send).with(:info, '- [1] - Lims::Core::Laboratory::Aliquot: {:sample=>"Sample A2/1", :tag=>nil, :quantity=>nil, :type=>nil}')
        logger.should_receive(:send).with(:info, '- [1] - Lims::Core::Laboratory::Aliquot: {:sample=>"Sample A2/2", :tag=>nil, :quantity=>nil, :type=>nil}')
        subject.with_session do |session|
          session << plate
        end
      end
    end
  end
end
__END_OF_plate_spec.rb__
filename='spec/persistence/logger/spec_helper.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_spec_helper.rb__ > $filename
require 'spec_helper'


__END_OF_spec_helper.rb__
filename='spec/persistence/logger/store_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_store_spec.rb__ > $filename
# Spec requirements
require 'persistence/logger/spec_helper'

# Model requirements
require 'logger'
require 'lims/core/persistence/logger/store'

module Lims::Core::Persistence
  P = self
  module Logger
    class Array < P::Persistor
      include Persistor
    end
  end
  describe Logger::Store do
    def self.initialized_with_a_logger(method)
      context "initialized with a logger" do
        let (:logger) { ::Logger.new(\$stdout) }
        subject { described_class.new(logger, method) }
        it "should log objects to stdout" do
          logger.should_receive(:send).with(method, '["A1", "A2", "B1", "B2"]')
          subject.with_session do |session|
            session << %w(A1 A2 B1 B2)
          end
        end
      end
    end
    def self.initialized_with_an_IO(io)
    context "initialized to stdout" do
      subject { described_class.new(io) }
      it "should log objects to stdout" do
        io.should_receive(:write)
        subject.with_session do |session|
          session << %w(A1 A2 B1 B2)
        end
      end
    end
    end
    initialized_with_an_IO(STDOUT)
    initialized_with_an_IO(STDERR)

    initialized_with_a_logger(:info)
    initialized_with_a_logger(:warn)
  end
end
__END_OF_store_spec.rb__
filename='spec/persistence/message_bus_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_message_bus_spec.rb__ > $filename
require 'lims-core/persistence/message_bus'

module Lims::Core
  module Persistence
    describe MessageBus do
      context "to be valid" do
        let(:url) { "amqp://user:password@localhost:55672" }
        let(:exchange_name) { "exchange_name" }
        let(:durable) { true }
        let(:prefetch_number) { 30 }
        let(:bus_settings) { {"url" => url, "exchange_name" => exchange_name, "durable" => durable, "prefetch_number" => prefetch_number} }

        it "requires a RabbitMQ host" do
          described_class.new(bus_settings - ["url"]).valid?.should == false
        end

        it "requires an exchange name" do
          described_class.new(bus_settings - ["exchange_name"]).valid?.should == false
        end

        it "requires the durable option" do
          described_class.new(bus_settings - ["durable"]).valid?.should == false
        end

        it "requires a prefetch number" do
          described_class.new(bus_settings - ["prefetch_number"]).valid?.should == false
        end

        it "requires correct settings" do
          described_class.new(bus_settings).valid?.should == true
        end

        it "requires correct settings to connect to the message bus" do
          expect do
            described_class.new(bus_settings - ["url"]).connect
          end.to raise_error(MessageBus::InvalidSettingsError)
        end

        it "requires an exchange to publish a message" do
          expect do
            described_class.new(bus_settings).publish("message")
          end.to raise_error(MessageBus::ConnectionError)
        end
      end
    end
  end 
end

__END_OF_message_bus_spec.rb__
filename='spec/persistence/resource_shared.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_resource_shared.rb__ > $filename
shared_examples_for "storable resource" do |model_name, tables|
  context "created and added to session" do
    tables.each do |table_name, count| 
      it "modifies the #{table_name} table" do
        expect do
          store.with_session { |s| s << subject }
        end.to change { db[table_name].count }.by(count)
      end
    end
    it "should be reloadable" do
      resource_id = save(subject)
      store.with_session do |session|
        session.public_send(model_name)[resource_id].should == subject
      end
    end

    context "created but not added to a session" do
      tables.each do |table_name, count| 
        it "should not be saved" do
          expect do 
            store.with_session { |_| subject }
          end.to change{ db[tables].count }.by(0)
        end 
      end
    end
  end
end
__END_OF_resource_shared.rb__
filename='spec/persistence/search_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_search_spec.rb__ > $filename
# Spec requirements
require 'persistence/spec_helper'

# Model requirements
require 'lims-core/persistence/search'

module Lims::Core
  module Persistence
    describe Search do
      context "to be valid" do
        let(:filter) { mock(:filter) }
        let(:model) { mock(:model) }
        let(:description) { mock(:description) }
        let(:create_parameters) {  {:description => description, :filter => filter, :model => model } }

        it "requires a model" do
          described_class.new(create_parameters - [:model]).valid?.should == false
        end

        it "requires a filter" do
          described_class.new(create_parameters - [:filter]).valid?.should == false
        end
        
        it "requires a description" do
          described_class.new(create_parameters - [:description]).valid?.should == false
        end

        it "requires a model and a filter" do
          described_class.new(create_parameters).valid?.should == true
        end
      end
    end
  end
end
__END_OF_search_spec.rb__
filename='spec/persistence/sequel/batch_filter_shared.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_batch_filter_shared.rb__ > $filename
require 'persistence/sequel/spec_helper'
require 'lims/core/persistence/batch_filter'
require 'persistence/sequel/order_lookup_filter_shared'

module Lims::Core
  shared_examples_for "batch filtrable" do
    include_context "with saved orders"
    let(:description) { "lookup resources by batch" }
    let(:filter) { Persistence::BatchFilter.new(criteria) }
    let(:search) { Persistence::Search.new(:model => model, :filter => filter, :description => description) }

    context "get resources by batch uuid criteria" do
      let(:criteria) { {:batch => {"uuid" => batch_uuids[1]}} }
      it "finds resources" do
        store.with_session do |session|
          results = search.call(session)
          all = results.slice(0, 1000).to_a
          all.size.should == 1 
          all.should include(session['22222222-1111-0000-0000-000000000000'])
          all.first.should be_a(model)
        end
      end
    end

    context "get resources by multiple batch uuid criteria" do
      let(:criteria) { {:batch => {"uuid" => batch_uuids}} }
      it "finds resources" do
        store.with_session do |session|
          results = search.call(session)
          all = results.slice(0, 1000).to_a
          all.size.should == uuids.size 

          uuids.each do |uuid|
            all.should include(session[uuid])
          end

          all.each do |resource|
            resource.should be_a(model)
          end
        end
      end
    end
  end
end
__END_OF_batch_filter_shared.rb__
filename='spec/persistence/sequel/batch_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_batch_spec.rb__ > $filename
# Spec requirements
require 'persistence/sequel/spec_helper'
require 'persistence/sequel/store_shared'

# Model requirements
require 'lims/core/persistence/sequel/store'
require 'lims/core/organization/batch'

module Lims::Core
  describe Organization::Batch do
    include_context "prepare tables" 
    let(:db) { ::Sequel.sqlite('') }
    let(:store) { Persistence::Sequel::Store.new(db) }
    before(:each) { prepare_table(db) }


    context "create a batch and add it to session" do
      it "modifies the batches table" do
        expect do
          store.with_session { |s| s << subject }
        end.to change { db[:batches].count }.by(1)
      end

      it "reloads the batch" do
        batch_id = save(subject)
        store.with_session do |session|
          batch = session.batch[batch_id]
          batch.should eq(session.batch[batch_id])
        end
      end
    end


    context "create a batch but don't add it to a session" do
      it "is not saved" do
        expect do 
          store.with_session { |_| subject }
        end.to change{ db[:batches].count }.by(0)
      end 
    end
  end
end
__END_OF_batch_spec.rb__
filename='spec/persistence/sequel/flowcell_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_flowcell_spec.rb__ > $filename
# Spec requirements
require 'persistence/sequel/spec_helper'

require 'laboratory/flowcell_shared'
require 'persistence/resource_shared'
require 'persistence/sequel/store_shared'
require 'persistence/sequel/page_shared'
require 'persistence/sequel/multi_criteria_filter_shared'

# Model requirements
require 'lims/core/persistence/sequel/store'
require 'lims/core/laboratory/flowcell'

module Lims::Core
  shared_context "already created flowcell" do
    let(:aliquot) { new_aliquot }
    before (:each) do
      store.with_session { |session| session << new_empty_flowcell.tap {|_| _[0] << aliquot} }
    end
    let(:flowcell_id) { store.with_session { |session| @flowcell_id = last_flowcell_id(session) } }

    context "when modified within a session" do
      before do
        store.with_session do |s|
          flowcell = s.flowcell[flowcell_id]
          flowcell[0].clear
          flowcell[1]<< aliquot
        end
      end
      it "should be saved" do
        store.with_session do |session|
          f = session.flowcell[flowcell_id]
          f[7].should be_empty
          f[1].should == [aliquot]
          f[0].should be_empty
        end
      end
    end
    context "when modified outside a session" do
      before do
        flowcell = store.with_session do |s|
          s.flowcell[flowcell_id]
        end
        flowcell[0].clear
        flowcell[1]<< aliquot
      end
      it "should not be saved" do
        store.with_session do |session|
          f = session.flowcell[flowcell_id]
          f[7].should be_empty
          f[1].should be_empty
          f[0].should == [aliquot]
        end
      end
    end
  end

  describe "Sequel#Flowcell " do
    include_context "prepare tables"
    let(:db) { ::Sequel.sqlite('') }
    let(:store) { Persistence::Sequel::Store.new(db) }
    let(:hiseq_number_of_lanes) { 8 }
    let(:miseq_number_of_lanes) { 1 }
    before (:each) { prepare_table(db) }

    include_context "flowcell factory"

    def last_flowcell_id(session)
      session.flowcell.dataset.order_by(:id).last[:id]
    end

    # execute tests with miseq flowcell
    context "miseql"  do
    let(:number_of_lanes) { miseq_number_of_lanes }
      subject { new_flowcell_with_samples(3) }
      it_behaves_like "storable resource", :flowcell, {:flowcells => 1, :lanes => 1*3 }

      pending "only works for hiseq"  do
        include_context "already created flowcell"
      end
    end

    # execute tests with hiseq flowcell
    context "hiseq"  do
    let(:number_of_lanes) { hiseq_number_of_lanes }

      subject { new_flowcell_with_samples(3) }
      it_behaves_like "storable resource", :flowcell, {:flowcells => 1, :lanes => 8*3 }
      include_context "already created flowcell"
    end

    context do
    let(:number_of_lanes) { hiseq_number_of_lanes }
    let(:constructor) { lambda { |*_| new_flowcell_with_samples } }
    it_behaves_like "paginable resource", :flowcell
    it_behaves_like "filtrable", :flowcell
    end
  end
end
__END_OF_flowcell_spec.rb__
filename='spec/persistence/sequel/gel_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_gel_spec.rb__ > $filename
# Spec requirements
require 'persistence/sequel/spec_helper'

require 'laboratory/plate_and_gel_shared'
require 'persistence/resource_shared'
require 'persistence/sequel/store_shared'
require 'persistence/sequel/label_filter_shared'
require 'persistence/sequel/batch_filter_shared'
require 'persistence/sequel/order_lookup_filter_shared'
require 'persistence/sequel/multi_criteria_filter_shared'

# Model requirement
require 'lims/core/laboratory/gel'

module Lims::Core
  describe "Persistence#Sequel#Gel" do
    include_context "sequel store"
    include_context "plate or gel factory"

    def last_gel_id(session)
      session.gel.dataset.order_by(:id).last[:id]
    end

    context "8*12 Gel" do
      # Set default dimension to create a plate
      let(:number_of_rows) { 8 }
      let(:number_of_columns) { 12 }
      let(:expected_plate_size) { number_of_rows*number_of_columns }

      context do
        subject { new_gel_with_samples(3) }
        it_behaves_like "storable resource", :gel, {:gels => 1, :windows =>  8*12*3 }
      end

      context "already created gel" do
        let(:aliquot) { new_aliquot }
        before (:each) do
          store.with_session { |session| session << new_empty_gel.tap {|_| _[0] << aliquot} }
        end
        let(:gel_id) { store.with_session { |session| @gel_id = last_gel_id(session) } }

        context "when modified within a session" do
          before do
            store.with_session do |s|
              gel = s.gel[gel_id]
              gel[0].clear
              gel[1]<< aliquot
            end
          end
          it "should be saved" do
            store.with_session do |session|
              f = session.gel[gel_id]
              f[7].should be_empty
              f[1].should == [aliquot]
              f[0].should be_empty
            end
          end
        end
        context "when modified outside a session" do
          before do
            gel = store.with_session do |s|
              s.gel[gel_id]
            end
            gel[0].clear
            gel[1]<< aliquot
          end
          it "should not be saved" do
            store.with_session do |session|
              f = session.gel[gel_id]
              f[7].should be_empty
              f[1].should be_empty
              f[0].should == [aliquot]
            end
          end
        end
        context "should be deletable" do
          before {
            # add some aliquot to the windows
            store.with_session do |session|
            gel = session.gel[gel_id]
            1.upto(10) { |i|  3.times { |j| gel[i] <<  new_aliquot(i,j) } }
            end
          }

          def delete_gel
            store.with_session do |session|
              gel = session.gel[gel_id]
              session.delete(gel)
            end
          end

          it "deletes the gel row" do
            expect { delete_gel }.to change { db[:gels].count}.by(-1)
          end

          it "deletes the window rows" do
            expect { delete_gel }.to change { db[:windows].count}.by(-31)
          end
        end

        context "#lookup" do
          let(:model) { Laboratory::Gel }
          # These uuids match the uuids defined for the order items 
          # in order_lookup_filter_shared.
          let!(:uuids) {
            ['11111111-2222-0000-0000-000000000000', 
             '22222222-1111-0000-0000-000000000000',
             '00000000-3333-0000-0000-000000000000'].tap do |uuids|
               uuids.each_with_index do |uuid, index|
                 store.with_session do |session|
                   gel =  new_empty_gel.tap { |gel| gel[index] << new_aliquot}
                   session << gel
                   ur = session.new_uuid_resource_for(gel)
                   ur.send(:uuid=, uuid)
                 end
               end
             end
          }

          context "by label" do
            let!(:uuid) {
              store.with_session do |session|
                gel = session.gel[gel_id]
                session.uuid_for!(gel)
              end
            }
            it_behaves_like "labels filtrable"
          end

          context "by order" do
            it_behaves_like "orders filtrable"
          end

          context "by batch" do
            it_behaves_like "batch filtrable"
          end
        end
      end

      context do
        let(:constructor) { lambda { |*_| new_empty_gel } }
        it_behaves_like "paginable resource", :gel
        it_behaves_like "filtrable", :gel
      end
    end
  end
end
__END_OF_gel_spec.rb__
filename='spec/persistence/sequel/label_filter_shared.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_label_filter_shared.rb__ > $filename
# Spec requirements
require 'persistence/sequel/spec_helper'

require 'lims/core/persistence/label_filter'

module Lims::Core

  shared_examples_for "labels filtrable" do
    context "with a label" do
      let(:label_position) { "front barcode" }
      let(:label_value) { "01234" }
      let(:label) { Laboratory::SangerBarcode.new(:value => label_value) }
      let!(:labellable) { 
        store.with_session do |session|
          session << labellable = Laboratory::Labellable.new(:name => uuid, :type => "resource")
          labellable[label_position] = label
          labellable
        end
      }

      let!(:labellable_resource) { store.with_session { |s| s[uuid] } }
      it "find the resource by label value"  do
        filter = Persistence::LabelFilter.new(:label => {:value => label_value})
        search = Persistence::Search.new(:model => labellable_resource.class , :filter => filter, :description => "lookup plate by label value")

        store.with_session do |session|
          results = search.call(session)
          all = results.slice(0,1000).to_a
          all.size.should == 1
          all.first.should == labellable_resource
        end
      end
      it "find the resource by label position" do
        filter = Persistence::LabelFilter.new(:label => {:position => label_position})
        search = Persistence::Search.new(:model => labellable_resource.class, :filter => filter, :description => "lookup plate by label value")

        store.with_session do |session|
          results = search.call(session)
          all = results.slice(0,1000).to_a
          all.size.should == 1
          all.first.should == labellable_resource
        end
      end
    end
  end
end
__END_OF_label_filter_shared.rb__
filename='spec/persistence/sequel/labellable_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_labellable_spec.rb__ > $filename
# Spec requirements
require 'persistence/sequel/spec_helper'
require 'persistence/sequel/store_shared'

# Model requirements
require 'lims/core/persistence/labellable'
require 'lims/core/laboratory/sanger_barcode'

module Lims::Core
  describe Laboratory::Labellable do
    include_context "sequel store"

    let(:name) { "test plate" }
    let(:type) { "plate" }
    let(:content) { { "front barcode" => Laboratory::SangerBarcode.new({ :value =>"12345ABC" }) } }
    let(:parameters) { { :name => name, :type => type, :content => content } }
    let(:labellable) { Laboratory::Labellable.new(parameters) }
    
    context "when created within a session" do
      it "should modify the labellable table" do
        expect do
          store.with_session { |session| session << labellable }
        end.to change { db[:labellables].count}.by(1)
      end
    end

    it "should save it" do
      labellable_id = save(labellable).should be_true
    end

    it "can be reloaded" do
      labellable_id = save(labellable)
      store.with_session do |session|
        loaded_labellable = session.labellable[labellable_id]
        loaded_labellable.should == labellable
        loaded_labellable.name.should == labellable.name
        loaded_labellable.type.should == labellable.type
        loaded_labellable.content.should == labellable.content
        loaded_labellable["front barcode"].should be_a(Laboratory::SangerBarcode)
      end
    end

    context "a labellable with content" do
      it "modifies the labellables table" do
        expect { save(labellable) }.to change { db[:labellables].count}.by(1)
      end
      it "modifies the labels table" do
        expect { save(labellable) }.to change { db[:labels].count}.by(1)
      end
    end
  end
end
__END_OF_labellable_spec.rb__
filename='spec/persistence/sequel/multi_criteria_filter_shared.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_multi_criteria_filter_shared.rb__ > $filename
# Spec requirements
require 'persistence/sequel/spec_helper'
require 'persistence/sequel/page_shared'

require 'lims/core/persistence/multi_criteria_filter'

module Lims::Core

shared_examples_for "filtrable" do |persistor_name|
  let(:ids) { [1, 2, 3, 4, 5, 6, 7, 8, 9, 10,  15, 17] }
  let(:filter) { Persistence::MultiCriteriaFilter.new(:id => ids) }

  let(:persistor) { store.with_session { |s| filter.call(s.public_send(persistor_name)) } }
  let(:override_resource_number) { ids.size }
  it_behaves_like "paginable", persistor_name
end

end
__END_OF_multi_criteria_filter_shared.rb__
filename='spec/persistence/sequel/oligo_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_oligo_spec.rb__ > $filename
# Spec requirements
require 'persistence/sequel/spec_helper'

require 'persistence/sequel/store_shared'

# Model requirements
require 'lims/core/persistence/sequel/store'
require 'lims/core/laboratory/oligo'

module Lims::Core

  describe Persistence::Sequel::Oligo do
    include_context "prepare tables"
    let(:db) { ::Sequel.sqlite('') }
    let(:store) { Persistence::Sequel::Store.new(db) }
    before (:each) { prepare_table(db) }

    let (:oligo) { Laboratory::Oligo.new ("AAA") }

    context "when created within a session" do
      it "should modify the  oligos table" do
        expect do
          store.with_session { |session| session << oligo }
        end.to change { db[:oligos].count}.by(1) 
      end
    end

    it "should save it" do
      oligo_id = store.with_session do |session|
        session << oligo
        lambda { session.id_for(oligo) }
      end.call 

      store.with_session do |session|
        session.oligo[oligo_id].sequence == oligo.sequence
        session.oligo[oligo_id]== oligo
      end
    end
  end
end
__END_OF_oligo_spec.rb__
filename='spec/persistence/sequel/order_lookup_filter_shared.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_order_lookup_filter_shared.rb__ > $filename
# Spec requirements
require 'persistence/sequel/spec_helper'
require 'persistence/sequel/page_shared'

require 'lims/core/persistence/multi_criteria_filter'
require 'lims/core/persistence/order_filter'

module Lims::Core
  module Persistence
    shared_context "with saved orders" do
      include_context "with saved batches"
      let(:basic_parameters) { { :creator => Organization::User.new(), :study => Organization::Study.new(), :pipeline => "testing" } }
      let(:orders) {
        # We give a different pipeline to be able to differentiate each order easily
        # and sort them
        [
          Organization::Order.new(basic_parameters.merge(:pipeline => "P1")).tap do |o|
            o.add_source("source1", "11111111-1111-0000-0000-000000000000")
            o.add_target("source2", "11111111-2222-0000-0000-000000000000")
            o.add_source("source3", "00000000-3333-0000-0000-000000000000")
            o.build!
            o.start!
          end,
          Organization::Order.new(basic_parameters.merge(:pipeline => "P2")).tap do |o|
            o.add_source("source1", "22222222-1111-0000-0000-000000000000")
            o.add_source("source2", "22222222-2222-0000-0000-000000000000")
            o.add_target("source3", "00000000-3333-0000-0000-000000000000")
            o.build!
            o.start!
          end,
          Organization::Order.new(basic_parameters.merge(:pipeline => "P3")).tap do |o|
            o.add_source("source1", "33333333-1111-0000-0000-000000000000")
            o.add_source("source2", "33333333-2222-0000-0000-000000000000")
            o.add_target("target1", "00000000-3333-0000-0000-000000000000")
            o.build!
            o.start!
            o.complete!
          end
        ]
      }
      let!(:ids) {
        orders.map do |o|
          store.with_session do |session|
            session << o
            o[:source2].first.batch = session[batch_uuids[0]] if o.pipeline == 'P1'
            o[:source1].first.batch = session[batch_uuids[1]] if o.pipeline == 'P2'
            o[:target1].first.batch = session[batch_uuids[0]] if o.pipeline == 'P3'
          end
        end
      }
    end

    shared_context "with saved batches" do
      let!(:batch_uuids) do
        ['11111111-2222-2222-3333-000000000000', '11111111-2222-2222-3333-111111111111'].tap do |uuids|
          uuids.each do |uuid|
            store.with_session do |session|
              batch = Organization::Batch.new
              session << batch
              ur = session.new_uuid_resource_for(batch)
              ur.send(:uuid=, uuid)
            end
          end
        end
      end
    end

    shared_examples_for "finding orders" do |criteria, indexes|
      let(:filter) { MultiCriteriaFilter.new(criteria)
      }
      let(:persistor) { store.with_session { |s| filter.call(s.order) } }
      context do
        it "find the right orders" do
          loaded = persistor.slice(0, orders.size).to_a.sort { |a,b| a.pipeline <=> b.pipeline }
          original = indexes.map { |i| orders[i]}.sort { |a,b| a.pipeline <=> b.pipeline }

          loaded.should == original

        end
        it "find the correct number of order" do
          persistor.count.should == indexes.size
        end
      end
    end

    shared_examples_for "searchable by item criteria" do
      context "saved orders" do
        include_context "with saved orders"

        context "lookup by one uuid" do
          it_behaves_like "finding orders", { :item => {:uuid => "11111111-2222-0000-0000-000000000000" } }, [0]
          context "find 2 orders" do
            it_behaves_like "finding orders", { :item => {:uuid => "00000000-3333-0000-0000-000000000000" } }, [0,1,2]
          end
        end

        context "lookup by role" do
          it_behaves_like "finding orders", { :item => {:role => "source3"} }, [0,1]
          it_behaves_like "finding orders", { :item => {:role => %w[source3 target1] } }, [0,1,2]
        end

        context "lookup by status" do
          it_behaves_like "finding orders", { :item => {:uuid => "00000000-3333-0000-0000-000000000000", :status => "pending" } }, [1,2]
        end

        context "lookup by role and uuid and status" do
          it_behaves_like "finding orders", { :item => { :role => "source3", :status => "pending", :uuid => "00000000-3333-0000-0000-000000000000" } }, [1]
        end

        context "mix order and items criteria" do
          it_behaves_like "finding orders", { :status => "completed", :item => { :uuid => "00000000-3333-0000-0000-000000000000" } }, [2]
        end

        context "lookup by batch assigned to order items" do
          it_behaves_like "finding orders", { :item => {:batch => {"uuid" => '11111111-2222-2222-3333-111111111111'}}}, [1] 
        end
      end
    end

    shared_examples_for "finding resources" do |uuids|
      it "finds the resource" do
        store.with_session do |session|
          results = search.call(session)
          all = results.slice(0, uuids.size).to_a
          all.size.should == uuids.size

          uuids.each do |uuid|
            all.should include(session[uuid])
          end

          all.each do |resource|
            resource.should be_a(model)
          end
        end
      end 
    end

    shared_examples_for "orders filtrable" do
      include_context "with saved orders"
      let(:description) { "lookup by order" }
      let(:filter) { Persistence::OrderFilter.new(criteria) }
      let(:search) { Persistence::Search.new(:model => model, :filter => filter, :description => description) }

      context "by order pipeline" do
        let(:criteria) { {:order => {:pipeline => "P1"}} }
        it_behaves_like "finding resources", ['11111111-2222-0000-0000-000000000000', '00000000-3333-0000-0000-000000000000'] 
      end

      context "by order status" do
        let(:criteria) { {:order => {:status => "in_progress"}} }
        it_behaves_like "finding resources", ['22222222-1111-0000-0000-000000000000','11111111-2222-0000-0000-000000000000', '00000000-3333-0000-0000-000000000000']
      end
      
      context "by order item" do
        let(:criteria) { {:order => {:item => {:status => "pending"}}} }
        it_behaves_like "finding resources", ['11111111-2222-0000-0000-000000000000']
      end

      context "by batch assigned to order items" do
        let(:criteria) { {:order => {:item => {:batch => {"uuid" => '11111111-2222-2222-3333-000000000000'}}}} }
        it_behaves_like "finding resources", ['11111111-2222-0000-0000-000000000000', '00000000-3333-0000-0000-000000000000']
      end
   end
  end
end
__END_OF_order_lookup_filter_shared.rb__
filename='spec/persistence/sequel/order_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_order_spec.rb__ > $filename
# Spec requirements
require 'persistence/sequel/spec_helper'
require 'persistence/sequel/store_shared'

require 'persistence/sequel/order_lookup_filter_shared'

# Model requirements
require 'lims/core/persistence/sequel/store'

module Lims::Core
  module Organization
    describe Order  do
      include_context "sequel store"

      def load_order(order_id)
        store.with_session do |session|
          yield( session.order[order_id])
        end
      end

      context "an empty order" do
        it "can be saved" do
          save(subject).should_not be_nil
        end

        context "being saved" do
          it "modifies the orders table" do
            expect { save(subject) }.to change { db[:orders].count }.by(1)
          end
        end
      end

      context "an order with items" do
        let(:source) { Order::Item.new }
        subject { Order.new(:items => { :source => [source]} ) }
        it "modifies the items table" do
          expect { save(subject) }.to change { db[:items].count }.by(1)
        end

        context "saved" do
          let!(:order_id) { save(subject) }
          let(:uuid_source2) { "11111111-1111-0000-0000-111111111111" }
          let(:uuid_source22) { "11111111-1111-0000-0000-222222222222" }

          it "can be reloaded" do
            store.with_session do |session|

              loaded = session.order[order_id]
              # testing object is well loaded
              loaded.should == subject

              # testing items are well loaded
              loaded[:source].should == subject[:source]
            end
          end

          it "can have empty items added" do
            load_order(order_id) do |order|
              order.add_target(:intermediate_target)
            end
            load_order(order_id) do |order|
              order[:intermediate_target].first.should be_an(Order::Item)
              order[:intermediate_target].first.status.should == "pending"
            end
          end


          it "can have non-empty items added" do
            load_order(order_id) do |order|
              order.add_source(:source2, uuid_source2)
              order.add_source(:source2, uuid_source22)
            end

            load_order(order_id) do |order|
              [uuid_source2, uuid_source22].zip(order[:source2]) do |uuid, item|
                item.done?.should == true
                item.status.should == "done"
                item.uuid.should == uuid
              end
            end

          end

          let(:long_attribute) { (1..50).inject("") { |s,i|  s+"#{i}-abcdefghi" } }
          let(:state) { {:my_state => 34, :state => :hidden, :long_attribute => long_attribute } }
          it "can its state updated with a really long state" do
            load_order(order_id) do |order|
              order.state = state
            end

            load_order(order_id) do |order|
              order.state.should == state
            end
          end
          let(:parameters) { {:read_length => 102, :hash => { :long_attribute => long_attribute}} }
          it "can its parameters updated with a really long parameters" do
            load_order(order_id) do |order|
              order.parameters = parameters
            end

            load_order(order_id) do |order|
              order.parameters.should == parameters
            end
          end


          context "with an intermediate item" do
            subject { Order.new.tap { |o| o.add_target(:intermediate_target) } }
            it "can have item's state updated" do
              load_order(order_id) do |order|
                order[:intermediate_target].each(&:start)
              end
              load_order(order_id) do |order|
                order[:intermediate_target].each { |item| item.status.should == "in_progress" }
              end
            end
          end
          
          context "with an intermediate item in progress"  do
            let(:item_uuid) { "11111111-1111-1111-0000-000000000000" }
            subject do Order.new.tap do |o|
              o.add_target(:intermediate_target);  
              o[:intermediate_target].each &:start
            end
            end
            it "can have item's uuid updated" do
              load_order(order_id) do |order|
                order[:intermediate_target].first.uuid =  item_uuid
              end
              load_order(order_id) do |order|
                order[:intermediate_target].first.uuid.should == item_uuid
              end
            end
          end

          context "with an item assigned to a batch" do
            let(:batch) { Organization::Batch.new }
            let(:item) { Order::Item.new(:batch => batch) }
            subject do 
              Order.new.tap do |order|
                order[:role] = []
                order[:role] << item
              end
            end

            it "saves item batch" do
              load_order(order_id) do |order|
                order["role"].first.batch.should == batch
              end
            end
          end

          it "saves its status" do
            load_order(order_id) do |order|
              order.cancel
            end
            load_order(order_id) do |order|
              order.cancel?.should == true
            end
          end
        end
      end

      context "with a creator" do
        let(:creator) { User.new }
        subject { Order.new(:creator => creator) }

        it "can be saved reloaded" do
          order_id = save(subject)

          load_order(order_id) do |order|
            order.creator.should == creator
          end
        end
      end

      context "#lookup" do
        it_behaves_like "searchable by item criteria"
      end
    end
  end
end
__END_OF_order_spec.rb__
filename='spec/persistence/sequel/page_shared.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_page_shared.rb__ > $filename
# Spec requirements
require 'persistence/sequel/spec_helper'
  require 'lims/core/persistence/multi_criteria_filter'


shared_examples_for "paginable resource" do |persistor_name|
  let(:persistor) {  store.with_session { |session| session.send(persistor_name) } }
  it_behaves_like "paginable"
end

shared_examples_for "paginable" do
  let(:resource_number) { override_resource_number rescue 25 }
  context "no resources" do
    context "#persistor" do
      subject { persistor }
      its(:count) { should == 0 }
    end

    context "#slice" do
      subject {  persistor.slice(0, 10) } 

      it "is empty" do
        subject.to_a.size == 0
      end
    end


  end

  context "with many resources" do
    let!(:resources) {
      [].tap do |l|
      store.with_session do |session|
        1.upto(25) do |i|
          resource = constructor.call(i)
          session << resource
          l << resource
        end
      end
      end
    }
    context "#persistor" do
      subject { persistor }
      its(:count) { should == resource_number }
    end
    context "#slice" do
      subject {
        persistor.slice(0, 10)
      }
      it "returns the correct number of resource" do
        subject.to_a.size.should== 10
      end

      it "iterate over all" do
        _resources = Array.new(resources)
        subject.each  do |resource|
          resource == resources.shift
        end
      end

    end
    context "#too big slice" do
      subject {
        persistor.slice(0, 30)
      }
      it "returns the correct number of resource" do
        subject.to_a.size.should== resource_number
      end
    end

  end
end
__END_OF_page_shared.rb__
filename='spec/persistence/sequel/plate_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_plate_spec.rb__ > $filename
# Spec requirements
require 'persistence/sequel/spec_helper'

require 'laboratory/plate_and_gel_shared'
require 'persistence/resource_shared'
require 'persistence/sequel/store_shared'
require 'persistence/sequel/multi_criteria_filter_shared'
require 'persistence/sequel/label_filter_shared'
require 'persistence/sequel/order_lookup_filter_shared'
require 'persistence/sequel/batch_filter_shared'

# Model requirements
require 'lims/core/laboratory/plate'

module Lims::Core

  describe "Sequel#Plate " do
    include_context "sequel store"
    include_context "plate or gel factory"

    def last_plate_id(session)
      session.plate.dataset.order_by(:id).last[:id]
    end

    context "8*12 Plate" do
      # Set default dimension to create a plate
      let(:number_of_rows) { 8 }
      let(:number_of_columns) { 12 }
      let(:expected_plate_size) { number_of_rows*number_of_columns }

      context do
        subject { new_plate_with_samples(3) }
        it_behaves_like "storable resource", :plate, {:plates => 1, :wells =>  8*12*3 }
      end

      context "already created plate" do
        let(:aliquot) { new_aliquot }
        before (:each) do
          store.with_session { |session| session << new_empty_plate.tap {|_| _[0] << aliquot} }
        end
        let(:plate_id) { store.with_session { |session| @plate_id = last_plate_id(session) } }

        context "when modified within a session" do
          before do
            store.with_session do |s|
              plate = s.plate[plate_id]
              plate[0].clear
              plate[1]<< aliquot
            end
          end
          it "should be saved" do
            store.with_session do |session|
              f = session.plate[plate_id]
              f[7].should be_empty
              f[1].should == [aliquot]
              f[0].should be_empty
            end
          end
        end
        context "when modified outside a session" do
          before do
            plate = store.with_session do |s|
              s.plate[plate_id]
            end
            plate[0].clear
            plate[1]<< aliquot
          end
          it "should not be saved" do
            store.with_session do |session|
              f = session.plate[plate_id]
              f[7].should be_empty
              f[1].should be_empty
              f[0].should == [aliquot]
            end
          end
        end
        context "should be deletable" do
          before {
            # add some aliquot to the wells
            store.with_session do |session|
            plate = session.plate[plate_id]
            1.upto(10) { |i|  3.times { |j| plate[i] <<  new_aliquot(i,j) } }
            end
          }

          def delete_plate
            store.with_session do |session|
              plate = session.plate[plate_id]
              session.delete(plate)
            end
          end

          it "deletes the plate row" do
            expect { delete_plate }.to change { db[:plates].count}.by(-1)
          end

          it "deletes the well rows" do
            expect { delete_plate }.to change { db[:wells].count}.by(-31)
          end
        end

        context "with a plate type" do
          let(:type) { "plate type" }
          subject { Laboratory::Plate.new(:number_of_rows => number_of_rows,
                                          :number_of_columns => number_of_columns,
                                          :type => type) }

          it "can be saved and reloaded" do
            plate_id = save(subject)                        
            store.with_session do |session|
              plate = session.plate[plate_id]
              plate.type.should == type
            end
          end
        end

        context "#lookup" do
          let(:model) { Laboratory::Plate }
          # These uuids match the uuids defined for the order items 
          # in order_lookup_filter_shared.
          let!(:uuids) {
            ['11111111-2222-0000-0000-000000000000', 
             '22222222-1111-0000-0000-000000000000',
             '00000000-3333-0000-0000-000000000000'].tap do |uuids|
               uuids.each_with_index do |uuid, index|
                 store.with_session do |session|
                   plate =  new_empty_plate.tap { |plate| plate[index] << new_aliquot}
                   session << plate
                   ur = session.new_uuid_resource_for(plate)
                   ur.send(:uuid=, uuid)
                 end
               end
             end
          }

          context "by label" do
            let!(:uuid) {
              store.with_session do |session|
                plate = session.plate[plate_id]
                session.uuid_for!(plate)
              end
            }
            it_behaves_like "labels filtrable"
          end

          context "by order" do
            it_behaves_like "orders filtrable"
          end

          context "by batch" do
            it_behaves_like "batch filtrable"
          end
        end
      end

      context do
        let(:constructor) { lambda { |*_| new_empty_plate } }
        it_behaves_like "paginable resource", :plate
        it_behaves_like "filtrable", :plate
      end
    end
  end
end
__END_OF_plate_spec.rb__
filename='spec/persistence/sequel/sample_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_sample_spec.rb__ > $filename
# Spec requirements
require 'persistence/sequel/spec_helper'

require 'persistence/sequel/store_shared'

# Model requirements
require 'lims/core/persistence/sequel/store'
require 'lims/core/laboratory/sample'

module Lims::Core

  describe Persistence::Sample do
    include_context "prepare tables"
    let(:db) { ::Sequel.sqlite('') }
    let(:store) { Persistence::Sequel::Store.new(db) }
    before (:each) { prepare_table(db) }

    let (:sample) { Laboratory::Sample.new(:name => "Sample 1") }

    context "when created within a session" do
      it "should modify the  samples table" do
        expect do
          store.with_session { |session| session << sample }
        end.to change { db[:samples].count}.by(1) 
      end
    end

    it "should save it" do
      sample_id = store.with_session do |session|
        session << sample
        lambda { session.id_for(sample) }
      end.call 

      store.with_session do |session|
        session.sample[sample_id].name == sample.name
        session.sample[sample_id]== sample
      end
    end
  end
end
__END_OF_sample_spec.rb__
filename='spec/persistence/sequel/search_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_search_spec.rb__ > $filename
# Spec requirements
require 'persistence/sequel/spec_helper'

require 'persistence/sequel/store_shared'
require 'persistence/sequel/page_shared'
require 'persistence/resource_shared'


# Model requirements
require 'lims/core/persistence/sequel/search'
require 'lims/core/laboratory/plate'
require 'lims/core/persistence/order_filter'

require 'logger'
module Lims::Core

  module Persistence

    describe Sequel::Search  do
      include_context "sequel store"

      context "holding a multi criteria filter" do
        let(:criteria) { {:id => 3, :name => "a name" } }
        let(:filter) { MultiCriteriaFilter.new(criteria) }
        let(:model) { Laboratory::Plate }
        subject { Persistence::Search.new( :model => model, :filter => filter) }

        it_behaves_like "storable resource", :search, {:searches => 1 }
      end

      context "holding an order filter" do
        let(:criteria) { {:order => {:item => {:status => "in_progress"}, :status => "pending"}} }
        let(:filter) { OrderFilter.new(criteria) }
        let(:model) { Laboratory::Plate }
        subject { Persistence::Search.new(:model => model, :filter => filter) }
        
        it_behaves_like "storable resource", :search, {:searches => 1}
      end
    end
  end
end

__END_OF_search_spec.rb__
filename='spec/persistence/sequel/session_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_session_spec.rb__ > $filename
# Spec requirements
require 'persistence/sequel/spec_helper'

# Model requirements
require 'lims/core/persistence/sequel/store'
require 'lims/core/persistence/sequel/session'


module Lims::Core::Persistence
  module Sequel
    describe Session do
      context "with sqlite underlying" do
        let(:db) { ::Sequel.sqlite('') }
        let(:store) { Store.new(db) }

        context "#transaction" do
          let(:a) { "A" }
          let(:b) { "B" }
          let(:c) { "C" }

          before() do
              db.create_table :names do
                primary_key :id
                String :name
              end

              Session.any_instance.stub(:save) do |arg|
                case arg
                when "A", "B"
                  db[:names].insert(:name => arg)
                when "C"
                  raise RuntimeError, "Can't save 'C'"
                end
              end
          end

          it "save the 2 if no problem" do
            expect { store.with_session do |s|
              s << a << b
            end }.to change{db[:names].count}.by(2)
          end

          it "saves 0 if the second doesn't save" do
            expect {
              begin
              store.with_session do |s|
              s << a << c
            end
          rescue
          end
            }.to change{db[:names].count}.by(0)
          end

          xit "saves 0 if the second is not valid" do
          end
        end
      end
    end
  end
end
__END_OF_session_spec.rb__
filename='spec/persistence/sequel/spec_helper.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_spec_helper.rb__ > $filename
require 'persistence/spec_helper'

module Helper
def save(object)
  store.with_session do |session|
    session << object
    lambda { session.id_for(object) }
  end.call 
end
end

RSpec.configure do |c|
  c.include Helper
end


__END_OF_spec_helper.rb__
filename='spec/persistence/sequel/spin_column_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_spin_column_spec.rb__ > $filename
# Spec requirements
require 'persistence/sequel/store_shared'
require 'persistence/sequel/spec_helper'
require 'laboratory/tube_shared'
require 'persistence/sequel/label_filter_shared'

# Model requirements
require 'lims/core/laboratory/spin_column'

module Lims::Core
  describe Laboratory::SpinColumn do
    include_context "sequel store"
    
    context "created and added to session" do
      it "modifies the spin column table" do
        expect do
          store.with_session { |session| session << subject }
        end.to change { db[:spin_columns].count }.by(1)
      end

      it "should be reloadable" do
        spin_column_id = save(subject)
        store.with_session do |session|
          spin_column = session.spin_column[spin_column_id]
          spin_column.should eq(session.spin_column[spin_column_id])
        end
      end

      context "created but not added to a session" do
        it "should not be saved" do
          expect do 
            store.with_session { |_| subject }
          end.to change{ db[:spin_columns].count }.by(0)
        end 
      end

      context "already created spin  column" do
        let(:aliquot) { new_aliquot }
        let!(:spin_column_id) { save(subject) }

        context "when modified within a session" do
          before do
            store.with_session do |s|
              spin_column = s.spin_column[spin_column_id]
              spin_column << aliquot
            end
          end
          it "should be saved" do
            store.with_session do |session|
              spin_column = session.spin_column[spin_column_id]
              spin_column.should == [aliquot]
            end
          end
        end

        context "when modified outside a session" do
          before do
            spin_column = store.with_session do |s|
              s.spin_column[spin_column_id]
            end
            spin_column << aliquot
          end
          it "should not be saved" do
            store.with_session do |session|
              spin_column = session.spin_column[spin_column_id]
              spin_column.should be_empty
            end
          end
        end

        context "#lookup by label" do
          let!(:uuid) {
            store.with_session do |session|
              spin_column = session.spin_column[spin_column_id]
              session.uuid_for!(spin_column)
            end
          }

          it_behaves_like "labels filtrable"
        end
      end
    end
  end
end
__END_OF_spin_column_spec.rb__
filename='spec/persistence/sequel/store_shared.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_store_shared.rb__ > $filename

# Spec requirements
require 'spec_helper'

# Model requirements
require 'sequel'
require 'lims/core/persistence/sequel/store'
Sequel.extension :migration

shared_context "prepare tables" do
  def prepare_table(db)
    Sequel::Migrator.run(db, 'db/migrations')
  end
end

Loggers = []
#require 'logger'; Loggers << Logger.new(\$stdout)

shared_context "sequel store" do
    include_context "prepare tables"
    let(:db) {  Sequel.sqlite '' , :loggers => Loggers }
    let(:store) { Lims::Core::Persistence::Sequel::Store.new(db) }
    before (:each) { prepare_table(db) }

end
__END_OF_store_shared.rb__
filename='spec/persistence/sequel/store_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_store_spec.rb__ > $filename
# Spec requirements
require 'persistence/sequel/spec_helper'

# Model requirements
require 'lims/core/persistence/sequel/store'

module Lims::Core::Persistence
    describe Sequel::Store do
      context "initialized with a valid database" do
        let(:db) { ::Sequel.sqlite('') }
        it "must  be valid" do
          expect { described_class.new(db) }.to_not raise_error
        end
      end

      context "initialized with something elese" do
        it "must  be invalid" do
          expect { described_class.new("my database") }.to raise_error
        end
      end
    end
end
__END_OF_store_spec.rb__
filename='spec/persistence/sequel/tag_group_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_tag_group_spec.rb__ > $filename
# Spec requirements
require 'persistence/sequel/spec_helper'

require 'persistence/sequel/store_shared'

# Model requirements
require 'lims/core/persistence/sequel/store'
require 'lims/core/laboratory/tag_group'

module Lims::Core

  describe Persistence::Sequel::TagGroup do
    include_context "prepare tables"
    let(:db) { ::Sequel.sqlite('') }
    let(:store) { Persistence::Sequel::Store.new(db) }
    before (:each) { prepare_table(db) }

    let (:old_oligo) { Laboratory::Oligo.new ("AAA") }
    let (:new_oligo) { Laboratory::Oligo.new ("TTT") }
    let (:group)  { Laboratory::TagGroup.new("my group", old_oligo) }
    let (:empty_group)  { Laboratory::TagGroup.new("empty group") }

    context "created and added to session" do
      it "modifies the tag_groups table" do
        expect do
          store.with_session { |s| s << group }
        end.to change { db[:tag_groups].count }.by(1)
      end

      it "modifies the tag_group_associations table" do
        expect do
          store.with_session { |s| s << group }
        end.to change { db[:tag_group_associations].count }.by(1)
      end

      context "existing in the database" do
        # The '!' is important, the session needs to be created before running
        # the example.
        let!(:group_id) {
          store.with_session do |session|
          session << group
          lambda { session.id_for(group) }
          end.call 
        }

        it "should be reloadable" do
          store.with_session do |session|
            loaded_group = session.tag_group[group_id]
            loaded_group.should == group
            loaded_group.name.should == "my group"
            loaded_group[0].should == Laboratory::Oligo.new(old_oligo.sequence)
          end
        end

        it "should be updated when modified" do
          store.with_session do |session|
            session.tag_group[group_id][0] = new_oligo
          end

          store.with_session do |session|
            session.tag_group[group_id][0].should == new_oligo
          end
        end

        context "adding a new tag" do
          def add_a_new_tag 
            store.with_session do |session|
              session.tag_group[group_id] << new_oligo
            end
          end
          it "should change the tag_group_association table" do
            expect { add_a_new_tag }.to change { db[:tag_group_associations].count }.by(1)
          end
          it "should change the oligos table" do
            expect { add_a_new_tag }.to change { db[:oligos].count }.by(1)
          end

          it "should save the new oligo" do
            add_a_new_tag
            store.with_session do |session|
              session.tag_group[group_id].content.should == [old_oligo, new_oligo]
              session.tag_group[group_id].should == Laboratory::TagGroup.new(group.name, old_oligo, new_oligo)
            end
          end


          context "already saved" do
            let!(:new_oligo_id)  { save(new_oligo) }
            it "shouldn't change the oligos table" do
              expect { store.with_session do |s|
                s .tag_group[group_id] << s.oligo[new_oligo_id]
              end
              }.to change { db[:oligos].count }.by(0)
            end
          end
        end
      end

      context "created but not added to a session" do
        it "should not be saved" do
          expect do 
            store.with_session { |_| empty_group }
          end.to change{ db[:tag_groups].count }.by(0)
        end 
      end
    end
  end
end
__END_OF_tag_group_spec.rb__
filename='spec/persistence/sequel/tube_rack_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_tube_rack_spec.rb__ > $filename
# Spec requirements
require 'persistence/sequel/spec_helper'

require 'laboratory/tube_rack_shared'
require 'persistence/resource_shared'
require 'persistence/sequel/store_shared'
require 'persistence/sequel/page_shared'
require 'persistence/sequel/multi_criteria_filter_shared'
require 'persistence/sequel/label_filter_shared'


# Model requirements
require 'lims/core/laboratory/tube_rack'

require 'lims-core/persistence/label_filter'
require 'lims-core/laboratory/labellable'
require 'lims-core/laboratory/sanger_barcode'

module Lims::Core

  describe "Sequel#TubeRack " do
    include_context "sequel store"
    include_context "tube_rack factory"

    include

    def last_tube_rack_id(session)
      session.tube_rack.dataset.order_by(:id).last[:id]
    end

    context "8*12 TubeRack" do
      # Set default dimension to create a tube_rack
      let(:number_of_rows) { 8 }
      let(:number_of_columns) { 12 }
      let(:expected_tube_rack_size) { number_of_rows*number_of_columns }

      context do
        subject { new_tube_rack_with_samples(3) }
        it_behaves_like "storable resource", :tube_rack, {:tube_racks => 1, :tubes =>  8*12, :tube_rack_slots => 8*12, :aliquots => 4*8*12 }
      end

      context "already created tube_rack" do
        let(:tube) { new_empty_tube << aliquot }
        let(:aliquot) { new_aliquot }
        before (:each) do
          store.with_session { |session| session << new_empty_tube_rack().tap {|_| _[0]=  tube } }
        end
        let(:tube_rack_id) { store.with_session { |session| @tube_rack_id = last_tube_rack_id(session) } }

        context "when modified within a session" do
          before do
            store.with_session do |s|
              tube_rack = s.tube_rack[tube_rack_id]
              tube_rack[0].clear
              tube_rack[1]= new_empty_tube
              tube_rack[1]<< aliquot
            end
          end
          it "should be saved" do
            store.with_session do |session|
              f = session.tube_rack[tube_rack_id]
              f[0].should == [] # empty tube
              f[1].should == [aliquot]
              f[7].should be_nil # not tube
            end
          end
        end
        context "when modified outside a session" do
          before do
            tube_rack = store.with_session do |s|
              s.tube_rack[tube_rack_id]
            end
            tube_rack[0].clear
            tube_rack[1]= new_empty_tube
            tube_rack[1]<< aliquot
          end
          it "should not be saved" do
            store.with_session do |session|
              f = session.tube_rack[tube_rack_id]
              f[7].should be_nil
              f[1].should be_nil
              f[0].should == [aliquot]
            end
          end
        end
        context "should be deletable" do
          before {
            # add some aliquot to the tube
            store.with_session do |session|
            tube_rack = session.tube_rack[tube_rack_id]
            1.upto(10) { |i|  3.times { |j| tube_rack[i] = (new_empty_tube <<  new_aliquot(i,j)) } }
            end
          }

          def delete_tube_rack
            store.with_session do |session|
              tube_rack = session.tube_rack[tube_rack_id]
              session.delete(tube_rack)
            end
          end

          it "deletes the tube_rack row" do
            expect { delete_tube_rack }.to change { db[:tube_racks].count}.by(-1)
          end

          it "deletes the tubes rows" do
            expect { delete_tube_rack }.to change { db[:tube_rack_slots].count}.by(-96)
          end
        end

        context "#lookup by label" do
          let!(:uuid) {
            store.with_session do |session|
              tube_rack = session.tube_rack[tube_rack_id]
              session.uuid_for!(tube_rack)
            end
          }

          it_behaves_like "labels filtrable"

        end
      end

      context do
        let(:constructor) { lambda { |*_| new_empty_tube_rack } }
        it_behaves_like "paginable resource", :tube_rack
        it_behaves_like "filtrable", :tube_rack
      end
    end
  end
end
__END_OF_tube_rack_spec.rb__
filename='spec/persistence/sequel/tube_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_tube_spec.rb__ > $filename
# Spec requirements
require 'persistence/sequel/spec_helper'

require 'persistence/sequel/store_shared'
require 'laboratory/tube_shared'
require 'persistence/sequel/label_filter_shared'
require 'persistence/sequel/order_lookup_filter_shared'
require 'persistence/sequel/batch_filter_shared'

# Model requirements
require 'lims/core/persistence/sequel/store'
require 'lims/core/laboratory/tube'

module Lims::Core
  describe Laboratory::Tube do
    include_context "prepare tables"
    include_context "tube factory"
    let(:db) { ::Sequel.sqlite('') }
    let(:store) { Persistence::Sequel::Store.new(db) }
    before (:each) { prepare_table(db) }

    context "created and added to session" do
      it "modifies the tubes table" do
        expect do
          store.with_session { |s| s << subject }
        end.to change { db[:tubes].count }.by(1)
      end

      it "should be reloadable" do
        tube_id = save(subject)
        store.with_session do |session|
          tube = session.tube[tube_id]
          tube.should eq(session.tube[tube_id])
        end
      end

      context "created but not added to a session" do
        it "should not be saved" do
          expect do 
            store.with_session { |_| subject }
          end.to change{ db[:tubes].count }.by(0)
        end 
      end

      context "already created tube" do
        let(:aliquot) { new_aliquot }
        let!(:tube_id) { save(subject) }

        context "when modified within a session" do
          before do
            store.with_session do |s|
              tube = s.tube[tube_id]
              tube << aliquot
            end
          end
          it "should be saved" do
            store.with_session do |session|
              tube = session.tube[tube_id]
              tube.should == [aliquot]
            end
          end
        end
        context "when modified outside a session" do
          before do
            tube = store.with_session do |s|
              s.tube[tube_id]
            end
            tube << aliquot
          end
          it "should not be saved" do
            store.with_session do |session|
              tube = session.tube[tube_id]
              tube.should be_empty
            end
          end
        end

        context "with a tube type" do
          let(:type) { "Eppendorf" }
          subject { Laboratory::Tube.new(:type => type) } 

          it "can be saved and reloaded" do
            tube_id = save(subject)
            
            store.with_session do |session|
              tube = session.tube[tube_id]
              tube.type.should == type
            end
          end
        end

        context "with a tube max volume" do
          let(:max_volume) { 2 }
          subject { Laboratory::Tube.new(:max_volume => max_volume) } 

          it "can be saved and reloaded" do
            tube_id = save(subject)
            
            store.with_session do |session|
              tube = session.tube[tube_id]
              tube.max_volume.should == max_volume
            end
          end
        end

        context "#lookup" do
          let(:model) { Laboratory::Tube }
          # These uuids match the uuids defined for the order items 
          # in order_lookup_filter_shared.
          let!(:uuids) {
            ['11111111-2222-0000-0000-000000000000',
             '22222222-1111-0000-0000-000000000000',
             '00000000-3333-0000-0000-000000000000'].tap do |uuids|
               uuids.each_with_index do |uuid, index|
                store.with_session do |session|
                  tube = Laboratory::Tube.new
                  session << tube
                  ur = session.new_uuid_resource_for(tube)
                  ur.send(:uuid=, uuid)
                end
              end
            end
          }

          context "by label" do
            let!(:uuid) {
              store.with_session do |session|
                tube = session.tube[tube_id]
                session.uuid_for!(tube)
              end
            }
            it_behaves_like "labels filtrable"
          end

          context "by order" do
            it_behaves_like "orders filtrable"
          end

          context "by batch" do
            it_behaves_like "batch filtrable"
          end
        end
      end
    end
  end
end

__END_OF_tube_spec.rb__
filename='spec/persistence/sequel/uuid_resource_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_uuid_resource_spec.rb__ > $filename
require 'persistence/sequel/spec_helper'
require 'persistence/sequel/store_shared'

# Model requirements
require 'lims/core/persistence/sequel/store'
require 'lims/core/persistence/uuid_resource'

module Lims::Core
  module Persistence
    describe Sequel::UuidResource do
      include_context "sequel store"
#      before  { Uuids::UuidResource.stub(:pack) { |s| s }  }
#      before  { Uuids::UuidResource.stub(:unpack) { |s| s }  }
      context "#saving" do
        before (:each) {
          db[:uuid_resources].delete
        }
        let(:model) { Laboratory::Tube }
        let(:key) { 1 }
        subject { Uuids::UuidResource.new(:model_class => model, :key => key) }
        it "should modify the uuids table" do
          expect {
            store.with_session do |s|
            s << subject
            end
          }.to change { db[:uuid_resources].count }.by(1) 
        end
        context "reloaded" do
          let!(:uuid) { store.with_session do |session|
            session << subject
            subject.uuid
          end
          }

          let(:loaded) {
            store.with_session do |session|
            loaded = session.uuid_resource[:uuid => uuid]
            end
          }

          its(:key) { should == loaded.key }
          its(:model_class) { should == loaded.model_class }
        end

        context "bound to an object" do
          let(:sequence) { "AGA" }
          let(:model) { Laboratory::Oligo.new(:sequence =>sequence) }
          let(:uuid) {
            store.with_session do |session|
              session << model
              session.uuid_for!(model)
            end
          }

          context "when created" do
            it "modifies the uuid table " do
              expect { 
                uuid
              }.to change { db[:uuid_resources].count }.by(1)
            end
          end

          context "already saved" do
            before(:each) { uuid }
            it "reloads the same object" do
              store.with_session do |session|
                loaded = session[uuid]
                loaded.should == model
                loaded.sequence.should == sequence
              end
            end

            it "find the uuid for the object" do
              object_id = store.with_session do |session|
                session.id_for(session[uuid])
              end
              store.with_session do |session|
                loaded = session.oligo[object_id]
                session.uuid_for(loaded).should == uuid
              end
            end

            it "doesn't allow asking for an uuid of unmanaged object " do
              expect do
                store.with_session do |session|
                  session.uuid_for(model).should == uuid
                end
              end.to raise_error(RuntimeError)
            end
          end
        end
      end
    end
  end
end
__END_OF_uuid_resource_spec.rb__
filename='spec/persistence/spec_helper.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_spec_helper.rb__ > $filename
require 'spec_helper'

__END_OF_spec_helper.rb__
filename='spec/spec_helper.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_spec_helper.rb__ > $filename
  shared_examples "requires" do |attribute|
    context "without #{attribute}" do
      let(:excluded_parameters) { [attribute] }
      it "'s not valid" do
        subject.valid?.should == false
      end
    end

  end

__END_OF_spec_helper.rb__
filename='spec/uuids/uuid_resource_spec.rb'
mkdir -p $(dirname $filename)
cat <<__END_OF_uuid_resource_spec.rb__ > $filename
# vi: ts=2:sts=2:et:sw=2 spell:spelllang=en
require 'persistence/spec_helper'

require 'lims/core/uuids/uuid_resource'

module Lims::Core
  module Uuids
    describe UuidResource do
      context "#class" do
        subject { UuidResource }
        it "validates valid uuid" do
          subject.valid?("12345678-abcd-1234-ABCD-1234567890ab").should be_true
        end

        it "invalidates unvaild uuid" do
          subject.valid?("12345678-Zbcd-1234-ABCD-1234567890ab").should be_false
          subject.valid?("12345678-Zbcd-1234-ABCD-1234567890").should be_false
          subject.valid?("I am not a uuid").should be_false
        end

        it "generates a UUID" do
          subject.valid?(subject.generate_uuid()).should be_true
        end 

        it "generates different UUID" do
          u1,u2 = 2.times { subject.generate_uuid()}
          u1.should_not == u2
        end

        context "#conversion" do
          context "to packed string" do
            let(:to_pack) { "41424344-4546-4748-6162-636465666768" }
            let(:packed) { "ABCDEFGHabcdefgh" }

            it "pack" do
              subject.pack(to_pack).should == packed
            end

            it "unpack" do
              subject.unpack(packed).should == to_pack
            end
            it "converts unpacked to valid string" do
              subject.valid?(subject.unpack(packed))
            end
          end
          context "to bignum" do
            let(:bignum) { 0x12345678abcd1234abcd1234567890ab }
            let(:string) { "12345678-abcd-1234-abcd-1234567890ab" }

            it "converts string to bignum" do
              subject.string_to_bignum(string).should == bignum
            end

            it "converts bignum to string" do
              subject.bignum_to_string(bignum).should == string
            end
            it "converts bignum to valid string" do
              subject.valid?(subject.bignum_to_string(bignum))
            end
          end
        end
      end


      context "created without an uuid" do
        subject { described_class.new(:modeli => "model", :key => 1) }
        it "should create an new uuid" do
          subject.uuid.should_not be_nil
        end
      end
      context "created with an uuid" do
        let(:uuid) { UuidResource.generate_uuid }
        subject { described_class.new(:model => "model", :key => 1, :uuid => uuid) }
        it "keeps the same uuid" do
          subject.uuid.should == uuid
        end
      end
    end
  end
end
__END_OF_uuid_resource_spec.rb__
